--- START FILE: backend/.env ---
 PORT=3000
 CLIENT_ORIGIN=http://localhost:3001
 JWT_SECRET=please_do_not_hack_my_very_first_app_SLUFF
 DATABASE_URL="postgres://sluff_db_user:x8JZaL7JJiOOKImyJyhqknZPU1OqbGEA@dpg-d1hp6enfte5s73aji2dg-a.oregon-postgres.render.com/sluff_db"
+AI_SECRET_KEY=a_very_secret_and_long_key_for_ai_studio_to_use_Random3228848293488229998882838823823_324233232223422_923949943929324323223
--- END FILE: backend/.env ---

--- START FILE: backend/.gitignore ---
node_modules/
.env
--- END FILE: backend/.gitignore ---

--- START FILE: backend/ai_tools.js ---
// --- START FILE: Backend/ai_tools.js ---

/**
 * This module contains functions that can be called by the AI assistant.
 * These functions provide read-only access to live application data.
 * IMPORTANT: Avoid any functions here that modify data unless you have
 * extremely robust security and confirmation checks in place.
 */

// We need the global 'state' to access in-memory table data.
const state = require('./game/gameState');

/**
 * Retrieves the complete, real-time game state for a specific table ID.
 * @param {object} args - The arguments for the function.
 * @param {string} args.tableId - The ID of the table to look up (e.g., "table-1").
 * @returns {Promise<object>} The full state of the requested table.
 */
async function getTableState({ tableId }) {
  const table = state.getTableById(tableId);
  if (!table) {
    return { error: `Table with ID '${tableId}' not found.` };
  }
  // The getStateForClient() method already prepares a clean object for us.
  return table.getStateForClient();
}

/**
 * Retrieves a user's profile, stats, and current token balance from the database.
 * @param {object} args - The arguments for the function.
 * @param {object} pool - The PostgreSQL connection pool.
 * @param {string} args.username - The username of the player to look up.
 * @returns {Promise<object>} The user's combined profile and token data.
 */
async function getUserByUsername({ username }, pool) {
  if (!pool) return { error: "Database connection not available." };
  
  try {
    const query = `
      SELECT 
        u.id, u.username, u.email, u.wins, u.losses, u.washes, u.is_admin,
        COALESCE(SUM(t.amount), 0) as tokens
      FROM users u
      LEFT JOIN transactions t ON u.id = t.user_id
      WHERE u.username = $1
      GROUP BY u.id;
    `;
    const { rows } = await pool.query(query, [username]);

    if (rows.length === 0) {
      return { error: `User with username '${username}' not found.` };
    }
    
    // Ensure tokens are formatted consistently
    rows[0].tokens = parseFloat(rows[0].tokens).toFixed(2);
    return rows[0];

  } catch (err) {
    console.error(`[AI Tool Error] Failed to get user ${username}:`, err);
    return { error: "A database error occurred." };
  }
}

// Export the functions so our switchboard can use them.
module.exports = {
  getTableState,
  getUserByUsername,
};
// --- END FILE: Backend/ai_tools.js ---
--- END FILE: backend/ai_tools.js ---

--- START FILE: backend/Control.html ---
--- END FILE: backend/Control.html ---

--- START FILE: backend/package.json ---
{
  "name": "sluff-server",
  "version": "1.0.0",
  "description": "Sluff Card Game Server",
  "main": "src/server.js",
  "scripts": {
    "start": "node src/server.js",
    "dev": "nodemon src/server.js",
    "test": "node tests/Table.integration.test.js"
  },
  "dependencies": {
    "bcrypt": "^6.0.0",
    "cors": "^2.8.5",
    "dotenv": "^16.6.1",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.2",
    "pg": "^8.16.3",
    "socket.io": "^4.5.4",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "nodemon": "^2.0.22"
  }
}
--- END FILE: backend/package.json ---

--- START FILE: backend/game/Table.js ---
// backend/game/Table.js

const { SERVER_VERSION, TABLE_COSTS, BID_HIERARCHY, PLACEHOLDER_ID, deck, SUITS, BID_MULTIPLIERS } = require('./constants');
const gameLogic = require('./logic');
const BotPlayer = require('./BotPlayer');
const transactionManager = require('../db/transactionManager');
const { shuffle } = require('../../utils/shuffle');

const BOT_NAMES = ["Mike Knight", "Grandma Joe", "Grampa Blane", "Kimba", "Courtney Sr.", "Cliff"];

class Table {
    constructor(tableId, theme, tableName, io, pool, emitLobbyUpdateCallback) {
        this.io = io;
        this.pool = pool;
        this.emitLobbyUpdateCallback = emitLobbyUpdateCallback;
        this.tableId = tableId;
        this.tableName = tableName;
        this.theme = theme;
        this.serverVersion = SERVER_VERSION;
        this.state = "Waiting for Players";
        this.players = {};
        this.playerOrderActive = [];
        this.scores = {};
        this.gameStarted = false;
        this.gameId = null;
        this.playerMode = null;
        this.dealer = null;
        this.internalTimers = {};
        this.bots = {};
        this._nextBotId = -1;
        this.pendingBotAction = null;
        this._initializeNewRoundState();
    }
    
    // =================================================================
    // PUBLIC: Forfeit & Timeout Logic
    // =================================================================

    startForfeitTimer(requestingUserId, targetPlayerName) {
        if (!this.players[requestingUserId] || this.internalTimers.forfeit) return;
        const targetPlayer = Object.values(this.players).find(p => p.playerName === targetPlayerName);
        if (!targetPlayer || !targetPlayer.disconnected) {
            return this.io.to(this.players[requestingUserId].socketId).emit("error", { message: "Cannot start timer: Player is not disconnected." });
        }
        console.log(`[${this.tableId}] Forfeit timer started for ${targetPlayerName} by ${this.players[requestingUserId].playerName}.`);
        this.forfeiture.targetPlayerName = targetPlayerName;
        this.forfeiture.timeLeft = 120;
        this.internalTimers.forfeit = setInterval(() => {
            if (!this.forfeiture.targetPlayerName) return this._clearForfeitTimer();
            this.forfeiture.timeLeft -= 1;
            if (this.forfeiture.timeLeft <= 0) {
                this._resolveForfeit(targetPlayerName, "timeout");
            } else {
                this._emitUpdate();
            }
        }, 1000);
        this._emitUpdate();
    }

    forfeitGame(userId) {
        const playerName = this.players[userId]?.playerName;
        if (!playerName || !this.gameStarted) return;
        this._resolveForfeit(playerName, "voluntary forfeit");
    }

    // =================================================================
    // PUBLIC: Player & Connection Management
    // =================================================================
    
    async joinTable(user, socketId) {
        const { id, username } = user;
        const isPlayerAlreadyInGame = !!this.players[id];

        if (isPlayerAlreadyInGame) {
            // This is a returning player, just update their connection status
            this.players[id].disconnected = false;
            this.players[id].socketId = socketId;
        } else {
            // This is a new player
            const activePlayersCount = Object.values(this.players).filter(p => !p.isSpectator).length;

            if (this.gameStarted || activePlayersCount >= 4) {
                // Game is full or started, add as spectator
                this.players[id] = { userId: id, playerName: username, socketId: socketId, isSpectator: true, disconnected: false };
            } else {
                // Check if they can afford to join
                const tableCost = TABLE_COSTS[this.theme] || 0;
                try {
                    const tokenResult = await this.pool.query("SELECT SUM(amount) as tokens FROM transactions WHERE user_id = $1", [id]);
                    const userTokens = parseFloat(tokenResult.rows[0]?.tokens || 0);
                    if (userTokens < tableCost) {
                        return this.io.to(socketId).emit("error", { message: `You need ${tableCost} tokens to join. You have ${userTokens.toFixed(2)}.` });
                    }
                    // Add as an active player
                    this.players[id] = { userId: id, playerName: username, socketId: socketId, isSpectator: false, disconnected: false };
                } catch (err) {
                    return this.io.to(socketId).emit("error", { message: "A server error occurred trying to join the table." });
                }
            }
        }

        if (!this.scores[username]) {
            this.scores[username] = 120;
        }

        this._recalculateActivePlayerOrder();

        const activePlayersAfterJoin = this.playerOrderActive.length;
        if (!this.gameStarted) {
            if (activePlayersAfterJoin >= 3) {
                this.state = "Ready to Start";
            } else {
                this.state = "Waiting for Players";
            }
        }
        
        await this._syncPlayerTokens(Object.keys(this.players));
        this.io.to(socketId).emit("joinedTable", { tableId: this.tableId, gameState: this.getStateForClient() });
        this._emitUpdate();
        this.emitLobbyUpdateCallback();
    }

    addBotPlayer() {
        const currentPlayers = Object.values(this.players).filter(p => !p.isSpectator);
        if (currentPlayers.length >= 4) return;

        const currentBotNames = new Set(currentPlayers.filter(p => p.isBot).map(p => p.playerName));
        const availableNames = BOT_NAMES.filter(name => !currentBotNames.has(name));

        if (availableNames.length === 0) {
            console.log(`[${this.tableId}] No available bot names to add.`);
            return;
        }

        const botName = availableNames[Math.floor(Math.random() * availableNames.length)];
        
        const botId = this._nextBotId--;
        this.players[botId] = {
            userId: botId,
            playerName: botName,
            socketId: null,
            isSpectator: false,
            disconnected: false,
            isBot: true
        };
        this.bots[botId] = new BotPlayer(botId, botName, this);
        if (!this.scores[botName]) this.scores[botName] = 120;
        this._recalculateActivePlayerOrder();
        const activePlayers = this.playerOrderActive.length;
        if (activePlayers >= 3 && !this.gameStarted) this.state = 'Ready to Start';
        this._emitUpdate();
        this.emitLobbyUpdateCallback();
    }

    async leaveTable(userId) {
        if (!this.players[userId]) return;
        const playerInfo = this.players[userId];
        const safeLeaveStates = ["Waiting for Players", "Ready to Start", "Game Over"];
        if (safeLeaveStates.includes(this.state) || playerInfo.isSpectator) { delete this.players[userId]; }
        else if (this.gameId && this.gameStarted) { this.disconnectPlayer(userId); }
        else { delete this.players[userId]; }
        if (playerInfo.isBot) {
            delete this.bots[userId];
        }
        this._recalculateActivePlayerOrder();
        await this._syncPlayerTokens(Object.keys(this.players));
        this._emitUpdate();
        this.emitLobbyUpdateCallback();
    }
    
    disconnectPlayer(userId) {
        const player = this.players[userId];
        if (!player) return;
        if (!this.gameStarted || player.isSpectator) {
            delete this.players[userId];
            this._recalculateActivePlayerOrder();
        } else {
            console.log(`[${this.tableId}] Player ${player.playerName} has disconnected.`);
            player.disconnected = true;
        }
        this._emitUpdate();
        this.emitLobbyUpdateCallback();
    }
    
    reconnectPlayer(userId, socket) {
        if (!this.players[userId] || !this.players[userId].disconnected) return;
        console.log(`[${this.tableId}] Reconnecting user ${this.players[userId].playerName}.`);
        this.players[userId].disconnected = false;
        this.players[userId].socketId = socket.id;
        socket.join(this.tableId);
        if (this.forfeiture.targetPlayerName === this.players[userId].playerName) {
            this._clearForfeitTimer();
            console.log(`[${this.tableId}] Cleared timeout for reconnected player ${this.players[userId].playerName}.`);
        }
        this._emitUpdate();
        this.emitLobbyUpdateCallback();
    }

    async startGame(requestingUserId) {
        if (this.gameStarted) return;
        if (!this.players[requestingUserId] || this.players[requestingUserId].isSpectator) return;
        const activePlayers = Object.values(this.players).filter(p => !p.isSpectator && !p.disconnected);
        if (activePlayers.length < 3) { 
            const userSocket = this.io.sockets.sockets.get(this.players[requestingUserId].socketId);
            if (userSocket) {
                userSocket.emit("gameStartError", { message: "Need at least 3 players to start." });
            }
            return;
        }
        this.playerMode = activePlayers.length;
        const activePlayerIds = activePlayers.map(p => p.userId);
        const humanIds = activePlayers.filter(p => !p.isBot).map(p => p.userId);
        try {
            this.gameId = await transactionManager.createGameRecord(this.pool, this);
            if (humanIds.length > 0) {
                await transactionManager.handleGameStartTransaction(this.pool, this, humanIds, this.gameId);
            }
            this.gameStarted = true;
            activePlayers.forEach(p => { if (this.scores[p.playerName] === undefined) this.scores[p.playerName] = 120; });
            if (this.playerMode === 3 && this.scores[PLACEHOLDER_ID] === undefined) { this.scores[PLACEHOLDER_ID] = 120; }
            const shuffledPlayerIds = shuffle([...activePlayerIds]);
            this.dealer = shuffledPlayerIds[0];
            this._recalculateActivePlayerOrder();
            this._initializeNewRoundState();
            this.state = "Dealing Pending";
            await this._syncPlayerTokens(activePlayerIds);
            this._emitUpdate();
            this.emitLobbyUpdateCallback();
        } catch (err) {
            const insufficientFundsMatch = err.message.match(/(.+) has insufficient tokens/);
            if (insufficientFundsMatch) {
                const brokePlayerName = insufficientFundsMatch[1];
                const brokePlayer = Object.values(this.players).find(p => p.playerName === brokePlayerName);
                if (brokePlayer) {
                    delete this.players[brokePlayer.userId];
                    this._recalculateActivePlayerOrder();
                    this.playerMode = this.playerOrderActive.length;
                    this.state = this.playerMode >= 3 ? "Ready to Start" : "Waiting for Players";
                    this.gameId = null; 
                    this.io.to(this.tableId).emit("gameStartFailed", { message: err.message, kickedPlayer: brokePlayerName });
                    this._emitUpdate();
                    this.emitLobbyUpdateCallback();
                }
            } else {
                const userSocket = this.io.sockets.sockets.get(this.players[requestingUserId].socketId);
                if (userSocket) {
                    userSocket.emit("gameStartError", { message: err.message || "A server error occurred during buy-in." });
                }
                this.gameStarted = false; 
                this.playerMode = null;
                this.gameId = null;
            }
        }
    }
    
    dealCards(requestingUserId) {
        if (this.state !== "Dealing Pending" || requestingUserId !== this.dealer) return;
        const shuffledDeck = shuffle([...deck]);
        this.playerOrderActive.forEach((playerId, i) => {
            const playerName = this.players[playerId].playerName;
            this.hands[playerName] = shuffledDeck.slice(i * 11, (i + 1) * 11);
        });
        this.widow = shuffledDeck.slice(11 * this.playerOrderActive.length);
        this.originalDealtWidow = [...this.widow];
        this.state = "Bidding Phase";
        this.biddingTurnPlayerId = this.playerOrderActive[0];
        this._emitUpdate();
    }

    placeBid(userId, bid) {
        if (userId !== this.biddingTurnPlayerId) return;
        const player = this.players[userId];
        if (!player) return;

        if (this.state === "Awaiting Frog Upgrade Decision") {
            if (userId !== this.originalFrogBidderId || (bid !== "Heart Solo" && bid !== "Pass")) return;
            if (bid === "Heart Solo") { this.currentHighestBidDetails = { userId, playerName: player.playerName, bid: "Heart Solo" }; }
            this.biddingTurnPlayerId = null;
            this._resolveBiddingFinal();
            return;
        }
        if (this.state !== "Bidding Phase" || !BID_HIERARCHY.includes(bid) || this.playersWhoPassedThisRound.includes(userId)) return;
        
        const currentHighestBidIndex = this.currentHighestBidDetails ? BID_HIERARCHY.indexOf(this.currentHighestBidDetails.bid) : -1;
        if (bid !== "Pass" && BID_HIERARCHY.indexOf(bid) <= currentHighestBidIndex) return;
        
        if (bid !== "Pass") {
            this.currentHighestBidDetails = { userId, playerName: player.playerName, bid };
            if (bid === "Frog" && !this.originalFrogBidderId) this.originalFrogBidderId = userId;
            if (bid === "Solo" && this.originalFrogBidderId && userId !== this.originalFrogBidderId) this.soloBidMadeAfterFrog = true;
        } else { this.playersWhoPassedThisRound.push(userId); }
        
        const activeBiddersRemaining = this.playerOrderActive.filter(id => !this.playersWhoPassedThisRound.includes(id));
        if ((this.currentHighestBidDetails && activeBiddersRemaining.length <= 1) || this.playersWhoPassedThisRound.length === this.playerOrderActive.length) {
            this.biddingTurnPlayerId = null;
            this._checkForFrogUpgrade();
        } else {
            let currentBidderIndex = this.playerOrderActive.indexOf(userId);
            let nextBidderId = null;
            for (let i = 1; i < this.playerOrderActive.length; i++) {
                let potentialNextBidderId = this.playerOrderActive[(currentBidderIndex + i) % this.playerOrderActive.length];
                if (!this.playersWhoPassedThisRound.includes(potentialNextBidderId)) {
                    nextBidderId = potentialNextBidderId;
                    break;
                }
            }
            if (nextBidderId) { this.biddingTurnPlayerId = nextBidderId; }
            else { this._checkForFrogUpgrade(); }
        }
        this._emitUpdate();
    }
    
    chooseTrump(userId, suit) {
        if (this.state !== "Trump Selection" || this.bidWinnerInfo?.userId !== userId || !["S", "C", "D"].includes(suit)) {
            return;
        }
        this.trumpSuit = suit;
        this._transitionToPlayingPhase();
    }

    submitFrogDiscards(userId, discards) {
        const player = this.players[userId];
        if (!player || this.state !== "Frog Widow Exchange" || this.bidWinnerInfo?.userId !== userId || !Array.isArray(discards) || discards.length !== 3) {
            return;
        }
        const currentHand = this.hands[player.playerName];
        if (!discards.every(card => currentHand.includes(card))) {
            return this.io.to(player.socketId).emit("error", { message: "Invalid discard selection." });
        }
        this.widowDiscardsForFrogBidder = discards;
        this.hands[player.playerName] = currentHand.filter(card => !discards.includes(card));
        this._transitionToPlayingPhase();
    }

    playCard(userId, card) {
        if (userId !== this.trickTurnPlayerId) return;
        const player = this.players[userId];
        if (!player) return;

        const hand = this.hands[player.playerName];
        if (!hand || !hand.includes(card)) return;
        
        const isLeading = this.currentTrickCards.length === 0;
        const playedSuit = gameLogic.getSuit(card);
        if (isLeading) {
            if (playedSuit === this.trumpSuit && !this.trumpBroken && !hand.every(c => gameLogic.getSuit(c) === this.trumpSuit)) {
                const msg = "Cannot lead trump until it is broken.";
                console.error(`[${this.tableId}] ILLEGAL MOVE by ${player.playerName}: ${msg}`);
                return this.io.to(player.socketId).emit("error", { message: msg });
            }
        } else {
            const leadCardSuit = this.leadSuitCurrentTrick;
            const hasLeadSuit = hand.some(c => gameLogic.getSuit(c) === leadCardSuit);
            if (hasLeadSuit && playedSuit !== leadCardSuit) {
                const msg = `Must follow suit (${SUITS[leadCardSuit]}).`;
                console.error(`[${this.tableId}] ILLEGAL MOVE by ${player.playerName}: ${msg}`);
                return this.io.to(player.socketId).emit("error", { message: msg });
            }
            if (!hasLeadSuit && hand.some(c => gameLogic.getSuit(c) === this.trumpSuit) && playedSuit !== this.trumpSuit) {
                const msg = "You must play trump if you cannot follow suit.";
                console.error(`[${this.tableId}] ILLEGAL MOVE by ${player.playerName}: ${msg}`);
                return this.io.to(player.socketId).emit("error", { message: msg });
            }
        }
        this.hands[player.playerName] = hand.filter(c => c !== card);
        this.currentTrickCards.push({ userId, playerName: player.playerName, card });
        if (isLeading) this.leadSuitCurrentTrick = playedSuit;
        if (playedSuit === this.trumpSuit) this.trumpBroken = true;
        
        const expectedCardsInTrick = this.playerOrderActive.length;
        if (this.currentTrickCards.length === expectedCardsInTrick) {
            this._resolveTrick();
        } else {
            const currentTurnPlayerIndex = this.playerOrderActive.indexOf(userId);
            this.trickTurnPlayerId = this.playerOrderActive[(currentTurnPlayerIndex + 1) % expectedCardsInTrick];
            this._emitUpdate();
        }
    }

    requestNextRound(requestingUserId) {
        if (this.state === "Awaiting Next Round Trigger" && requestingUserId === this.roundSummary?.dealerOfRoundId) { this._advanceRound(); }
    }

    async reset() {
        console.log(`[${this.tableId}] Game is being reset.`);
        this._clearAllTimers();
        const originalPlayers = { ...this.players };
        Object.assign(this, new Table(this.tableId, this.theme, this.tableName, this.io, this.pool, this.emitLobbyUpdateCallback));
        const playerIdsToKeep = [];
        for (const userId in originalPlayers) {
            const playerInfo = originalPlayers[userId];
            if (!playerInfo.disconnected) {
                this.players[userId] = { ...playerInfo, isSpectator: false, socketId: playerInfo.socketId };
                if (playerInfo.isBot) {
                    this.bots[userId] = new BotPlayer(parseInt(userId,10), playerInfo.playerName, this);
                }
                this.scores[playerInfo.playerName] = 120;
                if (!playerInfo.isSpectator) { playerIdsToKeep.push(parseInt(userId, 10)); }
            }
        }
        const botIds = Object.keys(this.bots).map(id => parseInt(id,10));
        this._nextBotId = botIds.length ? Math.min(...botIds) - 1 : -1;
        this._recalculateActivePlayerOrder();
        this.playerMode = this.playerOrderActive.length;
        this.state = this.playerMode >= 3 ? "Ready to Start" : "Waiting for Players";
        await this._syncPlayerTokens(playerIdsToKeep);
        this._emitUpdate();
        this.emitLobbyUpdateCallback();
    }
    
    updateInsuranceSetting(userId, settingType, value) {
        const player = this.players[userId];
        if (!player || !this.insurance.isActive || this.insurance.dealExecuted) return;

        const multiplier = this.insurance.bidMultiplier;
        const parsedValue = parseInt(value, 10);
        if (isNaN(parsedValue)) return;

        if (settingType === 'bidderRequirement' && player.playerName === this.insurance.bidderPlayerName) {
            const minReq = -120 * multiplier;
            const maxReq = 120 * multiplier;
            if (parsedValue >= minReq && parsedValue <= maxReq) {
                this.insurance.bidderRequirement = parsedValue;
            }
        } else if (settingType === 'defenderOffer' && this.insurance.defenderOffers.hasOwnProperty(player.playerName)) {
            const minOffer = -60 * multiplier;
            const maxOffer = 60 * multiplier;
            if (parsedValue >= minOffer && parsedValue <= maxOffer) {
                this.insurance.defenderOffers[player.playerName] = parsedValue;
            }
        } else {
            return;
        }

        const sumOfOffers = Object.values(this.insurance.defenderOffers || {}).reduce((sum, offer) => sum + (offer || 0), 0);
        if (this.insurance.bidderRequirement <= sumOfOffers) {
            this.insurance.dealExecuted = true;
            this.insurance.executedDetails = {
                agreement: {
                    bidderPlayerName: this.insurance.bidderPlayerName,
                    bidderRequirement: this.insurance.bidderRequirement,
                    defenderOffers: { ...this.insurance.defenderOffers }
                }
            };
        }
        this._emitUpdate();
    }


    requestDraw(userId) {
        const player = this.players[userId];
        if (!player || this.drawRequest.isActive || this.state !== 'Playing Phase') return;
        this.drawRequest.isActive = true;
        this.drawRequest.initiator = player.playerName;
        this.drawRequest.votes = {};
        const activePlayers = Object.values(this.players).filter(p => !p.isSpectator);
        activePlayers.forEach(p => {
            this.drawRequest.votes[p.playerName] = (p.playerName === player.playerName) ? 'wash' : null;
        });
        this.drawRequest.timer = 30;
        this.internalTimers.draw = setInterval(() => {
            if (!this.drawRequest.isActive) return clearInterval(this.internalTimers.draw);
            this.drawRequest.timer -= 1;
            if (this.drawRequest.timer <= 0) {
                clearInterval(this.internalTimers.draw);
                this.drawRequest.isActive = false;
                this.io.to(this.tableId).emit("notification", { message: "Draw request timed out. Game resumes." });
                this._emitUpdate();
            } else {
                this._emitUpdate();
            }
        }, 1000);
        this._emitUpdate();
    }

    async submitDrawVote(userId, vote) {
        const player = this.players[userId];
        if (!player || !this.drawRequest.isActive || !['wash', 'split', 'no'].includes(vote) || this.drawRequest.votes[player.playerName] !== null) return;
        
        this.drawRequest.votes[player.playerName] = vote;
    
        if (vote === 'no') {
            clearInterval(this.internalTimers.draw);
            this.drawRequest.isActive = false;
            this.io.to(this.tableId).emit("notification", { message: `${player.playerName} vetoed the draw. Game resumes.` });
            this._emitUpdate();
            return;
        }
    
        const allVotes = Object.values(this.drawRequest.votes);
        if (!allVotes.every(v => v !== null)) {
            this._emitUpdate();
            return;
        }

        clearInterval(this.internalTimers.draw);
        this.drawRequest.isActive = false;
        
        try {
            const voteCounts = allVotes.reduce((acc, v) => { acc[v] = (acc[v] || 0) + 1; return acc; }, {});
            const tableCost = TABLE_COSTS[this.theme] || 0;
            const activePlayers = Object.values(this.players).filter(p => !p.isSpectator);
            let outcomeMessage = "Draw resolved.";
            const transactionPromises = [];
    
            if (voteCounts.wash === activePlayers.length) {
                outcomeMessage = "All players agreed to a wash. All buy-ins returned.";
                activePlayers.forEach(p => {
                    transactionPromises.push(transactionManager.postTransaction(this.pool, { userId: p.userId, gameId: this.gameId, type: 'wash_payout', amount: tableCost, description: `Draw Outcome: Wash` }));
                });
            } else if (voteCounts.wash > 0 && voteCounts.split > 0) {
                outcomeMessage = "A split was agreed upon. Payouts calculated by score.";
                const payoutResult = gameLogic.calculateDrawSplitPayout(this);
                if (payoutResult && payoutResult.payouts) {
                    for (const playerName in payoutResult.payouts) {
                        const pData = payoutResult.payouts[playerName];
                        transactionPromises.push(transactionManager.postTransaction(this.pool, { userId: pData.userId, gameId: this.gameId, type: 'win_payout', amount: pData.totalReturn, description: `Draw Outcome: Split` }));
                    }
                }
            } else {
                outcomeMessage = "The draw resulted in a wash. All buy-ins returned.";
                activePlayers.forEach(p => {
                    transactionPromises.push(transactionManager.postTransaction(this.pool, { userId: p.userId, gameId: this.gameId, type: 'wash_payout', amount: tableCost, description: `Draw Outcome: Wash (Default)` }));
                });
            }
            
            await Promise.all(transactionPromises);
            await transactionManager.updateGameRecordOutcome(this.pool, this.gameId, outcomeMessage);
    
            this.state = "Game Over";
            this.roundSummary = { message: outcomeMessage, isGameOver: true, finalScores: this.scores };
            this._emitUpdate();
            this.emitLobbyUpdateCallback();

            this.internalTimers.drawReset = setTimeout(() => this.reset(), 10000);

        } catch (error) {
            console.error(`[${this.tableId}] Error resolving draw vote:`, error);
            this.io.to(this.tableId).emit("notification", { message: `A server error occurred resolving the draw. Resuming game.` });
            this.drawRequest = this._getInitialDrawRequestState();
            this._emitUpdate();
        }
    }

    // =================================================================
    // INTERNAL: Game Flow and State Transitions (_prefix)
    // =================================================================

    _clearForfeitTimer() {
        if (this.internalTimers.forfeit) {
            clearInterval(this.internalTimers.forfeit);
            delete this.internalTimers.forfeit;
        }
        this.forfeiture = this._getInitialForfeitureState();
    }

    async _resolveForfeit(forfeitingPlayerName, reason) {
        if (this.state === "Game Over" || !this.gameId) return;
        console.log(`[${this.tableId}] Resolving forfeit for ${forfeitingPlayerName}. Reason: ${reason}`);
        this._clearAllTimers();
        try {
            const forfeitingPlayer = Object.values(this.players).find(p => p.playerName === forfeitingPlayerName);
            const remainingPlayers = Object.values(this.players).filter(p => !p.isSpectator && p.playerName !== forfeitingPlayerName && !p.isBot);
            const tokenChanges = gameLogic.calculateForfeitPayout(this, forfeitingPlayerName);
            const transactionPromises = [];
            if (forfeitingPlayer && !forfeitingPlayer.isBot) {
                transactionPromises.push(transactionManager.postTransaction(this.pool, {
                    userId: forfeitingPlayer.userId, gameId: this.gameId, type: 'forfeit_loss',
                    amount: 0, description: `Forfeited game on table ${this.tableName}`
                }));
            }
            remainingPlayers.forEach(player => {
                const payoutInfo = tokenChanges[player.playerName];
                if (payoutInfo && payoutInfo.totalGain > 0) {
                    transactionPromises.push(transactionManager.postTransaction(this.pool, {
                        userId: player.userId, gameId: this.gameId, type: 'forfeit_payout',
                        amount: payoutInfo.totalGain, description: `Payout from ${forfeitingPlayerName}'s forfeit`
                    }));
                }
            });
            await Promise.all(transactionPromises);
            const statUpdatePromises = [];
            if (forfeitingPlayer && !forfeitingPlayer.isBot) {
                statUpdatePromises.push(this.pool.query("UPDATE users SET losses = losses + 1 WHERE id = $1", [forfeitingPlayer.userId]));
            }
            remainingPlayers.forEach(player => {
                statUpdatePromises.push(this.pool.query("UPDATE users SET washes = washes + 1 WHERE id = $1", [player.userId]));
            });
            await Promise.all(statUpdatePromises);
            const outcomeMessage = `${forfeitingPlayerName} has forfeited the game due to ${reason}.`;
            await transactionManager.updateGameRecordOutcome(this.pool, this.gameId, outcomeMessage);
            Object.values(this.players).forEach(p => {
                const playerSocket = this.io.sockets.sockets.get(p.socketId);
                if (playerSocket) {
                    playerSocket.emit("requestUserSync");
                }
            });
            this.roundSummary = {
                message: `${outcomeMessage} The game has ended.`, isGameOver: true,
                gameWinner: `Payout to remaining players.`, finalScores: this.scores, payouts: tokenChanges,
            };
            this.state = "Game Over";
            this._emitUpdate();
            this.emitLobbyUpdateCallback();
        } catch (err) {
            console.error(`Database error during forfeit resolution for table ${this.tableId}:`, err);
        }
    }
    
    _resolveTrick() {
        const winnerInfo = gameLogic.determineTrickWinner(this.currentTrickCards, this.leadSuitCurrentTrick, this.trumpSuit);
        this.lastCompletedTrick = { cards: [...this.currentTrickCards], winnerName: winnerInfo.playerName };
        
        const trickPoints = gameLogic.calculateCardPoints(this.lastCompletedTrick.cards.map(p => p.card));
        const winnerIsBidder = winnerInfo.playerName === this.bidWinnerInfo.playerName;
        if (winnerIsBidder) {
            this.bidderCardPoints += trickPoints;
        } else {
            this.defenderCardPoints += trickPoints;
        }

        this.tricksPlayedCount++;
        this.trickLeaderId = winnerInfo.userId;
        const winnerName = winnerInfo.playerName;
        if (winnerName && !this.capturedTricks[winnerName]) { this.capturedTricks[winnerName] = []; }
        if (winnerName) { this.capturedTricks[winnerName].push(this.currentTrickCards.map(p => p.card)); }
        
        if (this.tricksPlayedCount === 11) {
            this._calculateRoundScores();
        } else {
            this.state = "TrickCompleteLinger";
            this._emitUpdate();
            this.internalTimers.trickLinger = setTimeout(() => {
                if (this.state === "TrickCompleteLinger") {
                    this.currentTrickCards = [];
                    this.leadSuitCurrentTrick = null;
                    this.trickTurnPlayerId = winnerInfo.userId;
                    this.state = "Playing Phase";
                    this._emitUpdate();
                }
            }, 1000);
        }
    }

    _resolveBiddingFinal() {
        if (!this.currentHighestBidDetails) {
            this.state = "AllPassWidowReveal";
            this._emitUpdate();
            this.internalTimers.allPass = setTimeout(() => {
                if (this.state === "AllPassWidowReveal") {
                    this._advanceRound();
                }
            }, 3000);
            return;
        }
        this.bidWinnerInfo = { ...this.currentHighestBidDetails };
        const bid = this.bidWinnerInfo.bid;
        if (bid === "Frog") { 
            this.trumpSuit = "H"; 
            this.state = "Frog Widow Exchange";
            this.revealedWidowForFrog = [...this.widow];
            const bidderHand = this.hands[this.bidWinnerInfo.playerName];
            this.hands[this.bidWinnerInfo.playerName] = [...bidderHand, ...this.widow];
        } else if (bid === "Heart Solo") { 
            this.trumpSuit = "H"; 
            this._transitionToPlayingPhase();
        } else if (bid === "Solo") { 
            this.state = "Trump Selection";
        }
        this._emitUpdate();
        this.originalFrogBidderId = null;
        this.soloBidMadeAfterFrog = false;
    }

    _checkForFrogUpgrade() {
        if (this.soloBidMadeAfterFrog && this.originalFrogBidderId) {
            this.state = "Awaiting Frog Upgrade Decision";
            this.biddingTurnPlayerId = this.originalFrogBidderId;
        } else { this._resolveBiddingFinal(); }
        this._emitUpdate();
    }
    
    _transitionToPlayingPhase() {
        this.state = "Playing Phase";
        this.tricksPlayedCount = 0;
        this.trumpBroken = false;
        this.currentTrickCards = [];
        this.leadSuitCurrentTrick = null;
        this.lastCompletedTrick = null;
        this.trickLeaderId = this.bidWinnerInfo.userId;
        this.trickTurnPlayerId = this.bidWinnerInfo.userId;
        if (this.playerMode === 3) {
            this.insurance.isActive = true;
            const multiplier = BID_MULTIPLIERS[this.bidWinnerInfo.bid];
            this.insurance.bidMultiplier = multiplier;
            this.insurance.bidderPlayerName = this.bidWinnerInfo.playerName;
            this.insurance.bidderRequirement = 120 * multiplier;
            const defenders = this.playerOrderActive.map(id => this.players[id].playerName).filter(pName => pName !== this.bidWinnerInfo.playerName);
            defenders.forEach(defName => { this.insurance.defenderOffers[defName] = -60 * multiplier; });
        }
        this._emitUpdate();
    }
    
    _advanceRound() {
        if (!this.gameStarted) return;
        const oldDealerId = this.playerOrderActive.shift();
        this.playerOrderActive.push(oldDealerId);
        this.dealer = this.playerOrderActive[0];
        
        if (!this.players[this.dealer]) {
            console.error(`[${this.tableId}] FATAL: Could not find new dealer. Resetting table.`);
            this.reset();
            return;
        }

        this._initializeNewRoundState();
        this.state = "Dealing Pending";
        console.log(`[${this.tableId}] Round advanced. New dealer: ${this.players[this.dealer].playerName}. State: ${this.state}`);
        this._emitUpdate();
    }
    
    async _calculateRoundScores() {
        const roundData = gameLogic.calculateRoundScoreDetails(this);
        for(const playerName in roundData.pointChanges) { if(this.scores[playerName] !== undefined) { this.scores[playerName] += roundData.pointChanges[playerName]; } }
        let isGameOver = Object.values(this.scores).filter(s => typeof s === 'number').some(score => score <= 0);
        let gameWinnerName = null;
        let finalOutcomeMessage = roundData.roundMessage;
        if (isGameOver) {
            finalOutcomeMessage = "Game Over!";
            const gameOverResult = await gameLogic.handleGameOver(this, this.pool);
            gameWinnerName = gameOverResult.gameWinnerName;
            Object.values(this.players).forEach(p => { 
                if (!p.isBot) {
                    const playerSocket = this.io.sockets.sockets.get(p.socketId);
                    if (playerSocket) {
                        playerSocket.emit("requestUserSync"); 
                    }
                }
            });
        }
        await this._syncPlayerTokens(Object.keys(this.players));
        this.roundSummary = { message: finalOutcomeMessage, finalScores: { ...this.scores }, isGameOver, gameWinner: gameWinnerName, dealerOfRoundId: this.dealer, widowForReveal: roundData.widowForReveal, insuranceDealWasMade: this.insurance.dealExecuted, insuranceDetails: this.insurance.dealExecuted ? this.insurance.executedDetails : null, insuranceHindsight: roundData.insuranceHindsight, allTricks: this.capturedTricks, playerTokens: this.playerTokens };
        this.state = isGameOver ? "Game Over" : "Awaiting Next Round Trigger";
        this._emitUpdate();
    }

    _recalculateActivePlayerOrder() {
        const activePlayers = Object.values(this.players).filter(p => !p.isSpectator && !p.disconnected);
        if (activePlayers.length === 0) { this.playerOrderActive = []; return; }
        if (this.gameStarted && this.dealer) {
            const playerUserIds = activePlayers.map(p => p.userId);
            let dealerIndex = playerUserIds.indexOf(this.dealer);
            if (dealerIndex === -1) { this.dealer = playerUserIds[0]; dealerIndex = 0; }
            const orderedIds = [];
            for (let i = 1; i <= playerUserIds.length; i++) { 
                const playerId = playerUserIds[(dealerIndex + i) % playerUserIds.length]; 
                if (this.players[playerId]) {
                    orderedIds.push(playerId); 
                }
            }
            this.playerOrderActive = orderedIds;
        } else { this.playerOrderActive = activePlayers.map(p => p.userId).sort((a,b) => a - b); }
    }

    getStateForClient() {
        const state = {
            tableId: this.tableId, tableName: this.tableName, theme: this.theme, state: this.state, players: this.players,
            playerOrderActive: Object.values(this.players)
                .filter(p => this.playerOrderActive.includes(p.userId))
                .sort((a, b) => this.playerOrderActive.indexOf(a.userId) - this.playerOrderActive.indexOf(b.userId))
                .map(p => p.playerName), // Send names to client for UI
            dealer: this.dealer, hands: this.hands, widow: this.widow, originalDealtWidow: this.originalDealtWidow, scores: this.scores, currentHighestBidDetails: this.currentHighestBidDetails, bidWinnerInfo: this.bidWinnerInfo, gameStarted: this.gameStarted, trumpSuit: this.trumpSuit, currentTrickCards: this.currentTrickCards, tricksPlayedCount: this.tricksPlayedCount, leadSuitCurrentTrick: this.leadSuitCurrentTrick, trumpBroken: this.trumpBroken, capturedTricks: this.capturedTricks, roundSummary: this.roundSummary, lastCompletedTrick: this.lastCompletedTrick, playersWhoPassedThisRound: this.playersWhoPassedThisRound.map(id => this.players[id]?.playerName), playerMode: this.playerMode, serverVersion: this.serverVersion, insurance: this.insurance, forfeiture: this.forfeiture, playerTokens: this.playerTokens, drawRequest: this.drawRequest, originalFrogBidderId: this.originalFrogBidderId, soloBidMadeAfterFrog: this.soloBidMadeAfterFrog, revealedWidowForFrog: this.revealedWidowForFrog, widowDiscardsForFrogBidder: this.widowDiscardsForFrogBidder,
            bidderCardPoints: this.bidderCardPoints,
            defenderCardPoints: this.defenderCardPoints,
        };
        // Derive player names for client compatibility
        state.biddingTurnPlayerName = this.players[this.biddingTurnPlayerId]?.playerName;
        state.trickTurnPlayerName = this.players[this.trickTurnPlayerId]?.playerName;
        return state;
    }
    
    _emitUpdate() {
        this.io.to(this.tableId).emit('gameState', this.getStateForClient());
        this._triggerBots();
    }
    
    _triggerBots() {
        if (this.pendingBotAction) return;

        for (const botId in this.bots) {
            const bot = this.bots[botId];
            
            const isCourtney = bot.playerName === "Courtney Sr.";
            const standardDelay = 1000;
            const playDelay = 1200;
            const roundEndDelay = 8000;

            if (this.state === 'Dealing Pending' && this.dealer === bot.userId) {
                let delay = isCourtney ? standardDelay * 2 : standardDelay;
                this.pendingBotAction = setTimeout(() => {
                    this.pendingBotAction = null;
                    this.dealCards(bot.userId);
                }, delay);
                return;
            }

            if (this.state === 'Awaiting Next Round Trigger' && this.roundSummary?.dealerOfRoundId === bot.userId) {
                let delay = isCourtney ? roundEndDelay * 2 : roundEndDelay;
                this.pendingBotAction = setTimeout(() => {
                    this.pendingBotAction = null;
                    this.requestNextRound(bot.userId);
                }, delay);
                return;
            }

            if (this.state === 'Awaiting Frog Upgrade Decision' && this.biddingTurnPlayerId === bot.userId) {
                let delay = isCourtney ? standardDelay * 2 : standardDelay;
                this.pendingBotAction = setTimeout(() => { 
                    this.pendingBotAction = null; 
                    this.placeBid(bot.userId, "Pass"); 
                }, delay);
                return;
            }

            if (this.state === 'Bidding Phase' && this.biddingTurnPlayerId === bot.userId) {
                let delay = isCourtney ? standardDelay * 2 : standardDelay;
                this.pendingBotAction = setTimeout(() => { this.pendingBotAction = null; bot.makeBid(); }, delay);
                return;
            }

            if (this.state === 'Trump Selection' && this.bidWinnerInfo?.userId === bot.userId && !this.trumpSuit) {
                let delay = isCourtney ? standardDelay * 2 : standardDelay;
                this.pendingBotAction = setTimeout(() => { this.pendingBotAction = null; bot.chooseTrump(); }, delay);
                return;
            }

            if (this.state === 'Frog Widow Exchange' && this.bidWinnerInfo?.userId === bot.userId && this.widowDiscardsForFrogBidder.length === 0) {
                let delay = isCourtney ? standardDelay * 2 : standardDelay;
                this.pendingBotAction = setTimeout(() => { this.pendingBotAction = null; bot.submitFrogDiscards(); }, delay);
                return;
            }

            if (this.state === 'Playing Phase' && this.trickTurnPlayerId === bot.userId) {
                let delay = isCourtney ? playDelay * 2 : playDelay;
                this.pendingBotAction = setTimeout(() => { this.pendingBotAction = null; bot.playCard(); }, delay);
                return;
            }
        }
    }
    _clearAllTimers() { for (const timer in this.internalTimers) { clearTimeout(this.internalTimers[timer]); clearInterval(this.internalTimers[timer]); } this.internalTimers = {}; }
    
    _initializeNewRoundState() {
        this.hands = {}; this.widow = []; this.originalDealtWidow = [];
        this.biddingTurnPlayerId = null;
        this.currentHighestBidDetails = null;
        this.playersWhoPassedThisRound = [];
        this.bidWinnerInfo = null; this.trumpSuit = null; this.trumpBroken = false; this.originalFrogBidderId = null; this.soloBidMadeAfterFrog = false; this.revealedWidowForFrog = []; this.widowDiscardsForFrogBidder = [];
        this.trickTurnPlayerId = null;
        this.trickLeaderId = null;
        this.currentTrickCards = []; this.leadSuitCurrentTrick = null; this.lastCompletedTrick = null; this.tricksPlayedCount = 0; this.capturedTricks = {}; this.roundSummary = null; this.insurance = this._getInitialInsuranceState(); this.forfeiture = this._getInitialForfeitureState(); this.drawRequest = this._getInitialDrawRequestState();
        
        Object.values(this.players).forEach(p => {
            if (p.playerName && this.scores[p.playerName] !== undefined) {
                this.capturedTricks[p.playerName] = [];
            }
        });
        
        this.bidderCardPoints = 0;
        this.defenderCardPoints = 0;
    }

    async _syncPlayerTokens(playerIds) {
        if (!playerIds || playerIds.length === 0) { this.playerTokens = {}; return; }
        playerIds = playerIds.filter(id => parseInt(id,10) >= 0);
        if (playerIds.length === 0) { this.playerTokens = {}; return; }
        try {
            const tokenQuery = `SELECT user_id, SUM(amount) as tokens FROM transactions WHERE user_id = ANY($1::int[]) GROUP BY user_id;`;
            const tokenResult = await this.pool.query(tokenQuery, [playerIds]);
            const newPlayerTokens = {};
            const userIdToNameMap = Object.values(this.players).reduce((acc, player) => { acc[player.userId] = player.playerName; return acc; }, {});
            tokenResult.rows.forEach(row => { const playerName = userIdToNameMap[row.user_id]; if (playerName) { newPlayerTokens[playerName] = parseFloat(row.tokens || 0).toFixed(2); } });
            this.playerTokens = newPlayerTokens;
        } catch (err) { console.error(`Error fetching tokens during sync for table ${this.tableId}:`, err); }
    }
    _getInitialInsuranceState() { return { isActive: false, bidMultiplier: null, bidderPlayerName: null, bidderRequirement: 0, defenderOffers: {}, dealExecuted: false, executedDetails: null }; }
    _getInitialForfeitureState() { return { targetPlayerName: null, timeLeft: null }; }
    _getInitialDrawRequestState() { return { isActive: false, initiator: null, votes: {}, timer: null }; }
}

module.exports = Table;
--- END FILE: backend/game/Table.js ---

--- START FILE: backend/Onboarding/OpeningPrompt.txt ---
You are an expert full-stack software developer with deep expertise in Node.js, Express, React, PostgreSQL, and Socket.IO. Your role is to act as my senior pair programmer to assist me in writing, debugging, and refactoring code for the 'Sluff' web game.
The following text contains the complete source code for the project, organized as a monorepo. Please analyze it thoroughly to understand the full architecture.
Pay special attention to these key files to understand the core logic:
README.md (for the high-level project overview)
backend/game/Table.js (the main game state machine)
backend/game/logic.js (the core scoring and rule calculations)
frontend/src/App.js (the main client-side application component)
Once you have analyzed the entire context, please confirm that you understand the project's architecture and are ready for my first instruction.
--- END FILE: backend/Onboarding/OpeningPrompt.txt ---

--- START FILE: backend/Onboarding/Project_Roadmap_Prompt_3.txt ---
/**
 * Sluff: Project Roadmap & Feature Plan
 * =======================================
 * KEY:
 * [x] - Fully Implemented: The feature is complete, from UI to backend logic.
 * [P] - Partially Implemented: Significant parts of the feature are complete but not fully functional.
 * [ ] - Not Started: Little to no code has been written for this feature.
 */

---

### PHASE 1: Workable Local Prototype
*Goal: Establish the fundamental game logic and rules in a local, non-networked environment.*

- [x] **Core Rule Implementation:** Code the basic logic for card dealing, bidding, trick-taking, and scoring.
- [x] **State Management:** Create a system to manage the state of a single game instance.

---

### PHASE 2: Functional Web-Based Playable Game
*Goal: Transition the local prototype to a multiplayer web application with a basic user interface.*

- [x] **Client/Server Architecture:** Set up the initial React frontend and Node.js backend with WebSocket communication.
- [x] **Multiplayer Lobby:** Implement a basic lobby system to allow multiple players to join a game table.
- [x] **User Authentication:** Add persistent user accounts with registration and login.
- [x] **Transaction Ledger:** Implement a robust, transaction-based system for managing player tokens.

---

### PHASE 3: Alpha Testing with Real Users
*Goal: Address critical bugs, complete core logic, and deliver key features for family tournament play.*

- [ ] **Table Reset Logic:** Fix the bug preventing a table from correctly resetting to a "waiting for players" state after a round concludes. (NOTE: The `resetGame` event and `table.reset()` method exist, but are considered faulty).
- [x] **Forfeit & Disconnect Logic:**
    - [x] Implement the three possible outcomes for a mutual draw request.
    - [x] Finalize the logic for proportional token distribution when a player forfeits.
- [P] **Turn Timer for Inactive Players:**
    - [x] A 2-minute forfeit timer for *disconnected* players is implemented and can be triggered from the UI.
    - [ ] A timer for *AFK (still connected)* players who fail to take their turn has not been implemented.
- [x] **AI Player Implementation:**
    - [x] Create a baseline AI player that can join a game and make legal moves.
    - [x] AI strategy includes intelligent bidding based on hand strength and strategic card play (e.g., playing high to win, playing low to sluff).
- [ ] **User Account & Security:**
    - [ ] Account Recovery: Implement a "Forgot Password" system via email.
    - [ ] Email Confirmation: Require new users to confirm their email address upon registration.
- [ ] **Enhanced Card Play Experience:** Overhaul the card playing mechanic to allow players to drag and drop their selected card onto the play area.
- [x] **Visible Widow & Trump Puck:**
    - [x] Display the face-down Widow pile on the game table.
    - [x] Add a visual indicator ("puck") to the table that changes appearance once the trump suit has been broken.
- [P] **Expanded Sound Effects:**
    - [x] Sounds for turnAlert, cardPlay, trickWin, and cardDeal are implemented.
    - [ ] Sounds for trump played, card sluffed, and a round-win celebration are missing.
- [P] **In-App Feedback Tool:**
    - [x] Backend API (`/api/feedback`) and database table are fully implemented.
    - [ ] Frontend UI to submit feedback has not been created.

---

### PHASE 4: Beta - Polish & Player Engagement
*Goal: Transform the game from a functional app into a polished, engaging experience.*

- [ ] **Card Art & Animation:**
    - [ ] Commission or create unique, high-quality art for the card faces and backs.
    - [ ] Implement a smooth card dealing animation.
    - [ ] Add a "flipping" animation when a card is played.
- [ ] **Mobile-First UI Overhaul:** Conduct a thorough review and redesign of all UI components for a seamless mobile experience.
- [x] **New Player Onboarding:**
    - [x] Create low-stakes "Learner Tables" (`miss-pauls-academy` theme).
    - [ ] Implement an in-game "Cheat Sheet" window showing points captured, cards played, etc.
- [x] **Community & Chat:**
    - [x] Add a persistent chat window to the lobby and in-game view.
    - [ ] Implement in-game "chat bubbles" that appear above a player's seat.
- [ ] **Tournament Mode (v1):**
    - [ ] Develop a system for creating and managing multi-round tournaments.
- [ ] **Private Rooms:** Allow players to create password-protected tables.
- [ ] **Advanced Player Statistics:** Create a dedicated profile screen for detailed player stats.

---

### PHASE 5: Live Game - Monetization & Long-Term Growth
*Goal: Implement features to support a live, revenue-generating game and foster a long-term player community.*

- [ ] **Rewarded Ads:** Replace the "Mercy Token" system with a standard rewarded video ad.
- [ ] **Cosmetic In-App Purchases:** Sell unique card backs, table themes, etc.
- [ ] **Battle Pass / Seasonal System:** Introduce a seasonal pass to unlock exclusive cosmetic rewards.
- [ ] **Seasonal Leaderboards:** Implement weekly/monthly leaderboards with rewards.
- [ ] **Smart AI (Machine Learning):** Begin collecting game data to train a more advanced AI.
- [ ] **Interactive Tutorial:** Create a guided, playable tutorial for new users.
--- END FILE: backend/Onboarding/Project_Roadmap_Prompt_3.txt ---

--- START FILE: backend/Onboarding/Prompt_1.txt ---
AI Assistant Onboarding: Part 1

Your Role

Welcome to the Sluff web game project. You are an expert-level, full-stack software developer. Your primary function is to assist me, the lead developer, in writing, debugging, and refactoring code.

Interpreting the Code Context

You will be provided with one or more _context.txt files (e.g., frontend_context.txt, backend_context.txt). These files contain the concatenated source code of the entire project.

Your task is to mentally reconstruct the project's file and directory structure from these text files. Each file's content is preceded by a line like --- START FILE: [path/to/file.js] ---. Use these markers as your guide to understand the layout of the codebase as if you were browsing it in a code editor.

Your First Instruction

After you have read and understood this document, please respond with the following exact phrase: "I am ready for the next onboarding prompt."
--- END FILE: backend/Onboarding/Prompt_1.txt ---

--- START FILE: backend/Onboarding/Prompt_2.txt ---
Onboarding Prompt 2: Code Comprehension & AnalysisGoal:This prompt will test your ability to parse the codebase, connect it to the game's rules, and identify key architectural components.Required Files for Analysis:frontend_context.txtbackend_context.txtSluff Game Rules 3.0.docxAnalysis Steps:First, absorb the code in the context files and show me a tree view of all the .js files so I can confirm you've parsed the structure correctly.Next, using your knowledge of the Sluff Game Rules and the codebase, please identify the primary backend file and function(s) responsible for each of the following critical game mechanics:Handling the "Insurance Phase" negotiation logic.Determining the winner of a single trick during the trick-taking phase.Calculating the final score exchange at the end of a round when a bid succeeds.Then, based on your analysis, which single file appears to contain the main game state machine that orchestrates the overall flow of a round from bidding to scoring?Finally, analyze the component hierarchy starting from App.js. Identify any components that, while present in the codebase, do not appear to be rendered or used by any other part of the application (i.e., they are "orphaned").
--- END FILE: backend/Onboarding/Prompt_2.txt ---

--- START FILE: backend/Onboarding/Prompt_3.txt ---
Onboarding Prompt 3: Strategic Project Analysis

Goal:
Please perform a strategic analysis of the project by completing the following steps. This will help us align on the current state of the project and define our next priorities.

Required Files for Analysis:

frontend_context.txt

backend_context.txt

Project_Roadmap_Prompt_3.txt

Analysis Steps:

Analyze the Roadmap.
Compare the features listed as complete ([x]) in the Project_Roadmap_Prompt_3.txt document against the code provided in the frontend_context.txt and backend_context.txt files to verify their implementation.

Identify Completed Gaps.
Based on your code analysis, identify and list any significant features that are implemented in the codebase but are not yet marked as complete in the roadmap. This will help us update our documentation.

Assess Current Progress.
Review the tasks listed under Phase 3 (Alpha Testing) in the roadmap. Based on the code, provide an assessment of which tasks appear to be Partially Implemented, Fully Implemented, or Not Started.

Provide Strategic Recommendations.
With the long-term goal of making this a fun and profitable game, suggest any additions or reprioritizations to the roadmap. Frame your suggestions to help build a world-class game designed for player engagement and future revenue.
--- END FILE: backend/Onboarding/Prompt_3.txt ---

--- START FILE: backend/Onboarding/Prompt_4.txt ---
Onboarding Prompt 4: Our Workflow & Rules of Engagement

This is the final step of the onboarding process. This document outlines the tools we use and the best way for us to work together.

Our Technical Stack
To give you context on our development and deployment environment, here are the primary tools we use:

Code Editor: VS Code

Version Control: Git (with repositories hosted on GitHub)

Frontend Deployment: Netlify

Backend Deployment: Render

Database Management: DBeaver

You do not need to interact with these tools directly, but understanding this stack will help you provide more relevant suggestions. If development requires more tables, you may end up walking me through each setup step.

Rules of Engagement
To ensure our collaboration is as efficient as possible, please adhere to the following rules:

Seek Clarity on Ambiguity: I am relatively new to coding. If my instructions are ever ambiguous or unclear, you must ask for clarification before proceeding. Do not guess at implementation details, variable names, or database table names.

Provide Complete Files: Whenever you are asked to write or modify code, please provide the complete file, even for a single-line change. Do not provide snippets for me to place. This helps avoid integration errors.

Acknowledge and Confirm: Before you provide a solution, briefly acknowledge the key goals of my prompt to confirm your understanding.

If you understand and agree to these rules of engagement, please let me know that you are ready for your first real instruction of the day.
--- END FILE: backend/Onboarding/Prompt_4.txt ---

--- START FILE: backend/socket/gameHandlers.js ---
--- END FILE: backend/socket/gameHandlers.js ---

--- START FILE: backend/socket/index.js ---
--- END FILE: backend/socket/index.js ---

--- START FILE: backend/src/server.js ---
require("dotenv").config();
const http = require("http");
const express = require("express");
const cors =require("cors");
const { Server } = require("socket.io");
const { Pool } = require("pg");
const jwt = require("jsonwebtoken");
const bcrypt = require('bcrypt');

const state = require('./core/gameState');
const createAuthRoutes = require('./api/auth');
const createLeaderboardRoutes = require('./api/leaderboard');
const createAdminRoutes = require('./api/admin');
const createFeedbackRoutes = require('./api/feedback'); 
const createChatRoutes = require('./api/chat');
const createDbTables = require('../data/createTables');
const transactionManager = require("../data/transactionManager");

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: { origin: "*", methods: ["GET", "POST"] },
});

let pool;

app.use(cors({ origin: "*" }));
app.use(express.json());

// =================================================================
// AUTHENTICATION MIDDLEWARE
// =================================================================

io.use((socket, next) => {
    const token = socket.handshake.auth.token;
    if (!token) { 
        return next(new Error("Authentication error: No token provided."));
    }
    jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
        if (err) { 
            return next(new Error("Authentication error: Invalid token."));
        }
        socket.user = user;
        next();
    });
});

// =================================================================
// SOCKET.IO CONNECTION HANDLER
// =================================================================

io.on("connection", (socket) => {
    console.log(`Socket connected: ${socket.user.username} (ID: ${socket.user.id}, Socket: ${socket.id})`);

    const table = Object.values(state.getAllTables()).find(t => t.players[socket.user.id]);
    if (table && table.players[socket.user.id].disconnected) {
        table.reconnectPlayer(socket.user.id, socket);
    }
    
    socket.emit("lobbyState", state.getLobbyState());

    // --- CORE EVENT LISTENERS (DELEGATION MODEL) ---
    // ... (All your game event listeners like joinTable, playCard, etc. remain here)
    socket.on("joinTable", async ({ tableId }) => {
        const tableToJoin = state.getTableById(tableId);
        if (!tableToJoin) return socket.emit("error", { message: "Table not found." });

        const previousTable = Object.values(state.getAllTables()).find(t => t.players[socket.user.id] && t.tableId !== tableId);
        if (previousTable) {
            await previousTable.leaveTable(socket.user.id);
            socket.leave(previousTable.tableId);
        }
        
        socket.join(tableId);
        await tableToJoin.joinTable(socket.user, socket.id);
    });

    socket.on("leaveTable", async ({ tableId }) => {
        const tableToLeave = state.getTableById(tableId);
        if (tableToLeave) {
            await tableToLeave.leaveTable(socket.user.id);
        }
        socket.leave(tableId);
        socket.emit("lobbyState", state.getLobbyState());
    });

    socket.on("addBot", ({ tableId, name }) => {
        const table = state.getTableById(tableId);
        if (table) table.addBotPlayer(name || 'Lee');
    });

    socket.on("startGame", ({ tableId }) => {
        const table = state.getTableById(tableId);
        if (table) table.startGame(socket.user.id);
    });
    
    socket.on("dealCards", ({ tableId }) => {
        const table = state.getTableById(tableId);
        if (table) table.dealCards(socket.user.id);
    });

    socket.on("placeBid", ({ tableId, bid }) => {
        const table = state.getTableById(tableId);
        if (table) table.placeBid(socket.user.id, bid);
    });

    socket.on("chooseTrump", ({ tableId, suit }) => {
        const table = state.getTableById(tableId);
        if (table) table.chooseTrump(socket.user.id, suit);
    });

    socket.on("submitFrogDiscards", ({ tableId, discards }) => {
        const table = state.getTableById(tableId);
        if (table) table.submitFrogDiscards(socket.user.id, discards);
    });

    socket.on("playCard", ({ tableId, card }) => {
        const table = state.getTableById(tableId);
        if (table) table.playCard(socket.user.id, card);
    });

    socket.on("requestNextRound", ({ tableId }) => {
        const table = state.getTableById(tableId);
        if (table) table.requestNextRound(socket.user.id);
    });
    
    socket.on("forfeitGame", ({ tableId }) => {
        const table = state.getTableById(tableId);
        if (table) table.forfeitGame(socket.user.id);
    });
    
    socket.on("resetGame", async ({ tableId }) => {
        const table = state.getTableById(tableId);
        if (table) await table.reset();
    });

    socket.on("updateInsuranceSetting", ({ tableId, settingType, value }) => {
        const table = state.getTableById(tableId);
        if (table) table.updateInsuranceSetting(socket.user.id, settingType, value);
    });

    socket.on("startTimeoutClock", ({ tableId, targetPlayerName }) => {
        const table = state.getTableById(tableId);
        if (table) table.startForfeitTimer(socket.user.id, targetPlayerName);
    });

    socket.on("requestDraw", ({ tableId }) => {
        const table = state.getTableById(tableId);
        if (table) table.requestDraw(socket.user.id);
    });
    
    socket.on("submitDrawVote", ({ tableId, vote }) => {
        const table = state.getTableById(tableId);
        if (table) table.submitDrawVote(socket.user.id, vote);
    });


    // --- USER-SPECIFIC & MISC LISTENERS ---

    socket.on("requestUserSync", async () => {
        try {
            const userQuery = "SELECT id, username, email, created_at, wins, losses, washes, is_admin FROM users WHERE id = $1";
            const userResult = await pool.query(userQuery, [socket.user.id]);
            const updatedUser = userResult.rows[0];

            if (updatedUser) {
                const tokenQuery = "SELECT SUM(amount) AS current_tokens FROM transactions WHERE user_id = $1";
                const tokenResult = await pool.query(tokenQuery, [socket.user.id]);
                updatedUser.tokens = parseFloat(tokenResult.rows[0]?.current_tokens || 0).toFixed(2);
                socket.emit("updateUser", updatedUser);
            }
        } catch(err) {
            console.error(`Error during user sync for user ${socket.user.id}:`, err);
        }
    });

    socket.on("requestFreeToken", async () => {
        try {
            const tokenQuery = "SELECT SUM(amount) AS current_tokens FROM transactions WHERE user_id = $1";
            const tokenResult = await pool.query(tokenQuery, [socket.user.id]);
            const currentTokens = parseFloat(tokenResult.rows[0]?.current_tokens || 0);

            if (currentTokens >= 5) {
                return socket.emit("error", { message: "Sorry, free tokens are only for players with fewer than 5 tokens." });
            }

            await transactionManager.postTransaction(pool, {
                userId: socket.user.id, gameId: null, type: 'free_token_mercy', amount: 1,
                description: 'Mercy token requested by user'
            });
            
            const userQuery = "SELECT id, username, email, created_at, wins, losses, washes, is_admin FROM users WHERE id = $1";
            const userResult = await pool.query(userQuery, [socket.user.id]);
            const updatedUser = userResult.rows[0];

            if (updatedUser) {
                const updatedTokenQuery = "SELECT SUM(amount) AS current_tokens FROM transactions WHERE user_id = $1";
                const updatedTokenResult = await pool.query(updatedTokenQuery, [socket.user.id]);
                updatedUser.tokens = parseFloat(updatedTokenResult.rows[0]?.current_tokens || 0).toFixed(2);
                socket.emit("updateUser", updatedUser);
            }

            socket.emit("notification", { message: "1 free token has been added to your account!" });

        } catch (err) {
            socket.emit("error", { message: "Could not grant token." });
        }
    });

    socket.on("disconnect", async () => { // --- MODIFIED: Mark as async ---
        console.log(`Socket disconnected: ${socket.user.username} (ID: ${socket.user.id}, Socket: ${socket.id})`);
        
        // --- NEW: Announce logout/disconnect to the lobby chat ---
        try {
            const logoutMsgQuery = `
                INSERT INTO lobby_chat_messages (user_id, username, message)
                VALUES ($1, $2, $3)
                RETURNING id, username, message, created_at;
            `;
            const msgValues = [socket.user.id, 'System', `${socket.user.username} has logged out.`];
            const { rows } = await pool.query(logoutMsgQuery, msgValues);
            io.emit('new_lobby_message', rows[0]);
        } catch (chatError) {
            console.error("Failed to post logout message to chat:", chatError);
        }
        // --- END NEW ---
        
        const tablePlayerIsOn = Object.values(state.getAllTables()).find(t => t.players[socket.user.id]);
        if (tablePlayerIsOn) {
            tablePlayerIsOn.disconnectPlayer(socket.user.id);
        }
    });
});

// =================================================================
// SERVER STARTUP
// =================================================================

const PORT = process.env.PORT || 3000;
server.listen(PORT, async () => {
  console.log(`Sluff Game Server (v${require('./core/constants').SERVER_VERSION}) running on port ${PORT}`);
  try {
    pool = new Pool({
      connectionString: process.env.DATABASE_URL,
      ssl: { rejectUnauthorized: false }
    });
    await pool.connect();
    console.log("âœ… Database connection successful.");
    await createDbTables(pool);
    
    // --- MODIFICATION: Pass 'io' to the auth routes ---
    const authRoutes = createAuthRoutes(pool, bcrypt, jwt, io);
    app.use('/api/auth', authRoutes);

    const leaderboardRoutes = createLeaderboardRoutes(pool);
    app.use('/api/leaderboard', leaderboardRoutes);

    const adminRouter = createAdminRoutes(pool, jwt);
    app.use('/api/admin', adminRouter);

    const feedbackRouter = createFeedbackRoutes(pool, jwt); 
    app.use('/api/feedback', feedbackRouter);              

    const chatRouter = createChatRoutes(pool, io, jwt);
    app.use('/api/chat', chatRouter);

    state.initializeGameTables(io, pool);

  } catch (err) {
    console.error("âŒ DATABASE CONNECTION FAILED:", err);
    process.exit(1);
  }
});
--- END FILE: backend/src/server.js ---

--- START FILE: backend/src/api/admin.js ---
// backend/src/api/admin.js
// This file handles admin-specific routes, such as generating the database schema

const express = require('express');
const fs = require('fs');
const path = require('path');

// This function creates the router and gives it the database pool
const createAdminRoutes = (pool, jwt) => {
  const router = express.Router();
 
  const checkAuth = (req, res, next) => {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).send('Authentication required.');
    }
    const token = authHeader.split(' ')[1];
    jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
      if (err) {
        return res.status(403).send('Invalid or expired token.');
      }
      req.user = user;
      next();
    });
  };
  // A middleware to check if the user is an admin
  const isAdmin = async (req, res, next) => {
    // This assumes you have a way to get the user's ID from the request,
    // for example, from a decoded JWT token attached by another middleware.
    // Since your io.use middleware handles JWT, a separate one for Express is needed.
    // For now, we'll placeholder this logic.
    const userId = req.user?.id;
    if (!userId) return res.status(401).send('Authentication required.');

    try {
      const { rows } = await pool.query("SELECT is_admin FROM users WHERE id = $1", [userId]);
      if (rows.length > 0 && rows[0].is_admin) {
        return next();
      }
      res.status(403).send('Access Forbidden: Requires admin privileges.');
    } catch (err) {
      console.error("Admin check failed:", err);
      res.status(500).send('Server error during admin check.');
    }
  };

 router.post('/generate-schema', checkAuth, isAdmin, async (req, res) => {
    try {
      const sqlQuery = `
        SELECT table_name, column_name, data_type
        FROM information_schema.columns
        WHERE table_schema = 'public' ORDER BY table_name, ordinal_position;
      `;
      const { rows } = await pool.query(sqlQuery);

      let markdownContent = '# Database Schema\n\n';
      let currentTable = '';
      rows.forEach(row => {
        if (row.table_name !== currentTable) {
          currentTable = row.table_name;
          markdownContent += `\n## \`${currentTable}\`\n`;
        }
        markdownContent += `- **${row.column_name}**: \`${row.data_type}\`\n`;
      });

      // Writes the file to the project's root directory
      const filePath = path.join(__dirname, '../DATABASE_SCHEMA.md'); 
      fs.writeFileSync(filePath, markdownContent);

      res.status(200).send('DATABASE_SCHEMA.md updated successfully.');

    } catch (error) {
      console.error('Failed to generate schema file:', error);
      res.status(500).send('Internal Server Error');
    }
  });

  return router;
};

module.exports = createAdminRoutes;
--- END FILE: backend/src/api/admin.js ---

--- START FILE: backend/src/api/ai.js ---
// backend/src/api/ai.js
// This file handles AI-related routes, allowing the AI to call specific functions


const express = require('express');
const aiTools = require('../ai_tools');

// This is a simple "whitelist" of the tools the AI is allowed to call.
// This prevents any possibility of calling unintended functions.
const availableTools = {
  getTableState: aiTools.getTableState,
  getUserByUsername: aiTools.getUserByUsername,
};

const createAiRoutes = (pool) => {
  const router = express.Router();

  // IMPORTANT: Secure this endpoint!
  // Anyone who knows the URL could call your functions. We use a simple
  // secret key in the header. In a real production app, you might use
  // a more advanced system like Google Cloud IAM.
  const checkAiAuth = (req, res, next) => {
    const secret = req.headers['x-ai-secret-key'];
    if (!secret || secret !== process.env.AI_SECRET_KEY) {
      return res.status(403).json({ error: 'Forbidden: Invalid AI secret key.' });
    }
    next();
  };

  router.post('/execute-tool', checkAiAuth, async (req, res) => {
    // The AI Studio will send a body like: { "functionCall": { "name": "...", "args": {...} } }
    const { name, args } = req.body.functionCall;

    const tool = availableTools[name];

    if (!tool) {
      return res.status(404).json({ error: `Tool with name '${name}' not found.` });
    }

    try {
      // Call the requested function. We pass 'args' and the 'pool' for db access.
      const result = await tool(args, pool);

      // Send the result back to the AI Studio in the required format.
      res.json({
        functionResponse: {
          name,
          response: result,
        },
      });
    } catch (error) {
      console.error(`Error executing tool '${name}':`, error);
      res.status(500).json({ error: 'An internal server error occurred.' });
    }
  });

  return router;
};

module.exports = createAiRoutes;
// --- END FILE: Backend/routes/ai.js ---
--- END FILE: backend/src/api/ai.js ---

--- START FILE: backend/src/api/auth.js ---
const express = require('express');
const router = express.Router();

// --- MODIFICATION: Pass 'io' into the function ---
module.exports = function(pool, bcrypt, jwt, io) {

    // REGISTRATION ROUTE
    router.post('/register', async (req, res) => {
        try {
            const { username, email, password } = req.body;
            if (!username || !email || !password) {
                return res.status(400).json({ message: "Username, email, and password are required." });
            }
            const hashedPassword = await bcrypt.hash(password, 10);
            
            const insertUserQuery = 'INSERT INTO users (username, email, password_hash) VALUES ($1, $2, $3) RETURNING id';
            const userResult = await pool.query(insertUserQuery, [username, email, hashedPassword]);
            const newUserId = userResult.rows[0].id;

            const startingTokens = 8.00;
            const transactionType = 'admin_adjustment'; 
            const description = 'New user starting balance';
            const insertTransactionQuery = 'INSERT INTO transactions (user_id, amount, transaction_type, description) VALUES ($1, $2, $3, $4)';
            await pool.query(insertTransactionQuery, [newUserId, startingTokens, transactionType, description]);
            
            res.status(201).json({ message: "User registered successfully!" });
        } catch (error) {
            console.error("Registration error:", error);
            const detailedErrorMessage = error.message || "An unknown database error occurred.";
            res.status(500).json({ message: detailedErrorMessage });
        }
    });

    // LOGIN ROUTE
    router.post('/login', async (req, res) => {
        try {
            const { email, password } = req.body;
            if (!email || !password) {
                return res.status(400).json({ message: "Email and password are required." });
            }

            const userQuery = 'SELECT id, username, password_hash, is_admin FROM users WHERE email = $1';
            const userResult = await pool.query(userQuery, [email]);

            if (userResult.rows.length === 0) {
                return res.status(401).json({ message: "Invalid credentials." });
            }

            const user = userResult.rows[0];
            const isPasswordValid = await bcrypt.compare(password, user.password_hash);

            if (!isPasswordValid) {
                return res.status(401).json({ message: "Invalid credentials." });
            }

            const tokenQuery = "SELECT SUM(amount) AS tokens FROM transactions WHERE user_id = $1";
            const tokenResult = await pool.query(tokenQuery, [user.id]);
            const tokens = parseFloat(tokenResult.rows[0].tokens || 0).toFixed(2);

            const payload = { id: user.id, username: user.username, is_admin: user.is_admin };
            const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: '1d' });

            // --- NEW: Announce login to the lobby chat ---
            try {
                const loginMsgQuery = `
                    INSERT INTO lobby_chat_messages (user_id, username, message)
                    VALUES ($1, $2, $3)
                    RETURNING id, username, message, created_at;
                `;
                const msgValues = [user.id, 'System', `${user.username} has logged on.`];
                const { rows } = await pool.query(loginMsgQuery, msgValues);
                io.emit('new_lobby_message', rows[0]);
            } catch (chatError) {
                console.error("Failed to post login message to chat:", chatError);
            }
            // --- END NEW ---

            res.json({
                token,
                user: {
                    id: user.id,
                    username: user.username,
                    tokens: tokens,
                    is_admin: user.is_admin
                }
            });

        } catch (error) {
            console.error("Login error:", error);
            res.status(500).json({ message: "Internal server error during login." });
        }
    });

    return router;
};
--- END FILE: backend/src/api/auth.js ---

--- START FILE: backend/src/api/chat.js ---
// backend/src/api/chat.js

const express = require('express');

// Middleware to verify JWT token
const checkAuth = (jwt) => (req, res, next) => {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).send('Authentication required.');
    }
    const token = authHeader.split(' ')[1];
    jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
        if (err) {
            return res.status(403).send('Invalid or expired token.');
        }
        req.user = user;
        next();
    });
};

const createChatRoutes = (pool, io, jwt) => {
    const router = express.Router();

    // GET /api/chat - Fetch recent chat messages
    router.get('/', checkAuth(jwt), async (req, res) => {
        try {
            const query = `
                SELECT id, username, message, created_at 
                FROM lobby_chat_messages 
                ORDER BY created_at ASC 
                LIMIT 50;
            `;
            const { rows } = await pool.query(query);
            res.json(rows);
        } catch (error) {
            console.error('Failed to fetch chat history:', error);
            res.status(500).json({ message: 'Internal Server Error' });
        }
    });

    // POST /api/chat - Post a new message
    router.post('/', checkAuth(jwt), async (req, res) => {
        const { id: userId, username } = req.user;
        const { message } = req.body;

        if (!message || message.trim() === '') {
            return res.status(400).json({ message: 'Message cannot be empty.' });
        }

        try {
            const query = `
                INSERT INTO lobby_chat_messages (user_id, username, message)
                VALUES ($1, $2, $3)
                RETURNING id, username, message, created_at;
            `;
            const values = [userId, username, message.trim()];
            const { rows } = await pool.query(query, values);
            const newMessage = rows[0];

            // Broadcast the new message to all connected clients
            io.emit('new_lobby_message', newMessage);

            res.status(201).json(newMessage);

        } catch (error) {
            console.error('Failed to post chat message:', error);
            res.status(500).json({ message: 'Internal Server Error' });
        }
    });

    return router;
};

module.exports = createChatRoutes;
--- END FILE: backend/src/api/chat.js ---

--- START FILE: backend/src/api/feedback.js ---
// backend/src/api/feedback.js
// This file handles feedback submission from users

const express = require('express');

// A simple middleware to ensure the user is authenticated via JWT.
// This is a simplified version for Express routes.
const checkAuth = (jwt) => (req, res, next) => {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).send('Authentication required.');
    }
    const token = authHeader.split(' ')[1];
    jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
        if (err) {
            return res.status(403).send('Invalid or expired token.');
        }
        req.user = user; // Attach user payload to the request
        next();
    });
};

const createFeedbackRoutes = (pool, jwt) => {
    const router = express.Router();
    
    router.post('/', checkAuth(jwt), async (req, res) => {
        const { id: userId, username } = req.user;
        const { feedback_text, game_state_json } = req.body;

        if (!feedback_text) {
            return res.status(400).json({ message: 'Feedback text is required.' });
        }

        try {
            const tableId = game_state_json?.tableId || null;

            const query = `
                INSERT INTO feedback (user_id, username, feedback_text, table_id, game_state_json)
                VALUES ($1, $2, $3, $4, $5)
            `;
            const values = [userId, username, feedback_text, tableId, game_state_json];
            
            await pool.query(query, values);
            
            res.status(201).json({ message: 'Feedback submitted successfully. Thank you!' });

        } catch (error) {
            console.error('Error submitting feedback:', error);
            res.status(500).json({ message: 'An internal error occurred while submitting your feedback.' });
        }
    });

    return router;
};

module.exports = createFeedbackRoutes;
--- END FILE: backend/src/api/feedback.js ---

--- START FILE: backend/src/api/leaderboard.js ---
const express = require('express');
const router = express.Router();

// This function will be called from server.js with the db (pool)
module.exports = function(pool) {

    router.get('/', async (req, res) => {
        try {
            // --- MODIFICATION: Corrected the JOIN condition and GROUP BY clause ---
            const query = `
                SELECT 
                    u.id as user_id,
                    u.username, 
                    u.email, 
                    u.wins, 
                    u.losses, 
                    u.washes,
                    u.is_admin,
                    COALESCE(SUM(t.amount), 0) as tokens
                FROM 
                    users u
                LEFT JOIN 
                    transactions t ON u.id = t.user_id
                GROUP BY 
                    u.id, u.username, u.email, u.wins, u.losses, u.washes, u.is_admin
                ORDER BY 
                    tokens DESC;
            `;
            const { rows } = await pool.query(query);
            res.json(rows);
        } catch (error) {
            console.error("Error fetching leaderboard data:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    });

    return router;
};

--- END FILE: backend/src/api/leaderboard.js ---

--- START FILE: backend/src/core/BotPlayer.js ---
const gameLogic = require('./logic');
const { RANKS_ORDER, BID_HIERARCHY } = require('./constants');
const { getLegalMoves } = require('./legalMoves'); // --- MODIFIED: Import the new logic ---

// Helper function to get the rank value of a card for sorting.
const getRankValue = (card) => RANKS_ORDER.indexOf(gameLogic.getRank(card));

class BotPlayer {
    constructor(userId, name, table) {
        this.userId = userId;
        this.playerName = name;
        this.table = table;
    }

    /**
     * Analyzes a hand to determine its point value and suit distribution.
     * @param {string[]} hand - The array of card strings in the hand.
     * @returns {{points: number, suits: {H: number, S: number, C: number, D: number}}}
     */
    _analyzeHand(hand) {
        if (!hand || hand.length === 0) {
            return { points: 0, suits: { H: 0, S: 0, C: 0, D: 0 } };
        }
        const points = gameLogic.calculateCardPoints(hand);
        const suits = { H: 0, S: 0, C: 0, D: 0 };
        for (const card of hand) {
            suits[gameLogic.getSuit(card)]++;
        }
        return { points, suits };
    }

    makeBid() {
        const hand = this.table.hands[this.playerName] || [];
        const handStats = this._analyzeHand(hand);
        const { points, suits } = handStats;

        let potentialBid = "Pass";

        // Evaluate for Heart Solo (highest bid)
        if ((points > 30 && suits.H >= 5) || (points > 40 && suits.H >= 4)) {
            potentialBid = "Heart Solo";
        }
        // Evaluate for other Solos
        else if ((points > 30 && (suits.S >= 5 || suits.C >= 5 || suits.D >= 5)) ||
                 (points > 40 && (suits.S >= 4 || suits.C >= 4 || suits.D >= 4))) {
            potentialBid = "Solo";
        }
        // Evaluate for Frog
        else if ((points > 30 && suits.H >= 4) || (points > 40 && suits.H >= 3)) {
            potentialBid = "Frog";
        }

        // Check if the potential bid is higher than the current bid on the table
        const currentBidDetails = this.table.currentHighestBidDetails;
        const currentBidLevel = currentBidDetails ? BID_HIERARCHY.indexOf(currentBidDetails.bid) : -1;
        const potentialBidLevel = BID_HIERARCHY.indexOf(potentialBid);

        if (potentialBidLevel > currentBidLevel) {
            this.table.placeBid(this.userId, potentialBid);
        } else {
            this.table.placeBid(this.userId, "Pass");
        }
    }

    chooseTrump() {
        const hand = this.table.hands[this.playerName] || [];
        const handStats = this._analyzeHand(hand);
        
        // Find the strongest suit (non-Heart) to be trump
        let bestSuit = 'C';
        let maxCount = 0;
        for (const suit of ['S', 'C', 'D']) {
            if (handStats.suits[suit] > maxCount) {
                maxCount = handStats.suits[suit];
                bestSuit = suit;
            }
        }
        this.table.chooseTrump(this.userId, bestSuit);
    }

    submitFrogDiscards() {
        const hand = this.table.hands[this.playerName] || [];
        // A slightly smarter discard: get rid of the lowest ranking cards
        const sortedHand = [...hand].sort((a, b) => getRankValue(a) - getRankValue(b));
        const discards = sortedHand.slice(0, 3);
        this.table.submitFrogDiscards(this.userId, discards);
    }

    playCard() {
        const hand = this.table.hands[this.playerName];
        if (!hand || hand.length === 0) return;

        // --- MODIFICATION: The entire card selection logic is now refactored ---

        // 1. Get all legal moves first. This prevents the bot from ever getting stuck.
        const isLeading = this.table.currentTrickCards.length === 0;
        const legalPlays = getLegalMoves(
            hand,
            isLeading,
            this.table.leadSuitCurrentTrick,
            this.table.trumpSuit,
            this.table.trumpBroken
        );

        // If for some reason there are no legal plays, exit to prevent a crash.
        if (legalPlays.length === 0) {
            console.error(`[${this.table.tableId}] Bot ${this.playerName} has no legal moves from hand: ${hand.join(', ')}`);
            return;
        }

        // 2. Sort the legal cards from lowest rank to highest.
        legalPlays.sort((a, b) => getRankValue(a) - getRankValue(b));

        // 3. Apply the playing strategy you outlined.
        let cardToPlay;
        if (isLeading) {
            // LOGIC A: I am leading the trick. Play my highest legal card.
            cardToPlay = legalPlays[legalPlays.length - 1];
        } else {
            // LOGIC B: I am not leading.
            // Find which of my legal cards can win the trick.
            const winningPlays = legalPlays.filter(myCard => {
                const potentialTrick = [...this.table.currentTrickCards, { card: myCard, userId: this.userId }];
                const winner = gameLogic.determineTrickWinner(potentialTrick, this.table.leadSuitCurrentTrick, this.table.trumpSuit);
                return winner.userId === this.userId;
            });

            if (winningPlays.length > 0) {
                // I can win! Play the highest card I can win with.
                winningPlays.sort((a, b) => getRankValue(a) - getRankValue(b));
                cardToPlay = winningPlays[winningPlays.length - 1];
            } else {
                // I cannot win. Play my lowest legal card to save good cards.
                cardToPlay = legalPlays[0];
            }
        }
        
        // 4. Play the chosen card.
        this.table.playCard(this.userId, cardToPlay);
    }
}

module.exports = BotPlayer;
--- END FILE: backend/src/core/BotPlayer.js ---

--- START FILE: backend/src/core/constants.js ---
// backend/src/core/constants.js
// This file contains core constants used throughout the application

const SERVER_VERSION = "9.0.0 - Game Economy";

const SUITS = { H: "Hearts", D: "Diamonds", C: "Clubs", S: "Spades" };
const RANKS_ORDER = ["6", "7", "8", "9", "J", "Q", "K", "10", "A"];
const CARD_POINT_VALUES = { "A": 11, "10": 10, "K": 4, "Q": 3, "J": 2, "9":0, "8":0, "7":0, "6":0 };
const BID_HIERARCHY = ["Pass", "Frog", "Solo", "Heart Solo"];
const BID_MULTIPLIERS = { "Frog": 1, "Solo": 2, "Heart Solo": 3 };
const PLACEHOLDER_ID = "ScoreAbsorber";

// --- MODIFICATION: Define table costs, including the new learner table ---
const TABLE_COSTS = {
    'miss-pauls-academy': 0.1,
    'fort-creek': 1,
    'shirecliff-road': 5,
    'dans-deck': 20,
};

// Generate the initial, unshuffled deck
const deck = [];
for (const suitKey in SUITS) {
  for (const rank of RANKS_ORDER) {
    deck.push(rank + suitKey);
  }
}

module.exports = {
    SERVER_VERSION,
    SUITS,
    RANKS_ORDER,
    CARD_POINT_VALUES,
    BID_HIERARCHY,
    BID_MULTIPLIERS,
    PLACEHOLDER_ID,
    TABLE_COSTS,
    deck
};
--- END FILE: backend/src/core/constants.js ---

--- START FILE: backend/src/core/gameState.js ---
// backend/src/core/gameState.js
// This file manages the in-memory game state, including table management and lobby state

const Table = require('./Table'); // Import the new Table class
const { SERVER_VERSION, TABLE_COSTS } = require('./constants');

let tables = {};

// --- MODIFICATION: Reordered the themes to place Miss Paul's Academy last ---
const THEMES = [
    { id: 'fort-creek', name: 'Fort Creek', count: 10 },
    { id: 'shirecliff-road', name: 'ShireCliff Road', count: 10 },
    { id: 'dans-deck', name: "Dan's Deck", count: 10 },
    { id: 'miss-pauls-academy', name: "Miss Paul's Academy", count: 10 },
];

/**
 * Creates instances of the Table class for each defined theme.
 * @param {object} io - The main socket.io server instance.
 * @param {object} pool - The PostgreSQL connection pool.
 */
function initializeGameTables(io, pool) {
    let tableCounter = 1;

    const emitLobbyUpdate = () => {
        io.emit("lobbyState", getLobbyState());
    };

    THEMES.forEach(theme => {
        for (let i = 0; i < theme.count; i++) {
            const tableId = `table-${tableCounter}`;
            const tableNumber = i + 1;
            const tableName = `${theme.name} #${tableNumber}`;
            
            tables[tableId] = new Table(tableId, theme.id, tableName, io, pool, emitLobbyUpdate);
            tableCounter++;
        }
    });
    console.log(`${tableCounter - 1} in-memory game tables initialized using Table class.`);
}

function getTableById(tableId) {
    return tables[tableId];
}

function getAllTables() {
    return tables;
}

/**
 * Gathers the state of all tables for the main lobby view.
 */
function getLobbyState() {
    const groupedByTheme = THEMES.map(theme => {
        const themeTables = Object.values(tables)
            .filter(tableInstance => tableInstance.theme === theme.id)
            .map(tableInstance => {
                const clientState = tableInstance.getStateForClient();
                const activePlayers = Object.values(clientState.players).filter(p => !p.isSpectator);
                return {
                    tableId: clientState.tableId,
                    tableName: clientState.tableName,
                    state: clientState.state,
                    playerCount: activePlayers.length,
                    players: activePlayers.map(p => ({ userId: p.userId, playerName: p.playerName }))
                };
            });
        return { ...theme, cost: TABLE_COSTS[theme.id] || 0, tables: themeTables };
    });

    const lobbyData = {
        themes: groupedByTheme,
        serverVersion: SERVER_VERSION
    };
    return lobbyData;
}

module.exports = {
    initializeGameTables,
    getTableById,
    getAllTables,
    getLobbyState,
};
--- END FILE: backend/src/core/gameState.js ---

--- START FILE: backend/src/core/legalMoves.js ---
// backend/src/core/legalMoves.js
// This file contains the logic to determine legal moves in the game based on the current state
// backend/src/core/legalMoves.js

const { getSuit } = require('./logic');

/**
 * Determines the set of legally playable cards from a player's hand based on the current game state.
 * @param {string[]} hand - The player's current hand of cards.
 * @param {boolean} isLeading - True if the player is leading the trick.
 * @param {string|null} leadSuit - The suit of the first card played in the trick (null if leading).
 * @param {string} trumpSuit - The current trump suit.
 * @param {boolean} trumpBroken - True if trump has been played in a previous trick.
 * @returns {string[]} An array of card strings representing the legal moves.
 */
function getLegalMoves(hand, isLeading, leadSuit, trumpSuit, trumpBroken) {
    if (isLeading) {
        // --- Lead-Out Condition ---
        const hasNonTrumpCards = hand.some(card => getSuit(card) !== trumpSuit);
        if (!trumpBroken && hasNonTrumpCards) {
            // Trump is not broken and player has other suits, so only non-trump cards are legal.
            return hand.filter(card => getSuit(card) !== trumpSuit);
        } else {
            // Trump is broken, OR the player only has trump cards. Any card is legal.
            return [...hand];
        }
    } else {
        // --- Non-Lead-Out (Following) Condition ---
        // 1. Do I have the suit that was led?
        const cardsInLeadSuit = hand.filter(card => getSuit(card) === leadSuit);
        if (cardsInLeadSuit.length > 0) {
            // Yes - I must follow suit.
            return cardsInLeadSuit;
        }

        // 2. No lead suit. Do I have trump?
        const trumpCards = hand.filter(card => getSuit(card) === trumpSuit);
        if (trumpCards.length > 0) {
            // Yes - Trump must be played.
            return trumpCards;
        }

        // 3. No lead suit and no trump. Any card can be played (sluff).
        return [...hand];
    }
}

module.exports = { getLegalMoves };
--- END FILE: backend/src/core/legalMoves.js ---

--- START FILE: backend/src/core/logic.js ---
// backend/src/core/logic.js
// This file contains core game logic functions, including card manipulation and scoring calculations

const { RANKS_ORDER, BID_MULTIPLIERS, PLACEHOLDER_ID, CARD_POINT_VALUES, TABLE_COSTS } = require('./constants');
const transactionManager = require('../db/transactionManager');

// =================================================================
// PURE UTILITY FUNCTIONS
// =================================================================

const getSuit = (cardStr) => (cardStr ? cardStr.slice(-1) : null);
const getRank = (cardStr) => (cardStr ? cardStr.slice(0, -1) : null);

const calculateCardPoints = (cardsArray) => {
    if (!cardsArray || cardsArray.length === 0) return 0;
    return cardsArray.reduce((sum, cardString) => sum + (CARD_POINT_VALUES[getRank(cardString)] || 0), 0);
};

function determineTrickWinner(trickCards, leadSuit, trumpSuit) {
    let highestTrumpPlay = null;
    let highestLeadSuitPlay = null;
    for (const play of trickCards) {
        const cardSuit = getSuit(play.card);
        const cardRankIndex = RANKS_ORDER.indexOf(getRank(play.card));
        if (cardSuit === trumpSuit) {
            if (!highestTrumpPlay || cardRankIndex > RANKS_ORDER.indexOf(getRank(highestTrumpPlay.card))) {
                highestTrumpPlay = play;
            }
        } else if (cardSuit === leadSuit) {
            if (!highestLeadSuitPlay || cardRankIndex > RANKS_ORDER.indexOf(getRank(highestLeadSuitPlay.card))) {
                highestLeadSuitPlay = play;
            }
        }
    }
    return highestTrumpPlay || highestLeadSuitPlay;
}


// =================================================================
// PURE CALCULATION FUNCTIONS (Called by Table Class)
// =================================================================

function calculateForfeitPayout(table, forfeitingPlayerName) {
    const remainingPlayers = Object.values(table.players).filter(p => 
        !p.isSpectator && 
        p.playerName !== forfeitingPlayerName
    );

    if (remainingPlayers.length === 0) return {};

    const tableBuyIn = TABLE_COSTS[table.theme] || 0;
    const forfeitedPot = tableBuyIn;
    const totalScoreOfRemaining = remainingPlayers.reduce((sum, player) => sum + (table.scores[player.playerName] || 0), 0);
    
    const payoutDetails = {};
    if (totalScoreOfRemaining > 0) {
        remainingPlayers.forEach(player => {
            const playerScore = table.scores[player.playerName] || 0;
            const proportion = playerScore / totalScoreOfRemaining;
            const shareOfPot = forfeitedPot * proportion;
            
            payoutDetails[player.playerName] = {
                totalGain: tableBuyIn + shareOfPot,
                buyInReturned: tableBuyIn,
                forfeitShare: shareOfPot,
            };
        });
    } else {
        const evenShare = forfeitedPot / remainingPlayers.length;
        remainingPlayers.forEach(player => {
            payoutDetails[player.playerName] = {
                totalGain: tableBuyIn + evenShare,
                buyInReturned: tableBuyIn,
                forfeitShare: evenShare,
            };
        });
    }

    return payoutDetails;
}

function calculateDrawSplitPayout(table) {
    const tableBuyIn = TABLE_COSTS[table.theme] || 0;
    const playersInOrder = Object.values(table.players)
        .filter(p => !p.isSpectator)
        .map(p => ({ name: p.playerName, score: table.scores[p.playerName] || 0, userId: p.userId }))
        .sort((a, b) => a.score - b.score);

    if (playersInOrder.length !== 3) {
        return { wash: true, players: playersInOrder };
    }

    const [lowest, ...others] = playersInOrder;
    const [p1, p2] = others.sort((a,b) => b.score - a.score);

    const lowestRecoveryPercentage = Math.max(0, lowest.score) / 120;
    const lowestRecoveryAmount = tableBuyIn * lowestRecoveryPercentage;
    const remainingPot = tableBuyIn - lowestRecoveryAmount;
    
    const totalScoreOfSplitters = p1.score + p2.score;
    let p1Share = 0;
    let p2Share = 0;

    if (totalScoreOfSplitters > 0) {
        p1Share = remainingPot * (p1.score / totalScoreOfSplitters);
        p2Share = remainingPot * (p2.score / totalScoreOfSplitters);
    } else {
        p1Share = remainingPot / 2;
        p2Share = remainingPot / 2;
    }

    const payouts = {
        [lowest.name]: { userId: lowest.userId, totalReturn: lowestRecoveryAmount },
        [p1.name]: { userId: p1.userId, totalReturn: tableBuyIn + p1Share },
        [p2.name]: { userId: p2.userId, totalReturn: tableBuyIn + p2Share },
    };

    return { wash: false, payouts };
}

function calculateRoundScoreDetails(table) {
    const { bidWinnerInfo, playerOrderActive, playerMode, capturedTricks, widowDiscardsForFrogBidder, originalDealtWidow, insurance, players, bidderTotalCardPoints } = table;
    const bidWinnerName = bidWinnerInfo.playerName;
    const bidType = bidWinnerInfo.bid;
    const currentBidMultiplier = BID_MULTIPLIERS[bidType];
    
    const activePlayerNames = playerOrderActive.map(id => players[id].playerName);
    
    let widowPoints = 0;
    let widowForReveal = [...originalDealtWidow];
    if (bidType === "Frog") {
        widowPoints = calculateCardPoints(widowDiscardsForFrogBidder);
        widowForReveal = [...widowDiscardsForFrogBidder];
    } else if (bidType === "Solo" || bidType === "Heart Solo") {
        widowPoints = calculateCardPoints(originalDealtWidow);
    }

    let roundMessage = "";
    const pointChanges = {};
    activePlayerNames.forEach(p => pointChanges[p] = 0);
    if(playerMode === 3) pointChanges[PLACEHOLDER_ID] = 0;

    if (insurance.dealExecuted) {
        const agreement = insurance.executedDetails.agreement;
        pointChanges[agreement.bidderPlayerName] += agreement.bidderRequirement;
        for (const defenderName in agreement.defenderOffers) {
            pointChanges[defenderName] -= agreement.defenderOffers[defenderName];
        }
        roundMessage = `Insurance deal executed. Points exchanged based on agreement.`;
    } else {
        const scoreDifferenceFrom60 = bidderTotalCardPoints - 60;
        const exchangeValue = Math.abs(scoreDifferenceFrom60) * currentBidMultiplier;
        if (scoreDifferenceFrom60 === 0) { 
            roundMessage = `${bidWinnerName} scored exactly 60. No points exchanged.`; 
        } else if (bidderTotalCardPoints > 60) {
            let totalPointsGained = 0;
            activePlayerNames.forEach(pName => { 
                if (pName !== bidWinnerName) { 
                    // --- BUG FIX: Each defender only loses the exchange value ---
                    pointChanges[pName] -= exchangeValue;
                    totalPointsGained += exchangeValue; 
                } 
            });
            pointChanges[bidWinnerName] += totalPointsGained;
            roundMessage = `${bidWinnerName} succeeded! Gains ${totalPointsGained} points.`;
        } else { // Bidder failed
            let totalPointsLost = 0;
            const activeOpponents = activePlayerNames.filter(pName => pName !== bidWinnerName);
            activeOpponents.forEach(oppName => { 
                pointChanges[oppName] += exchangeValue; 
                totalPointsLost += exchangeValue; 
            });
            if (playerMode === 3) { 
                pointChanges[PLACEHOLDER_ID] += exchangeValue; 
                totalPointsLost += exchangeValue; 
            }
            else if (playerMode === 4) { 
                const dealerName = table.players[table.dealer]?.playerName;
                if(dealerName && !activeOpponents.includes(dealerName) && dealerName !== bidWinnerName) {
                    pointChanges[dealerName] += exchangeValue; 
                    totalPointsLost += exchangeValue;
                }
            }
            pointChanges[bidWinnerName] -= totalPointsLost;
            roundMessage = `${bidWinnerName} failed. Loses ${totalPointsLost} points.`;
        }
    }
    
    const insuranceHindsight = calculateInsuranceHindsight(table, bidderTotalCardPoints, currentBidMultiplier);

    const finalBidderPoints = bidderTotalCardPoints;
    const finalDefenderPoints = 120 - finalBidderPoints;

    return {
        pointChanges,
        roundMessage,
        widowForReveal,
        insuranceHindsight,
        finalBidderPoints,
        finalDefenderPoints,
        widowPointsValue: widowPoints,
        bidType
    };
}


async function handleGameOver(table, pool) {
    let gameWinnerName = "N/A";
    const { playerOrderActive, scores, theme, gameId, players } = table;
    try {
        const tableCost = TABLE_COSTS[theme] || 0;
        const transactionPromises = [];
        const statPromises = [];

        const finalPlayerScores = playerOrderActive
            .map(id => players[id])
            .filter(p => p && !p.isBot)
            .map(p => ({ name: p.playerName, score: scores[p.playerName], userId: p.userId }))
            .sort((a, b) => b.score - a.score);
        
        if (finalPlayerScores.length === 3) {
            const [p1, p2, p3] = finalPlayerScores;
            if (p1.score > p2.score && p2.score > p3.score) {
                gameWinnerName = p1.name;
                transactionPromises.push(transactionManager.postTransaction(pool, { userId: p1.userId, gameId, type: 'win_payout', amount: tableCost * 2, description: `Win and Payout from ${p3.name}` }));
                statPromises.push(pool.query("UPDATE users SET wins = wins + 1 WHERE id = $1", [p1.userId]));
                transactionPromises.push(transactionManager.postTransaction(pool, { userId: p2.userId, gameId, type: 'wash_payout', amount: tableCost, description: `Wash - Buy-in returned` }));
                statPromises.push(pool.query("UPDATE users SET washes = washes + 1 WHERE id = $1", [p2.userId]));
                statPromises.push(pool.query("UPDATE users SET losses = losses + 1 WHERE id = $1", [p3.userId]));
            }
            else if (p1.score === p2.score && p2.score > p3.score) {
                gameWinnerName = `${p1.name} & ${p2.name}`;
                transactionPromises.push(transactionManager.postTransaction(pool, { userId: p1.userId, gameId, type: 'win_payout', amount: tableCost * 1.5, description: `Win (tie) - Split payout from ${p3.name}` }));
                transactionPromises.push(transactionManager.postTransaction(pool, { userId: p2.userId, gameId, type: 'win_payout', amount: tableCost * 1.5, description: `Win (tie) - Split payout from ${p3.name}` }));
                statPromises.push(pool.query("UPDATE users SET wins = wins + 1 WHERE id = ANY($1::int[])", [[p1.userId, p2.userId]]));
                statPromises.push(pool.query("UPDATE users SET losses = losses + 1 WHERE id = $1", [p3.userId]));
            }
            else if (p1.score > p2.score && p2.score === p3.score) {
                gameWinnerName = p1.name;
                transactionPromises.push(transactionManager.postTransaction(pool, { userId: p1.userId, gameId, type: 'win_payout', amount: tableCost * 3, description: `Win - Collects full pot` }));
                statPromises.push(pool.query("UPDATE users SET wins = wins + 1 WHERE id = $1", [p1.userId]));
                statPromises.push(pool.query("UPDATE users SET losses = losses + 1 WHERE id = ANY($1::int[])", [[p2.userId, p3.userId]]));
            }
            else {
                gameWinnerName = "3-Way Tie";
                finalPlayerScores.forEach(p => {
                    transactionPromises.push(transactionManager.postTransaction(pool, { userId: p.userId, gameId, type: 'wash_payout', amount: tableCost, description: `3-Way Tie - Buy-in returned` }));
                    statPromises.push(pool.query("UPDATE users SET washes = washes + 1 WHERE id = $1", [p.userId]));
                });
            }
        }
        
        await Promise.all(transactionPromises);
        await Promise.all(statPromises);
        await transactionManager.updateGameRecordOutcome(pool, gameId, `Game Over! Winner: ${gameWinnerName}`);
        
    } catch(err) {
        console.error("Database error during game over update:", err);
    }
    return { gameWinnerName };
}

function calculateInsuranceHindsight(table, bidderTotalCardPoints, currentBidMultiplier) {
    if (table.playerMode !== 3) return null;
    const { playerOrderActive, bidWinnerInfo, insurance, players } = table;
    const bidWinnerName = bidWinnerInfo.playerName;
    const insuranceHindsight = {};
    const activePlayerNames = playerOrderActive.map(id => players[id].playerName);
    const defenders = activePlayerNames.filter(p => p !== bidWinnerName);
    const outcomeFromCards = {};
    const scoreDifferenceFrom60 = bidderTotalCardPoints - 60;
    const exchangeValue = Math.abs(scoreDifferenceFrom60) * currentBidMultiplier;
    if (scoreDifferenceFrom60 > 0) {
        outcomeFromCards[bidWinnerName] = exchangeValue * 2;
        defenders.forEach(def => outcomeFromCards[def] = -exchangeValue);
    } else if (scoreDifferenceFrom60 < 0) {
        outcomeFromCards[bidWinnerName] = -(exchangeValue * 2);
        defenders.forEach(def => outcomeFromCards[def] = exchangeValue);
    } else {
         activePlayerNames.forEach(p => outcomeFromCards[p] = 0);
    }
    const potentialOutcomeFromDeal = {};
    const sumOfFinalOffers = Object.values(insurance.defenderOffers).reduce((sum, offer) => sum + offer, 0);
    potentialOutcomeFromDeal[bidWinnerName] = sumOfFinalOffers;
    const costPerDefenderForced = Math.round(insurance.bidderRequirement / defenders.length);
    defenders.forEach(def => { potentialOutcomeFromDeal[def] = -costPerDefenderForced; });
    const actualOutcomeFromDeal = {};
    if (insurance.dealExecuted) {
        const agreement = insurance.executedDetails.agreement;
        actualOutcomeFromDeal[agreement.bidderPlayerName] = agreement.bidderRequirement;
        for (const defName in agreement.defenderOffers) {
            actualOutcomeFromDeal[defName] = -agreement.defenderOffers[defName];
       }
    }
    activePlayerNames.forEach(pName => {
        let actualPoints, potentialPoints;
        if (insurance.dealExecuted) {
            actualPoints = actualOutcomeFromDeal[pName];
            potentialPoints = outcomeFromCards[pName];
        } else {
            actualPoints = outcomeFromCards[pName];
            potentialPoints = potentialOutcomeFromDeal[pName];
        }
        insuranceHindsight[pName] = {
            actualPoints: actualPoints || 0,
            actualReason: insurance.dealExecuted ? "Insurance Deal" : "Card Outcome",
            potentialPoints: potentialPoints || 0,
            potentialReason: insurance.dealExecuted ? "Played it Out" : "Taken Insurance Deal",
            hindsightValue: (actualPoints || 0) - (potentialPoints || 0)
        };
    });
    return insuranceHindsight;
}

module.exports = {
    getSuit,
    getRank,
    determineTrickWinner,
    calculateRoundScoreDetails,
    handleGameOver,
    calculateForfeitPayout,
    calculateDrawSplitPayout,
    calculateCardPoints
};
--- END FILE: backend/src/core/logic.js ---

--- START FILE: backend/src/core/Table.js ---
// backend/src/core/Table.js

const { SERVER_VERSION, TABLE_COSTS, BID_HIERARCHY, PLACEHOLDER_ID, deck, SUITS, BID_MULTIPLIERS } = require('./constants');
const gameLogic = require('./logic');
const BotPlayer = require('./BotPlayer');
// --- PATH CORRECTION: The 'db' folder is now 'data' inside the 'src' directory ---
const transactionManager = require('../data/transactionManager');
const { shuffle } = require('../utils/shuffle');

const BOT_NAMES = ["Mike Knight", "Grandma Joe", "Grampa Blane", "Kimba", "Courtney Sr.", "Cliff"];

class Table {
    constructor(tableId, theme, tableName, io, pool, emitLobbyUpdateCallback) {
        this.io = io;
        this.pool = pool;
        this.emitLobbyUpdateCallback = emitLobbyUpdateCallback;
        this.tableId = tableId;
        this.tableName = tableName;
        this.theme = theme;
        this.serverVersion = SERVER_VERSION;
        this.state = "Waiting for Players";
        this.players = {};
        this.playerOrderActive = [];
        this.scores = {};
        this.gameStarted = false;
        this.gameId = null;
        this.playerMode = null;
        this.dealer = null;
        this.internalTimers = {};
        this.bots = {};
        this._nextBotId = -1;
        this.pendingBotAction = null;
        this._initializeNewRoundState();
    }
    
    // =================================================================
    // PUBLIC: Forfeit & Timeout Logic
    // =================================================================

    startForfeitTimer(requestingUserId, targetPlayerName) {
        if (!this.players[requestingUserId] || this.internalTimers.forfeit) return;
        const targetPlayer = Object.values(this.players).find(p => p.playerName === targetPlayerName);
        if (!targetPlayer || !targetPlayer.disconnected) {
            return this.io.to(this.players[requestingUserId].socketId).emit("error", { message: "Cannot start timer: Player is not disconnected." });
        }
        console.log(`[${this.tableId}] Forfeit timer started for ${targetPlayerName} by ${this.players[requestingUserId].playerName}.`);
        this.forfeiture.targetPlayerName = targetPlayerName;
        this.forfeiture.timeLeft = 120;
        this.internalTimers.forfeit = setInterval(() => {
            if (!this.forfeiture.targetPlayerName) return this._clearForfeitTimer();
            this.forfeiture.timeLeft -= 1;
            if (this.forfeiture.timeLeft <= 0) {
                this._resolveForfeit(targetPlayerName, "timeout");
            } else {
                this._emitUpdate();
            }
        }, 1000);
        this._emitUpdate();
    }

    forfeitGame(userId) {
        const playerName = this.players[userId]?.playerName;
        if (!playerName || !this.gameStarted) return;
        this._resolveForfeit(playerName, "voluntary forfeit");
    }

    // =================================================================
    // PUBLIC: Player & Connection Management
    // =================================================================
    
    async joinTable(user, socketId) {
        const { id, username } = user;
        const isPlayerAlreadyInGame = !!this.players[id];

        if (isPlayerAlreadyInGame) {
            // This is a returning player, just update their connection status
            this.players[id].disconnected = false;
            this.players[id].socketId = socketId;
        } else {
            // This is a new player
            const activePlayersCount = Object.values(this.players).filter(p => !p.isSpectator).length;

            if (this.gameStarted || activePlayersCount >= 4) {
                // Game is full or started, add as spectator
                this.players[id] = { userId: id, playerName: username, socketId: socketId, isSpectator: true, disconnected: false };
            } else {
                // Check if they can afford to join
                const tableCost = TABLE_COSTS[this.theme] || 0;
                try {
                    const tokenResult = await this.pool.query("SELECT SUM(amount) as tokens FROM transactions WHERE user_id = $1", [id]);
                    const userTokens = parseFloat(tokenResult.rows[0]?.tokens || 0);
                    if (userTokens < tableCost) {
                        return this.io.to(socketId).emit("error", { message: `You need ${tableCost} tokens to join. You have ${userTokens.toFixed(2)}.` });
                    }
                    // Add as an active player
                    this.players[id] = { userId: id, playerName: username, socketId: socketId, isSpectator: false, disconnected: false };
                } catch (err) {
                    return this.io.to(socketId).emit("error", { message: "A server error occurred trying to join the table." });
                }
            }
        }

        if (!this.scores[username]) {
            this.scores[username] = 120;
        }

        this._recalculateActivePlayerOrder();

        const activePlayersAfterJoin = this.playerOrderActive.length;
        if (!this.gameStarted) {
            if (activePlayersAfterJoin >= 3) {
                this.state = "Ready to Start";
            } else {
                this.state = "Waiting for Players";
            }
        }
        
        await this._syncPlayerTokens(Object.keys(this.players));
        this.io.to(socketId).emit("joinedTable", { tableId: this.tableId, gameState: this.getStateForClient() });
        this._emitUpdate();
        this.emitLobbyUpdateCallback();
    }

    addBotPlayer() {
        const currentPlayers = Object.values(this.players).filter(p => !p.isSpectator);
        if (currentPlayers.length >= 4) return;

        const currentBotNames = new Set(currentPlayers.filter(p => p.isBot).map(p => p.playerName));
        const availableNames = BOT_NAMES.filter(name => !currentBotNames.has(name));

        if (availableNames.length === 0) {
            console.log(`[${this.tableId}] No available bot names to add.`);
            return;
        }

        const botName = availableNames[Math.floor(Math.random() * availableNames.length)];
        
        const botId = this._nextBotId--;
        this.players[botId] = {
            userId: botId,
            playerName: botName,
            socketId: null,
            isSpectator: false,
            disconnected: false,
            isBot: true
        };
        this.bots[botId] = new BotPlayer(botId, botName, this);
        if (!this.scores[botName]) this.scores[botName] = 120;
        this._recalculateActivePlayerOrder();
        const activePlayers = this.playerOrderActive.length;
        if (activePlayers >= 3 && !this.gameStarted) this.state = 'Ready to Start';
        this._emitUpdate();
        this.emitLobbyUpdateCallback();
    }

    async leaveTable(userId) {
        if (!this.players[userId]) return;
        const playerInfo = this.players[userId];
        const safeLeaveStates = ["Waiting for Players", "Ready to Start", "Game Over"];
        if (safeLeaveStates.includes(this.state) || playerInfo.isSpectator) { delete this.players[userId]; }
        else if (this.gameId && this.gameStarted) { this.disconnectPlayer(userId); }
        else { delete this.players[userId]; }
        if (playerInfo.isBot) {
            delete this.bots[userId];
        }
        this._recalculateActivePlayerOrder();
        await this._syncPlayerTokens(Object.keys(this.players));
        this._emitUpdate();
        this.emitLobbyUpdateCallback();
    }
    
    disconnectPlayer(userId) {
        const player = this.players[userId];
        if (!player) return;
        if (!this.gameStarted || player.isSpectator) {
            delete this.players[userId];
            this._recalculateActivePlayerOrder();
        } else {
            console.log(`[${this.tableId}] Player ${player.playerName} has disconnected.`);
            player.disconnected = true;
        }
        this._emitUpdate();
        this.emitLobbyUpdateCallback();
    }
    
    reconnectPlayer(userId, socket) {
        if (!this.players[userId] || !this.players[userId].disconnected) return;
        console.log(`[${this.tableId}] Reconnecting user ${this.players[userId].playerName}.`);
        this.players[userId].disconnected = false;
        this.players[userId].socketId = socket.id;
        socket.join(this.tableId);
        if (this.forfeiture.targetPlayerName === this.players[userId].playerName) {
            this._clearForfeitTimer();
            console.log(`[${this.tableId}] Cleared timeout for reconnected player ${this.players[userId].playerName}.`);
        }
        this._emitUpdate();
        this.emitLobbyUpdateCallback();
    }

    async startGame(requestingUserId) {
        if (this.gameStarted) return;
        if (!this.players[requestingUserId] || this.players[requestingUserId].isSpectator) return;
        const activePlayers = Object.values(this.players).filter(p => !p.isSpectator && !p.disconnected);
        if (activePlayers.length < 3) { 
            const userSocket = this.io.sockets.sockets.get(this.players[requestingUserId].socketId);
            if (userSocket) {
                userSocket.emit("gameStartError", { message: "Need at least 3 players to start." });
            }
            return;
        }
        this.playerMode = activePlayers.length;
        const activePlayerIds = activePlayers.map(p => p.userId);
        const humanIds = activePlayers.filter(p => !p.isBot).map(p => p.userId);
        try {
            this.gameId = await transactionManager.createGameRecord(this.pool, this);
            if (humanIds.length > 0) {
                await transactionManager.handleGameStartTransaction(this.pool, this, humanIds, this.gameId);
            }
            this.gameStarted = true;
            activePlayers.forEach(p => { if (this.scores[p.playerName] === undefined) this.scores[p.playerName] = 120; });
            if (this.playerMode === 3 && this.scores[PLACEHOLDER_ID] === undefined) { this.scores[PLACEHOLDER_ID] = 120; }
            const shuffledPlayerIds = shuffle([...activePlayerIds]);
            this.dealer = shuffledPlayerIds[0];
            this._recalculateActivePlayerOrder();
            this._initializeNewRoundState();
            this.state = "Dealing Pending";
            await this._syncPlayerTokens(activePlayerIds);
            this._emitUpdate();
            this.emitLobbyUpdateCallback();
        } catch (err) {
            const insufficientFundsMatch = err.message.match(/(.+) has insufficient tokens/);
            if (insufficientFundsMatch) {
                const brokePlayerName = insufficientFundsMatch[1];
                const brokePlayer = Object.values(this.players).find(p => p.playerName === brokePlayerName);
                if (brokePlayer) {
                    delete this.players[brokePlayer.userId];
                    this._recalculateActivePlayerOrder();
                    this.playerMode = this.playerOrderActive.length;
                    this.state = this.playerMode >= 3 ? "Ready to Start" : "Waiting for Players";
                    this.gameId = null; 
                    this.io.to(this.tableId).emit("gameStartFailed", { message: err.message, kickedPlayer: brokePlayerName });
                    this._emitUpdate();
                    this.emitLobbyUpdateCallback();
                }
            } else {
                const userSocket = this.io.sockets.sockets.get(this.players[requestingUserId].socketId);
                if (userSocket) {
                    userSocket.emit("gameStartError", { message: err.message || "A server error occurred during buy-in." });
                }
                this.gameStarted = false; 
                this.playerMode = null;
                this.gameId = null;
            }
        }
    }
    
    dealCards(requestingUserId) {
        if (this.state !== "Dealing Pending" || requestingUserId !== this.dealer) return;
        const shuffledDeck = shuffle([...deck]);
        this.playerOrderActive.forEach((playerId, i) => {
            const playerName = this.players[playerId].playerName;
            this.hands[playerName] = shuffledDeck.slice(i * 11, (i + 1) * 11);
        });
        this.widow = shuffledDeck.slice(11 * this.playerOrderActive.length);
        this.originalDealtWidow = [...this.widow];
        this.state = "Bidding Phase";
        this.biddingTurnPlayerId = this.playerOrderActive[0];
        this._emitUpdate();
    }

    placeBid(userId, bid) {
        if (userId !== this.biddingTurnPlayerId) return;
        const player = this.players[userId];
        if (!player) return;

        if (this.state === "Awaiting Frog Upgrade Decision") {
            if (userId !== this.originalFrogBidderId || (bid !== "Heart Solo" && bid !== "Pass")) return;
            if (bid === "Heart Solo") { this.currentHighestBidDetails = { userId, playerName: player.playerName, bid: "Heart Solo" }; }
            this.biddingTurnPlayerId = null;
            this._resolveBiddingFinal();
            return;
        }
        if (this.state !== "Bidding Phase" || !BID_HIERARCHY.includes(bid) || this.playersWhoPassedThisRound.includes(userId)) return;
        
        const currentHighestBidIndex = this.currentHighestBidDetails ? BID_HIERARCHY.indexOf(this.currentHighestBidDetails.bid) : -1;
        if (bid !== "Pass" && BID_HIERARCHY.indexOf(bid) <= currentHighestBidIndex) return;
        
        if (bid !== "Pass") {
            this.currentHighestBidDetails = { userId, playerName: player.playerName, bid };
            if (bid === "Frog" && !this.originalFrogBidderId) this.originalFrogBidderId = userId;
            if (bid === "Solo" && this.originalFrogBidderId && userId !== this.originalFrogBidderId) this.soloBidMadeAfterFrog = true;
        } else { this.playersWhoPassedThisRound.push(userId); }
        
        const activeBiddersRemaining = this.playerOrderActive.filter(id => !this.playersWhoPassedThisRound.includes(id));
        if ((this.currentHighestBidDetails && activeBiddersRemaining.length <= 1) || this.playersWhoPassedThisRound.length === this.playerOrderActive.length) {
            this.biddingTurnPlayerId = null;
            this._checkForFrogUpgrade();
        } else {
            let currentBidderIndex = this.playerOrderActive.indexOf(userId);
            let nextBidderId = null;
            for (let i = 1; i < this.playerOrderActive.length; i++) {
                let potentialNextBidderId = this.playerOrderActive[(currentBidderIndex + i) % this.playerOrderActive.length];
                if (!this.playersWhoPassedThisRound.includes(potentialNextBidderId)) {
                    nextBidderId = potentialNextBidderId;
                    break;
                }
            }
            if (nextBidderId) { this.biddingTurnPlayerId = nextBidderId; }
            else { this._checkForFrogUpgrade(); }
        }
        this._emitUpdate();
    }
    
    chooseTrump(userId, suit) {
        if (this.state !== "Trump Selection" || this.bidWinnerInfo?.userId !== userId || !["S", "C", "D"].includes(suit)) {
            return;
        }
        this.trumpSuit = suit;
        this._transitionToPlayingPhase();
    }

    submitFrogDiscards(userId, discards) {
        const player = this.players[userId];
        if (!player || this.state !== "Frog Widow Exchange" || this.bidWinnerInfo?.userId !== userId || !Array.isArray(discards) || discards.length !== 3) {
            return;
        }
        const currentHand = this.hands[player.playerName];
        if (!discards.every(card => currentHand.includes(card))) {
            return this.io.to(player.socketId).emit("error", { message: "Invalid discard selection." });
        }
        this.widowDiscardsForFrogBidder = discards;
        this.hands[player.playerName] = currentHand.filter(card => !discards.includes(card));
        this._transitionToPlayingPhase();
    }

    playCard(userId, card) {
        if (userId !== this.trickTurnPlayerId) return;
        const player = this.players[userId];
        if (!player) return;

        const hand = this.hands[player.playerName];
        if (!hand || !hand.includes(card)) return;
        
        const isLeading = this.currentTrickCards.length === 0;
        const playedSuit = gameLogic.getSuit(card);
        if (isLeading) {
            if (playedSuit === this.trumpSuit && !this.trumpBroken && !hand.every(c => gameLogic.getSuit(c) === this.trumpSuit)) {
                const msg = "Cannot lead trump until it is broken.";
                console.error(`[${this.tableId}] ILLEGAL MOVE by ${player.playerName}: ${msg}`);
                return this.io.to(player.socketId).emit("error", { message: msg });
            }
        } else {
            const leadCardSuit = this.leadSuitCurrentTrick;
            const hasLeadSuit = hand.some(c => gameLogic.getSuit(c) === leadCardSuit);
            if (hasLeadSuit && playedSuit !== leadCardSuit) {
                const msg = `Must follow suit (${SUITS[leadCardSuit]}).`;
                console.error(`[${this.tableId}] ILLEGAL MOVE by ${player.playerName}: ${msg}`);
                return this.io.to(player.socketId).emit("error", { message: msg });
            }
            if (!hasLeadSuit && hand.some(c => gameLogic.getSuit(c) === this.trumpSuit) && playedSuit !== this.trumpSuit) {
                const msg = "You must play trump if you cannot follow suit.";
                console.error(`[${this.tableId}] ILLEGAL MOVE by ${player.playerName}: ${msg}`);
                return this.io.to(player.socketId).emit("error", { message: msg });
            }
        }
        this.hands[player.playerName] = hand.filter(c => c !== card);
        this.currentTrickCards.push({ userId, playerName: player.playerName, card });
        if (isLeading) this.leadSuitCurrentTrick = playedSuit;
        if (playedSuit === this.trumpSuit) this.trumpBroken = true;
        
        const expectedCardsInTrick = this.playerOrderActive.length;
        if (this.currentTrickCards.length === expectedCardsInTrick) {
            this._resolveTrick();
        } else {
            const currentTurnPlayerIndex = this.playerOrderActive.indexOf(userId);
            this.trickTurnPlayerId = this.playerOrderActive[(currentTurnPlayerIndex + 1) % expectedCardsInTrick];
            this._emitUpdate();
        }
    }

    requestNextRound(requestingUserId) {
        if (this.state === "Awaiting Next Round Trigger" && requestingUserId === this.roundSummary?.dealerOfRoundId) { this._advanceRound(); }
    }

    async reset() {
        console.log(`[${this.tableId}] Game is being reset.`);
        this._clearAllTimers();
        const originalPlayers = { ...this.players };
        Object.assign(this, new Table(this.tableId, this.theme, this.tableName, this.io, this.pool, this.emitLobbyUpdateCallback));
        const playerIdsToKeep = [];
        for (const userId in originalPlayers) {
            const playerInfo = originalPlayers[userId];
            if (!playerInfo.disconnected) {
                this.players[userId] = { ...playerInfo, isSpectator: false, socketId: playerInfo.socketId };
                if (playerInfo.isBot) {
                    this.bots[userId] = new BotPlayer(parseInt(userId,10), playerInfo.playerName, this);
                }
                this.scores[playerInfo.playerName] = 120;
                if (!playerInfo.isSpectator) { playerIdsToKeep.push(parseInt(userId, 10)); }
            }
        }
        const botIds = Object.keys(this.bots).map(id => parseInt(id,10));
        this._nextBotId = botIds.length ? Math.min(...botIds) - 1 : -1;
        this._recalculateActivePlayerOrder();
        this.playerMode = this.playerOrderActive.length;
        this.state = this.playerMode >= 3 ? "Ready to Start" : "Waiting for Players";
        await this._syncPlayerTokens(playerIdsToKeep);
        this._emitUpdate();
        this.emitLobbyUpdateCallback();
    }
    
    updateInsuranceSetting(userId, settingType, value) {
        const player = this.players[userId];
        if (!player || !this.insurance.isActive || this.insurance.dealExecuted) return;

        const multiplier = this.insurance.bidMultiplier;
        const parsedValue = parseInt(value, 10);
        if (isNaN(parsedValue)) return;

        if (settingType === 'bidderRequirement' && player.playerName === this.insurance.bidderPlayerName) {
            const minReq = -120 * multiplier;
            const maxReq = 120 * multiplier;
            if (parsedValue >= minReq && parsedValue <= maxReq) {
                this.insurance.bidderRequirement = parsedValue;
            }
        } else if (settingType === 'defenderOffer' && this.insurance.defenderOffers.hasOwnProperty(player.playerName)) {
            const minOffer = -60 * multiplier;
            const maxOffer = 60 * multiplier;
            if (parsedValue >= minOffer && parsedValue <= maxOffer) {
                this.insurance.defenderOffers[player.playerName] = parsedValue;
            }
        } else {
            return;
        }

        const sumOfOffers = Object.values(this.insurance.defenderOffers || {}).reduce((sum, offer) => sum + (offer || 0), 0);
        if (this.insurance.bidderRequirement <= sumOfOffers) {
            this.insurance.dealExecuted = true;
            this.insurance.executedDetails = {
                agreement: {
                    bidderPlayerName: this.insurance.bidderPlayerName,
                    bidderRequirement: this.insurance.bidderRequirement,
                    defenderOffers: { ...this.insurance.defenderOffers }
                }
            };
        }
        this._emitUpdate();
    }


    requestDraw(userId) {
        const player = this.players[userId];
        if (!player || this.drawRequest.isActive || this.state !== 'Playing Phase') return;
        this.drawRequest.isActive = true;
        this.drawRequest.initiator = player.playerName;
        this.drawRequest.votes = {};
        const activePlayers = Object.values(this.players).filter(p => !p.isSpectator);
        activePlayers.forEach(p => {
            this.drawRequest.votes[p.playerName] = (p.playerName === player.playerName) ? 'wash' : null;
        });
        this.drawRequest.timer = 30;
        this.internalTimers.draw = setInterval(() => {
            if (!this.drawRequest.isActive) return clearInterval(this.internalTimers.draw);
            this.drawRequest.timer -= 1;
            if (this.drawRequest.timer <= 0) {
                clearInterval(this.internalTimers.draw);
                this.drawRequest.isActive = false;
                this.io.to(this.tableId).emit("notification", { message: "Draw request timed out. Game resumes." });
                this._emitUpdate();
            } else {
                this._emitUpdate();
            }
        }, 1000);
        this._emitUpdate();
    }

    async submitDrawVote(userId, vote) {
        const player = this.players[userId];
        if (!player || !this.drawRequest.isActive || !['wash', 'split', 'no'].includes(vote) || this.drawRequest.votes[player.playerName] !== null) return;
        
        this.drawRequest.votes[player.playerName] = vote;
    
        if (vote === 'no') {
            clearInterval(this.internalTimers.draw);
            this.drawRequest.isActive = false;
            this.io.to(this.tableId).emit("notification", { message: `${player.playerName} vetoed the draw. Game resumes.` });
            this._emitUpdate();
            return;
        }
    
        const allVotes = Object.values(this.drawRequest.votes);
        if (!allVotes.every(v => v !== null)) {
            this._emitUpdate();
            return;
        }

        clearInterval(this.internalTimers.draw);
        this.drawRequest.isActive = false;
        
        try {
            const voteCounts = allVotes.reduce((acc, v) => { acc[v] = (acc[v] || 0) + 1; return acc; }, {});
            const tableCost = TABLE_COSTS[this.theme] || 0;
            const activePlayers = Object.values(this.players).filter(p => !p.isSpectator);
            let outcomeMessage = "Draw resolved.";
            const transactionPromises = [];
    
            if (voteCounts.wash === activePlayers.length) {
                outcomeMessage = "All players agreed to a wash. All buy-ins returned.";
                activePlayers.forEach(p => {
                    transactionPromises.push(transactionManager.postTransaction(this.pool, { userId: p.userId, gameId: this.gameId, type: 'wash_payout', amount: tableCost, description: `Draw Outcome: Wash` }));
                });
            } else if (voteCounts.wash > 0 && voteCounts.split > 0) {
                outcomeMessage = "A split was agreed upon. Payouts calculated by score.";
                const payoutResult = gameLogic.calculateDrawSplitPayout(this);
                if (payoutResult && payoutResult.payouts) {
                    for (const playerName in payoutResult.payouts) {
                        const pData = payoutResult.payouts[playerName];
                        transactionPromises.push(transactionManager.postTransaction(this.pool, { userId: pData.userId, gameId: this.gameId, type: 'win_payout', amount: pData.totalReturn, description: `Draw Outcome: Split` }));
                    }
                }
            } else {
                outcomeMessage = "The draw resulted in a wash. All buy-ins returned.";
                activePlayers.forEach(p => {
                    transactionPromises.push(transactionManager.postTransaction(this.pool, { userId: p.userId, gameId: this.gameId, type: 'wash_payout', amount: tableCost, description: `Draw Outcome: Wash (Default)` }));
                });
            }
            
            await Promise.all(transactionPromises);
            await transactionManager.updateGameRecordOutcome(this.pool, this.gameId, outcomeMessage);
    
            this.state = "Game Over";
            this.roundSummary = { message: outcomeMessage, isGameOver: true, finalScores: this.scores };
            this._emitUpdate();
            this.emitLobbyUpdateCallback();

            this.internalTimers.drawReset = setTimeout(() => this.reset(), 10000);

        } catch (error) {
            console.error(`[${this.tableId}] Error resolving draw vote:`, error);
            this.io.to(this.tableId).emit("notification", { message: `A server error occurred resolving the draw. Resuming game.` });
            this.drawRequest = this._getInitialDrawRequestState();
            this._emitUpdate();
        }
    }

    // =================================================================
    // INTERNAL: Game Flow and State Transitions (_prefix)
    // =================================================================

    _clearForfeitTimer() {
        if (this.internalTimers.forfeit) {
            clearInterval(this.internalTimers.forfeit);
            delete this.internalTimers.forfeit;
        }
        this.forfeiture = this._getInitialForfeitureState();
    }

    async _resolveForfeit(forfeitingPlayerName, reason) {
        if (this.state === "Game Over" || !this.gameId) return;
        console.log(`[${this.tableId}] Resolving forfeit for ${forfeitingPlayerName}. Reason: ${reason}`);
        this._clearAllTimers();
        try {
            const forfeitingPlayer = Object.values(this.players).find(p => p.playerName === forfeitingPlayerName);
            const remainingPlayers = Object.values(this.players).filter(p => !p.isSpectator && p.playerName !== forfeitingPlayerName && !p.isBot);
            const tokenChanges = gameLogic.calculateForfeitPayout(this, forfeitingPlayerName);
            const transactionPromises = [];
            if (forfeitingPlayer && !forfeitingPlayer.isBot) {
                transactionPromises.push(transactionManager.postTransaction(this.pool, {
                    userId: forfeitingPlayer.userId, gameId: this.gameId, type: 'forfeit_loss',
                    amount: 0, description: `Forfeited game on table ${this.tableName}`
                }));
            }
            remainingPlayers.forEach(player => {
                const payoutInfo = tokenChanges[player.playerName];
                if (payoutInfo && payoutInfo.totalGain > 0) {
                    transactionPromises.push(transactionManager.postTransaction(this.pool, {
                        userId: player.userId, gameId: this.gameId, type: 'forfeit_payout',
                        amount: payoutInfo.totalGain, description: `Payout from ${forfeitingPlayerName}'s forfeit`
                    }));
                }
            });
            await Promise.all(transactionPromises);
            const statUpdatePromises = [];
            if (forfeitingPlayer && !forfeitingPlayer.isBot) {
                statUpdatePromises.push(this.pool.query("UPDATE users SET losses = losses + 1 WHERE id = $1", [forfeitingPlayer.userId]));
            }
            remainingPlayers.forEach(player => {
                statUpdatePromises.push(this.pool.query("UPDATE users SET washes = washes + 1 WHERE id = $1", [player.userId]));
            });
            await Promise.all(statUpdatePromises);
            const outcomeMessage = `${forfeitingPlayerName} has forfeited the game due to ${reason}.`;
            await transactionManager.updateGameRecordOutcome(this.pool, this.gameId, outcomeMessage);
            Object.values(this.players).forEach(p => {
                const playerSocket = this.io.sockets.sockets.get(p.socketId);
                if (playerSocket) {
                    playerSocket.emit("requestUserSync");
                }
            });
            this.roundSummary = {
                message: `${outcomeMessage} The game has ended.`, isGameOver: true,
                gameWinner: `Payout to remaining players.`, finalScores: this.scores, payouts: tokenChanges,
            };
            this.state = "Game Over";
            this._emitUpdate();
            this.emitLobbyUpdateCallback();
        } catch (err) {
            console.error(`Database error during forfeit resolution for table ${this.tableId}:`, err);
        }
    }
    
    _resolveTrick() {
        const winnerInfo = gameLogic.determineTrickWinner(this.currentTrickCards, this.leadSuitCurrentTrick, this.trumpSuit);
        this.lastCompletedTrick = { cards: [...this.currentTrickCards], winnerName: winnerInfo.playerName };
        
        const trickPoints = gameLogic.calculateCardPoints(this.lastCompletedTrick.cards.map(p => p.card));
        const winnerIsBidder = winnerInfo.playerName === this.bidWinnerInfo.playerName;
        if (winnerIsBidder) {
            this.bidderCardPoints += trickPoints;
        } else {
            this.defenderCardPoints += trickPoints;
        }

        this.tricksPlayedCount++;
        this.trickLeaderId = winnerInfo.userId;
        const winnerName = winnerInfo.playerName;
        if (winnerName && !this.capturedTricks[winnerName]) { this.capturedTricks[winnerName] = []; }
        if (winnerName) { this.capturedTricks[winnerName].push(this.currentTrickCards.map(p => p.card)); }
        
        if (this.tricksPlayedCount === 11) {
            this._calculateRoundScores();
        } else {
            this.state = "TrickCompleteLinger";
            this._emitUpdate();
            this.internalTimers.trickLinger = setTimeout(() => {
                if (this.state === "TrickCompleteLinger") {
                    this.currentTrickCards = [];
                    this.leadSuitCurrentTrick = null;
                    this.trickTurnPlayerId = winnerInfo.userId;
                    this.state = "Playing Phase";
                    this._emitUpdate();
                }
            }, 1000);
        }
    }

    _resolveBiddingFinal() {
        if (!this.currentHighestBidDetails) {
            this.state = "AllPassWidowReveal";
            this._emitUpdate();
            this.internalTimers.allPass = setTimeout(() => {
                if (this.state === "AllPassWidowReveal") {
                    this._advanceRound();
                }
            }, 3000);
            return;
        }
        this.bidWinnerInfo = { ...this.currentHighestBidDetails };
        const bid = this.bidWinnerInfo.bid;
        if (bid === "Frog") { 
            this.trumpSuit = "H"; 
            this.state = "Frog Widow Exchange";
            this.revealedWidowForFrog = [...this.widow];
            const bidderHand = this.hands[this.bidWinnerInfo.playerName];
            this.hands[this.bidWinnerInfo.playerName] = [...bidderHand, ...this.widow];
        } else if (bid === "Heart Solo") { 
            this.trumpSuit = "H"; 
            this._transitionToPlayingPhase();
        } else if (bid === "Solo") { 
            this.state = "Trump Selection";
        }
        this._emitUpdate();
        this.originalFrogBidderId = null;
        this.soloBidMadeAfterFrog = false;
    }

    _checkForFrogUpgrade() {
        if (this.soloBidMadeAfterFrog && this.originalFrogBidderId) {
            this.state = "Awaiting Frog Upgrade Decision";
            this.biddingTurnPlayerId = this.originalFrogBidderId;
        } else { this._resolveBiddingFinal(); }
        this._emitUpdate();
    }
    
    _transitionToPlayingPhase() {
        this.state = "Playing Phase";
        this.tricksPlayedCount = 0;
        this.trumpBroken = false;
        this.currentTrickCards = [];
        this.leadSuitCurrentTrick = null;
        this.lastCompletedTrick = null;
        this.trickLeaderId = this.bidWinnerInfo.userId;
        this.trickTurnPlayerId = this.bidWinnerInfo.userId;
        if (this.playerMode === 3) {
            this.insurance.isActive = true;
            const multiplier = BID_MULTIPLIERS[this.bidWinnerInfo.bid];
            this.insurance.bidMultiplier = multiplier;
            this.insurance.bidderPlayerName = this.bidWinnerInfo.playerName;
            this.insurance.bidderRequirement = 120 * multiplier;
            const defenders = this.playerOrderActive.map(id => this.players[id].playerName).filter(pName => pName !== this.bidWinnerInfo.playerName);
            defenders.forEach(defName => { this.insurance.defenderOffers[defName] = -60 * multiplier; });
        }
        this._emitUpdate();
    }
    
    _advanceRound() {
        if (!this.gameStarted) return;
        const oldDealerId = this.playerOrderActive.shift();
        this.playerOrderActive.push(oldDealerId);
        this.dealer = this.playerOrderActive[0];
        
        if (!this.players[this.dealer]) {
            console.error(`[${this.tableId}] FATAL: Could not find new dealer. Resetting table.`);
            this.reset();
            return;
        }

        this._initializeNewRoundState();
        this.state = "Dealing Pending";
        console.log(`[${this.tableId}] Round advanced. New dealer: ${this.players[this.dealer].playerName}. State: ${this.state}`);
        this._emitUpdate();
    }
    
    async _calculateRoundScores() {
        const roundData = gameLogic.calculateRoundScoreDetails(this);
        for(const playerName in roundData.pointChanges) { if(this.scores[playerName] !== undefined) { this.scores[playerName] += roundData.pointChanges[playerName]; } }
        let isGameOver = Object.values(this.scores).filter(s => typeof s === 'number').some(score => score <= 0);
        let gameWinnerName = null;
        let finalOutcomeMessage = roundData.roundMessage;
        if (isGameOver) {
            finalOutcomeMessage = "Game Over!";
            const gameOverResult = await gameLogic.handleGameOver(this, this.pool);
            gameWinnerName = gameOverResult.gameWinnerName;
            Object.values(this.players).forEach(p => { 
                if (!p.isBot) {
                    const playerSocket = this.io.sockets.sockets.get(p.socketId);
                    if (playerSocket) {
                        playerSocket.emit("requestUserSync"); 
                    }
                }
            });
        }
        await this._syncPlayerTokens(Object.keys(this.players));
        this.roundSummary = { message: finalOutcomeMessage, finalScores: { ...this.scores }, isGameOver, gameWinner: gameWinnerName, dealerOfRoundId: this.dealer, widowForReveal: roundData.widowForReveal, insuranceDealWasMade: this.insurance.dealExecuted, insuranceDetails: this.insurance.dealExecuted ? this.insurance.executedDetails : null, insuranceHindsight: roundData.insuranceHindsight, allTricks: this.capturedTricks, playerTokens: this.playerTokens };
        this.state = isGameOver ? "Game Over" : "Awaiting Next Round Trigger";
        this._emitUpdate();
    }

    _recalculateActivePlayerOrder() {
        const activePlayers = Object.values(this.players).filter(p => !p.isSpectator && !p.disconnected);
        if (activePlayers.length === 0) { this.playerOrderActive = []; return; }
        if (this.gameStarted && this.dealer) {
            const playerUserIds = activePlayers.map(p => p.userId);
            let dealerIndex = playerUserIds.indexOf(this.dealer);
            if (dealerIndex === -1) { this.dealer = playerUserIds[0]; dealerIndex = 0; }
            const orderedIds = [];
            for (let i = 1; i <= playerUserIds.length; i++) { 
                const playerId = playerUserIds[(dealerIndex + i) % playerUserIds.length]; 
                if (this.players[playerId]) {
                    orderedIds.push(playerId); 
                }
            }
            this.playerOrderActive = orderedIds;
        } else { this.playerOrderActive = activePlayers.map(p => p.userId).sort((a,b) => a - b); }
    }

    getStateForClient() {
        const state = {
            tableId: this.tableId, tableName: this.tableName, theme: this.theme, state: this.state, players: this.players,
            playerOrderActive: Object.values(this.players)
                .filter(p => this.playerOrderActive.includes(p.userId))
                .sort((a, b) => this.playerOrderActive.indexOf(a.userId) - this.playerOrderActive.indexOf(b.userId))
                .map(p => p.playerName), // Send names to client for UI
            dealer: this.dealer, hands: this.hands, widow: this.widow, originalDealtWidow: this.originalDealtWidow, scores: this.scores, currentHighestBidDetails: this.currentHighestBidDetails, bidWinnerInfo: this.bidWinnerInfo, gameStarted: this.gameStarted, trumpSuit: this.trumpSuit, currentTrickCards: this.currentTrickCards, tricksPlayedCount: this.tricksPlayedCount, leadSuitCurrentTrick: this.leadSuitCurrentTrick, trumpBroken: this.trumpBroken, capturedTricks: this.capturedTricks, roundSummary: this.roundSummary, lastCompletedTrick: this.lastCompletedTrick, playersWhoPassedThisRound: this.playersWhoPassedThisRound.map(id => this.players[id]?.playerName), playerMode: this.playerMode, serverVersion: this.serverVersion, insurance: this.insurance, forfeiture: this.forfeiture, playerTokens: this.playerTokens, drawRequest: this.drawRequest, originalFrogBidderId: this.originalFrogBidderId, soloBidMadeAfterFrog: this.soloBidMadeAfterFrog, revealedWidowForFrog: this.revealedWidowForFrog, widowDiscardsForFrogBidder: this.widowDiscardsForFrogBidder,
            bidderCardPoints: this.bidderCardPoints,
            defenderCardPoints: this.defenderCardPoints,
        };
        // Derive player names for client compatibility
        state.biddingTurnPlayerName = this.players[this.biddingTurnPlayerId]?.playerName;
        state.trickTurnPlayerName = this.players[this.trickTurnPlayerId]?.playerName;
        return state;
    }
    
    _emitUpdate() {
        this.io.to(this.tableId).emit('gameState', this.getStateForClient());
        this._triggerBots();
    }
    
    _triggerBots() {
        if (this.pendingBotAction) return;

        for (const botId in this.bots) {
            const bot = this.bots[botId];
            
            const isCourtney = bot.playerName === "Courtney Sr.";
            const standardDelay = 1000;
            const playDelay = 1200;
            const roundEndDelay = 8000;

            if (this.state === 'Dealing Pending' && this.dealer === bot.userId) {
                let delay = isCourtney ? standardDelay * 2 : standardDelay;
                this.pendingBotAction = setTimeout(() => {
                    this.pendingBotAction = null;
                    this.dealCards(bot.userId);
                }, delay);
                return;
            }

            if (this.state === 'Awaiting Next Round Trigger' && this.roundSummary?.dealerOfRoundId === bot.userId) {
                let delay = isCourtney ? roundEndDelay * 2 : roundEndDelay;
                this.pendingBotAction = setTimeout(() => {
                    this.pendingBotAction = null;
                    this.requestNextRound(bot.userId);
                }, delay);
                return;
            }

            if (this.state === 'Awaiting Frog Upgrade Decision' && this.biddingTurnPlayerId === bot.userId) {
                let delay = isCourtney ? standardDelay * 2 : standardDelay;
                this.pendingBotAction = setTimeout(() => { 
                    this.pendingBotAction = null; 
                    this.placeBid(bot.userId, "Pass"); 
                }, delay);
                return;
            }

            if (this.state === 'Bidding Phase' && this.biddingTurnPlayerId === bot.userId) {
                let delay = isCourtney ? standardDelay * 2 : standardDelay;
                this.pendingBotAction = setTimeout(() => { this.pendingBotAction = null; bot.makeBid(); }, delay);
                return;
            }

            if (this.state === 'Trump Selection' && this.bidWinnerInfo?.userId === bot.userId && !this.trumpSuit) {
                let delay = isCourtney ? standardDelay * 2 : standardDelay;
                this.pendingBotAction = setTimeout(() => { this.pendingBotAction = null; bot.chooseTrump(); }, delay);
                return;
            }

            if (this.state === 'Frog Widow Exchange' && this.bidWinnerInfo?.userId === bot.userId && this.widowDiscardsForFrogBidder.length === 0) {
                let delay = isCourtney ? standardDelay * 2 : standardDelay;
                this.pendingBotAction = setTimeout(() => { this.pendingBotAction = null; bot.submitFrogDiscards(); }, delay);
                return;
            }

            if (this.state === 'Playing Phase' && this.trickTurnPlayerId === bot.userId) {
                let delay = isCourtney ? playDelay * 2 : playDelay;
                this.pendingBotAction = setTimeout(() => { this.pendingBotAction = null; bot.playCard(); }, delay);
                return;
            }
        }
    }
    _clearAllTimers() { for (const timer in this.internalTimers) { clearTimeout(this.internalTimers[timer]); clearInterval(this.internalTimers[timer]); } this.internalTimers = {}; }
    
    _initializeNewRoundState() {
        this.hands = {}; this.widow = []; this.originalDealtWidow = [];
        this.biddingTurnPlayerId = null;
        this.currentHighestBidDetails = null;
        this.playersWhoPassedThisRound = [];
        this.bidWinnerInfo = null; this.trumpSuit = null; this.trumpBroken = false; this.originalFrogBidderId = null; this.soloBidMadeAfterFrog = false; this.revealedWidowForFrog = []; this.widowDiscardsForFrogBidder = [];
        this.trickTurnPlayerId = null;
        this.trickLeaderId = null;
        this.currentTrickCards = []; this.leadSuitCurrentTrick = null; this.lastCompletedTrick = null; this.tricksPlayedCount = 0; this.capturedTricks = {}; this.roundSummary = null; this.insurance = this._getInitialInsuranceState(); this.forfeiture = this._getInitialForfeitureState(); this.drawRequest = this._getInitialDrawRequestState();
        
        Object.values(this.players).forEach(p => {
            if (p.playerName && this.scores[p.playerName] !== undefined) {
                this.capturedTricks[p.playerName] = [];
            }
        });
        
        this.bidderCardPoints = 0;
        this.defenderCardPoints = 0;
    }

    async _syncPlayerTokens(playerIds) {
        if (!playerIds || playerIds.length === 0) { this.playerTokens = {}; return; }
        playerIds = playerIds.filter(id => parseInt(id,10) >= 0);
        if (playerIds.length === 0) { this.playerTokens = {}; return; }
        try {
            const tokenQuery = `SELECT user_id, SUM(amount) as tokens FROM transactions WHERE user_id = ANY($1::int[]) GROUP BY user_id;`;
            const tokenResult = await this.pool.query(tokenQuery, [playerIds]);
            const newPlayerTokens = {};
            const userIdToNameMap = Object.values(this.players).reduce((acc, player) => { acc[player.userId] = player.playerName; return acc; }, {});
            tokenResult.rows.forEach(row => { const playerName = userIdToNameMap[row.user_id]; if (playerName) { newPlayerTokens[playerName] = parseFloat(row.tokens || 0).toFixed(2); } });
            this.playerTokens = newPlayerTokens;
        } catch (err) { console.error(`Error fetching tokens during sync for table ${this.tableId}:`, err); }
    }
    _getInitialInsuranceState() { return { isActive: false, bidMultiplier: null, bidderPlayerName: null, bidderRequirement: 0, defenderOffers: {}, dealExecuted: false, executedDetails: null }; }
    _getInitialForfeitureState() { return { targetPlayerName: null, timeLeft: null }; }
    _getInitialDrawRequestState() { return { isActive: false, initiator: null, votes: {}, timer: null }; }
}

module.exports = Table;
--- END FILE: backend/src/core/Table.js ---

--- START FILE: backend/src/data/chatEndpoint.js ---
// Example Express endpoint for lobby chat
// This server file is illustrative only; the actual backend repository is not included.

const express = require('express');
const router = express.Router();

// Expected database table: lobby_chat_messages
// Fields: id SERIAL PRIMARY KEY, user_id INTEGER, username TEXT,
// message TEXT, created_at TIMESTAMP DEFAULT NOW()

// GET /api/chat - return chat history
router.get('/', async (req, res) => {
    // TODO: implement database fetch
    res.json([]);
});

// POST /api/chat - add a new message
router.post('/', async (req, res) => {
    const { message } = req.body;
    // TODO: insert message into database
    // Return the saved message with id, username, etc.
    res.json({ id: 0, username: req.user.username, message });
});

module.exports = router;
--- END FILE: backend/src/data/chatEndpoint.js ---

--- START FILE: backend/src/data/createTables.js ---
// backend/src/data/createTables.js
// This file creates the necessary database tables and types for the application

const createDbTables = async (pool) => {
    try {
        // This command creates the type if it doesn't exist at all.
        await pool.query(`
            DO $$ BEGIN
                CREATE TYPE transaction_type_enum AS ENUM (
                    'buy_in', 
                    'win_payout', 
                    'forfeit_loss', 
                    'forfeit_payout',
                    'admin_adjustment',
                    'free_token_mercy',
                    'wash_payout'
                );
            EXCEPTION
                WHEN duplicate_object THEN null;
            END $$;
        `);

        await pool.query(`
            DO $$ BEGIN
                CREATE TYPE user_role_enum AS ENUM ('player', 'admin');
            EXCEPTION
                WHEN duplicate_object THEN null;
            END $$;
        `);

        // NEW: Add a status type for feedback tracking
        await pool.query(`
            DO $$ BEGIN
                CREATE TYPE feedback_status_enum AS ENUM ('new', 'in_progress', 'resolved', 'wont_fix');
            EXCEPTION
                WHEN duplicate_object THEN null;
            END $$;
        `);

        await pool.query(`
            CREATE TABLE IF NOT EXISTS users (
                id SERIAL PRIMARY KEY,
                username VARCHAR(50) UNIQUE NOT NULL,
                email VARCHAR(255) UNIQUE NOT NULL,
                password_hash VARCHAR(255) NOT NULL,
                created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                wins INTEGER DEFAULT 0,
                losses INTEGER DEFAULT 0,
                washes INTEGER DEFAULT 0,
                is_admin BOOLEAN DEFAULT FALSE
            );
        `);

        await pool.query(`
            CREATE TABLE IF NOT EXISTS game_history (
                game_id SERIAL PRIMARY KEY,
                table_id VARCHAR(50),
                theme VARCHAR(50),
                player_count INTEGER,
                start_time TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                end_time TIMESTAMP WITH TIME ZONE,
                outcome TEXT
            );
        `);

        await pool.query(`
            CREATE TABLE IF NOT EXISTS transactions (
                transaction_id SERIAL PRIMARY KEY,
                user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
                game_id INTEGER REFERENCES game_history(game_id) ON DELETE SET NULL,
                transaction_type transaction_type_enum NOT NULL,
                amount DECIMAL(10, 2) NOT NULL,
                description TEXT,
                transaction_time TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
            );
        `);

        await pool.query(`
            CREATE TABLE IF NOT EXISTS feedback (
                feedback_id SERIAL PRIMARY KEY,
                user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
                username VARCHAR(50),
                submitted_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                feedback_text TEXT NOT NULL,
                table_id VARCHAR(50),
                game_state_json JSONB,
                status feedback_status_enum DEFAULT 'new'
            );
        `);

        // --- NEW: Create the lobby chat messages table ---
        await pool.query(`
            CREATE TABLE IF NOT EXISTS lobby_chat_messages (
                id SERIAL PRIMARY KEY,
                user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
                username VARCHAR(50),
                message TEXT NOT NULL,
                created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
            );
        `);


        console.log("âœ… Tables checked/created successfully.");
    } catch (err) {
        console.error("Error during table creation/modification:", err);
        throw err;
    }
};

module.exports = createDbTables;
--- END FILE: backend/src/data/createTables.js ---

--- START FILE: backend/src/data/README.md ---
# Lobby Chat Backend Endpoint

This folder contains an illustrative Express router for handling lobby chat messages. The actual backend implementation is not part of this repository.

## Database Table

Create a table called `lobby_chat_messages` with the following fields:

| Field      | Type      | Notes                       |
|------------|-----------|-----------------------------|
| `id`       | SERIAL    | Primary key                 |
| `user_id`  | INTEGER   | ID of the user sending text |
| `username` | TEXT      | Display name of sender      |
| `message`  | TEXT      | Chat content                |
| `created_at` | TIMESTAMP | Defaults to `NOW()`         |

## API Routes

- `GET /api/chat` â€“ Returns an array of recent chat messages.
- `POST /api/chat` â€“ Accepts `{ message }` and stores a new message. Returns the saved message object.

These endpoints are referenced by the front-end `LobbyChat` component.  
--- END FILE: backend/src/data/README.md ---

--- START FILE: backend/src/data/transactionManager.js ---
// backend/src/data/transactionManager.js

// --- PATH CORRECTION: The 'game' folder is now 'core' inside the 'src' directory ---
const { TABLE_COSTS } = require('../core/constants');

const createGameRecord = async (pool, table) => {
    const query = `
        INSERT INTO game_history (table_id, theme, player_count, outcome)
        VALUES ($1, $2, $3, $4)
        RETURNING game_id;
    `;
    const values = [table.tableId, table.theme, table.playerMode, 'In Progress'];
    try {
        const result = await pool.query(query, values);
        console.log(`[DB] Created game_id: ${result.rows[0].game_id} for table ${table.tableId}`);
        return result.rows[0].game_id;
    } catch (err) {
        console.error('Error creating game record in database:', err);
        throw err;
    }
};

const postTransaction = async (pool, { userId, gameId, type, amount, description }) => {
    const query = `
        INSERT INTO transactions (user_id, game_id, transaction_type, amount, description)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING *;
    `;
    const values = [userId, gameId, type, amount, description];
    try {
        const result = await pool.query(query, values);
        console.log(`[DB] Posted transaction_id: ${result.rows[0].transaction_id} for user_id: ${userId}, type: ${type}, amount: ${amount}`);
        return result.rows[0];
    } catch (err) {
        console.error(`Error posting transaction for user ${userId}:`, err);
        throw err;
    }
};

const updateGameRecordOutcome = async (pool, gameId, outcome) => {
    const query = `
        UPDATE game_history
        SET outcome = $1, end_time = NOW()
        WHERE game_id = $2;
    `;
    try {
        await pool.query(query, [outcome, gameId]);
        console.log(`[DB] Finalized game_id: ${gameId} with outcome: "${outcome}"`);
    } catch (err) {
        console.error(`Error updating game record outcome for game_id ${gameId}:`, err);
    }
};

const handleGameStartTransaction = async (pool, table, playerIds, gameId) => {
    // Look up the cost dynamically based on the table's theme, default to 1 if not found
    const cost = -(TABLE_COSTS[table.theme] || 1);
    const description = `Table buy-in for game #${gameId}`;

    const client = await pool.connect();
    try {
        await client.query('BEGIN');

        const balanceQuery = `
            SELECT user_id, SUM(amount) as current_tokens 
            FROM transactions 
            WHERE user_id = ANY($1::int[]) 
            GROUP BY user_id;
        `;
        const balanceResult = await client.query(balanceQuery, [playerIds]);
        
        const playerBalances = balanceResult.rows.reduce((acc, row) => {
            acc[row.user_id] = parseFloat(row.current_tokens);
            return acc;
        }, {});

        for (const userId of playerIds) {
            const balance = playerBalances[userId] || 0;
            if (balance < Math.abs(cost)) {
                const userRes = await client.query('SELECT username FROM users WHERE id = $1', [userId]);
                const username = userRes.rows[0]?.username || `Player ID ${userId}`;
                throw new Error(`${username} has insufficient tokens. Needs ${Math.abs(cost)}, but has ${balance.toFixed(2)}.`);
            }
        }

        const transactionPromises = playerIds.map(userId => {
            const insertQuery = `
                INSERT INTO transactions(user_id, game_id, transaction_type, amount, description) 
                VALUES($1, $2, 'buy_in', $3, $4);
            `;
            return client.query(insertQuery, [userId, gameId, cost, description]);
        });
        
        await Promise.all(transactionPromises);

        await client.query('COMMIT');
        console.log(`âœ… Game start buy-in transaction successful for game ${gameId}`);

    } catch (error) {
        await client.query('ROLLBACK');
        console.error("âŒ Game start transaction failed and was rolled back:", error.message);
        throw error; 
    } finally {
        client.release();
    }
};

const awardWinnings = async (pool, winnerId, potSize, gameId) => {
    if (!winnerId || potSize <= 0) {
        console.log("No winner or empty pot, skipping payout transaction.");
        return;
    }
    await postTransaction(pool, {
        userId: winnerId,
        gameId: gameId,
        type: 'win_payout',
        amount: potSize,
        description: `Winnings for game #${gameId}`
    });
    console.log(`âœ… Payout of ${potSize} tokens successful for user ${winnerId} in game ${gameId}`);
};

module.exports = {
    createGameRecord,
    postTransaction,
    updateGameRecordOutcome,
    handleGameStartTransaction,
    awardWinnings
};
--- END FILE: backend/src/data/transactionManager.js ---

--- START FILE: backend/src/db/transactionManager.js ---
// backend/db/transactionManager.js

// --- MODIFICATION: Import TABLE_COSTS to look up buy-in amounts ---
const { TABLE_COSTS } = require('../core/constants');

const createGameRecord = async (pool, table) => {
    const query = `
        INSERT INTO game_history (table_id, theme, player_count, outcome)
        VALUES ($1, $2, $3, $4)
        RETURNING game_id;
    `;
    const values = [table.tableId, table.theme, table.playerMode, 'In Progress'];
    try {
        const result = await pool.query(query, values);
        console.log(`[DB] Created game_id: ${result.rows[0].game_id} for table ${table.tableId}`);
        return result.rows[0].game_id;
    } catch (err) {
        console.error('Error creating game record in database:', err);
        throw err;
    }
};

const postTransaction = async (pool, { userId, gameId, type, amount, description }) => {
    const query = `
        INSERT INTO transactions (user_id, game_id, transaction_type, amount, description)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING *;
    `;
    const values = [userId, gameId, type, amount, description];
    try {
        const result = await pool.query(query, values);
        console.log(`[DB] Posted transaction_id: ${result.rows[0].transaction_id} for user_id: ${userId}, type: ${type}, amount: ${amount}`);
        return result.rows[0];
    } catch (err) {
        console.error(`Error posting transaction for user ${userId}:`, err);
        throw err;
    }
};

const updateGameRecordOutcome = async (pool, gameId, outcome) => {
    const query = `
        UPDATE game_history
        SET outcome = $1, end_time = NOW()
        WHERE game_id = $2;
    `;
    try {
        await pool.query(query, [outcome, gameId]);
        console.log(`[DB] Finalized game_id: ${gameId} with outcome: "${outcome}"`);
    } catch (err) {
        console.error(`Error updating game record outcome for game_id ${gameId}:`, err);
    }
};

// --- MODIFICATION: Updated function to accept the 'table' object and use its theme ---
const handleGameStartTransaction = async (pool, table, playerIds, gameId) => {
    // Look up the cost dynamically based on the table's theme, default to 1 if not found
    const cost = -(TABLE_COSTS[table.theme] || 1);
    const description = `Table buy-in for game #${gameId}`;

    const client = await pool.connect();
    try {
        await client.query('BEGIN');

        const balanceQuery = `
            SELECT user_id, SUM(amount) as current_tokens 
            FROM transactions 
            WHERE user_id = ANY($1::int[]) 
            GROUP BY user_id;
        `;
        const balanceResult = await client.query(balanceQuery, [playerIds]);
        
        const playerBalances = balanceResult.rows.reduce((acc, row) => {
            acc[row.user_id] = parseFloat(row.current_tokens);
            return acc;
        }, {});

        for (const userId of playerIds) {
            const balance = playerBalances[userId] || 0;
            if (balance < Math.abs(cost)) {
                const userRes = await client.query('SELECT username FROM users WHERE id = $1', [userId]);
                const username = userRes.rows[0]?.username || `Player ID ${userId}`;
                throw new Error(`${username} has insufficient tokens. Needs ${Math.abs(cost)}, but has ${balance.toFixed(2)}.`);
            }
        }

        const transactionPromises = playerIds.map(userId => {
            const insertQuery = `
                INSERT INTO transactions(user_id, game_id, transaction_type, amount, description) 
                VALUES($1, $2, 'buy_in', $3, $4);
            `;
            return client.query(insertQuery, [userId, gameId, cost, description]);
        });
        
        await Promise.all(transactionPromises);

        await client.query('COMMIT');
        console.log(`âœ… Game start buy-in transaction successful for game ${gameId}`);

    } catch (error) {
        await client.query('ROLLBACK');
        console.error("âŒ Game start transaction failed and was rolled back:", error.message);
        throw error; 
    } finally {
        client.release();
    }
};

const awardWinnings = async (pool, winnerId, potSize, gameId) => {
    if (!winnerId || potSize <= 0) {
        console.log("No winner or empty pot, skipping payout transaction.");
        return;
    }
    await postTransaction(pool, {
        userId: winnerId,
        gameId: gameId,
        type: 'win_payout',
        amount: potSize,
        description: `Winnings for game #${gameId}`
    });
    console.log(`âœ… Payout of ${potSize} tokens successful for user ${winnerId} in game ${gameId}`);
};

module.exports = {
    createGameRecord,
    postTransaction,
    updateGameRecordOutcome,
    handleGameStartTransaction,
    awardWinnings
};
--- END FILE: backend/src/db/transactionManager.js ---

--- START FILE: backend/tests/api.test.js ---
const assert = require('assert');
const { Pool } = require('pg');
require('dotenv').config(); // To load the DATABASE_URL from your .env file

// User credentials for the test
const TEST_USER_EMAIL = 'matthewgmcmillan@icloud.com';
const TEST_USER_PASSWORD = 'Ew**2012';
const SERVER_URL = 'https://sluff-backend.onrender.com';

// Setup database connection
const pool = new Pool({
    connectionString: process.env.DATABASE_URL,
    ssl: { rejectUnauthorized: false }
});

async function testChatHistoryIsMostRecent() {
    console.log('Running Test: API should return the most recent chat messages...');
    
    // Step 1: Login to get a JWT token
    let token;
    try {
        const loginRes = await fetch(`${SERVER_URL}/api/auth/login`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: TEST_USER_EMAIL, password: TEST_USER_PASSWORD }),
        });
        const loginData = await loginRes.json();
        token = loginData.token;
    } catch (error) {
        throw new Error('Could not log in test user. Ensure the server is running and the user exists.');
    }

    // Step 2: Fetch chat history from the API
    let apiChatData;
    try {
        const chatRes = await fetch(`${SERVER_URL}/api/chat`, {
            headers: { 'Authorization': `Bearer ${token}` },
        });
        apiChatData = await chatRes.json();
    } catch (error) {
        throw new Error('Could not fetch chat history from the API.');
    }

    // Step 3: Fetch the ground truth directly from the database
    let dbChatData;
    try {
        const dbQuery = `
            SELECT id, username, message 
            FROM lobby_chat_messages 
            ORDER BY created_at DESC 
            LIMIT 50;
        `;
        const { rows } = await pool.query(dbQuery);
        dbChatData = rows.reverse(); // Reverse to get chronological order (oldest to newest)
    } catch (error) {
        throw new Error('Could not query the database directly for chat messages.');
    }
    
    // Step 4: The Assertion and Detailed Failure Report
    try {
        // We will compare the arrays of message IDs to ensure they are identical in content and order.
        const apiMessageIds = apiChatData.map(msg => msg.id);
        const dbMessageIds = dbChatData.map(msg => msg.id);

        assert.deepStrictEqual(apiMessageIds, dbMessageIds, 'The message history from the API does not match the database.');

    } catch (error) {
        // This block runs ONLY if the assertion fails.
        console.error('\n--- TEST FAILED ---');
        console.error('Reason:', error.message);
        
        // Helper function to format the message list for easy reading
        const formatMessages = (messages) => {
            return messages.slice(-10).map(m => `  ID ${m.id}: "${m.message}"`).join('\n');
        };

        console.log('\nLast 10 Messages Returned by API (Oldest First):');
        console.log(formatMessages(apiChatData));
        
        console.log('\nLast 10 Messages Expected from Database (Newest First, then reversed):');
        console.log(formatMessages(dbChatData));

        // Re-throw the error so the test process exits with a failure code.
        throw error;
    }
}

async function run() {
    try {
        await testChatHistoryIsMostRecent();
        console.log('\n\u2713 All API tests passed! The chat history bug has been fixed.');
    } catch (error) {
        // The detailed error is already printed inside the test function.
        // We just need to ensure the script exits correctly.
        process.exit(1);
    } finally {
        await pool.end();
    }
}

run();
--- END FILE: backend/tests/api.test.js ---

--- START FILE: backend/tests/auth.test.js ---
const assert = require('assert');
const fetch = require('node-fetch'); // --- ADD THIS LINE ---

const SERVER_URL = 'http://localhost:3000';

async function runAuthTests() {
    console.log('Running auth.js API tests...');

    const uniqueUser = `testuser_${Date.now()}`;
    const uniqueEmail = `${uniqueUser}@test.com`;
    const password = 'password123';

    // Test 1: Successful Registration
    let res = await fetch(`${SERVER_URL}/api/auth/register`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username: uniqueUser, email: uniqueEmail, password }),
    });
    assert.strictEqual(res.status, 201, 'Test 1 Failed: Successful registration should return 201.');
    console.log('  \u2713 Test 1 Passed: Successful registration.');

    // Test 2: Attempt to register with the same username
    res = await fetch(`${SERVER_URL}/api/auth/register`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username: uniqueUser, email: `another_${uniqueEmail}`, password }),
    });
    assert.strictEqual(res.status, 500, 'Test 2 Failed: Duplicate username registration should return 500.');
    console.log('  \u2713 Test 2 Passed: Duplicate username correctly rejected.');
    
    // Test 3: Attempt to register with the same email
    res = await fetch(`${SERVER_URL}/api/auth/register`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username: `another_${uniqueUser}`, email: uniqueEmail, password }),
    });
    assert.strictEqual(res.status, 500, 'Test 3 Failed: Duplicate email registration should return 500.');
    console.log('  \u2713 Test 3 Passed: Duplicate email correctly rejected.');

    console.log('  \u2713 All auth.js tests passed!');
}

runAuthTests().catch(err => {
    console.error('Auth test suite failed:', err.message);
    process.exit(1);
});
--- END FILE: backend/tests/auth.test.js ---

--- START FILE: backend/tests/bot.test.js ---
const assert = require('assert');
const BotPlayer = require('../game/BotPlayer');

// Mock the table object the bot needs to interact with
class MockTable {
    constructor(hand) {
        this.hands = { 'TestBot': hand };
        this.currentHighestBidDetails = null; // Start with no bids
    }
    // Mock the placeBid function to just record the bid
    placeBid(userId, bid) {
        this.lastBid = bid;
    }
}

function runBotTests() {
    console.log('Running BotPlayer.js tests...');
    let testCounter = 1;
    const pass = (testName) => console.log(`  \u2713 Test ${testCounter++}: ${testName}`);

    // Test: Bot should bid Heart Solo
    let hand1 = ['AH', 'KH', 'QH', 'JH', '10H', 'AS', 'KS', 'QS', 'JS', '10S', '6C']; // High points, 5 hearts
    let mockTable1 = new MockTable(hand1);
    let bot1 = new BotPlayer(-1, 'TestBot', mockTable1);
    bot1.makeBid();
    assert.strictEqual(mockTable1.lastBid, 'Heart Solo');
    pass('Correctly bids Heart Solo.');

    // Test: Bot should bid Solo
    let hand2 = ['AC', 'KC', 'QC', 'JC', '10C', 'AD', 'KD', 'QD', 'JD', '10D', '6H']; // High points, 5 clubs
    let mockTable2 = new MockTable(hand2);
    let bot2 = new BotPlayer(-1, 'TestBot', mockTable2);
    bot2.makeBid();
    assert.strictEqual(mockTable2.lastBid, 'Solo');
    pass('Correctly bids Solo.');
    
    // Test: Bot should bid Frog
    // --- FIX: Constructed a hand that is unambiguously a Frog bid. ---
    // Has 4 hearts and 31 points. Does not meet the criteria for Solo or Heart Solo.
    let hand3 = ['AH', 'KH', 'QH', 'JH', 'AC', '6D', '7D', '8C', '9C', '6S', '7S'];
    let mockTable3 = new MockTable(hand3);
    let bot3 = new BotPlayer(-1, 'TestBot', mockTable3);
    bot3.makeBid();
    assert.strictEqual(mockTable3.lastBid, 'Frog');
    pass('Correctly bids Frog.');
    
    // Test: Bot should Pass
    let hand4 = ['6H', '7H', '8H', '9H', '6D', '7D', '8D', '9D', '6C', '7C', '8C']; // 0 points
    let mockTable4 = new MockTable(hand4);
    let bot4 = new BotPlayer(-1, 'TestBot', mockTable4);
    bot4.makeBid();
    assert.strictEqual(mockTable4.lastBid, 'Pass');
    pass('Correctly passes with a weak hand.');

    console.log('  \u2713 All BotPlayer.js tests passed!');
}

runBotTests();
--- END FILE: backend/tests/bot.test.js ---

--- START FILE: backend/tests/gameLogic.unit.test.js ---
const assert = require('assert');
const gameLogic = require('../game/logic');

function runGameLogicTests() {
    console.log('Running gameLogic.js tests...');

    let testCounter = 1;
    const pass = (testName) => console.log(`  \u2713 Test ${testCounter++}: ${testName}`);

    // --- Trick Winner Tests ---
    const playsTrump = [ { userId: 1, playerName: 'Alice', card: '10H' }, { userId: 2, playerName: 'Bob', card: 'AS' }, { userId: 3, playerName: 'Carol', card: 'KH' }];
    let result = gameLogic.determineTrickWinner(playsTrump, 'H', 'S');
    assert.strictEqual(result.playerName, 'Bob');
    pass('Trump should win trick.');

    const followsSuit = [ { userId: 1, playerName: 'Alice', card: '10H' }, { userId: 2, playerName: 'Bob', card: 'AH' }, { userId: 3, playerName: 'Carol', card: 'KH' }];
    result = gameLogic.determineTrickWinner(followsSuit, 'H', 'S');
    assert.strictEqual(result.playerName, 'Bob');
    pass('Highest of lead suit should win.');

    // --- Payout Tests ---
    // --- FIX: Restored the full players object needed by the function ---
    const forfeitTable = {
        theme: 'fort-creek',
        players: {
            1: { userId: 1, playerName: 'Alice', isSpectator: false },
            2: { userId: 2, playerName: 'Bob', isSpectator: false },
            3: { userId: 3, playerName: 'Carol', isSpectator: false },
        },
        scores: { 'Alice': 120, 'Bob': 80, 'Carol': 100 }
    };
    let payout = gameLogic.calculateForfeitPayout(forfeitTable, 'Bob');
    assert.strictEqual(payout['Alice'].totalGain.toFixed(3), '1.545');
    pass('Forfeit payout for Alice is correct.');
    assert.strictEqual(payout['Carol'].totalGain.toFixed(3), '1.455');
    pass('Forfeit payout for Carol is correct.');

    // --- FIX: Restored the full players object needed by the function ---
    const drawTable = {
        theme: 'fort-creek',
        players: {
            1: { userId: 1, playerName: 'Alice', isSpectator: false },
            2: { userId: 2, playerName: 'Bob', isSpectator: false },
            3: { userId: 3, playerName: 'Carol', isSpectator: false },
        },
        scores: { 'Alice': 90, 'Bob': 80, 'Carol': 60 }
    };
    let drawResult = gameLogic.calculateDrawSplitPayout(drawTable);
    assert.strictEqual(drawResult.wash, false);
    pass('Draw should be a split, not a wash.');
    assert.ok(Math.abs(drawResult.payouts['Carol'].totalReturn - 0.5) < 0.0001);
    pass('Draw split payout for lowest player is correct.');
    
    // --- Scoring Tests ---
    const mockScoringTable = {
        playerOrderActive: [1, 2, 3], playerMode: 3, players: { 1: { playerName: 'Alice' }, 2: { playerName: 'Bob' }, 3: { playerName: 'Carol' } },
        insurance: { dealExecuted: false, defenderOffers: {} }, capturedTricks: {}, originalDealtWidow: []
    };
    
    let succeedResult = gameLogic.calculateRoundScoreDetails({ ...mockScoringTable, bidWinnerInfo: { playerName: 'Alice', bid: 'Solo' }, bidderTotalCardPoints: 70 });
    assert.strictEqual(succeedResult.pointChanges['Alice'], 40);
    pass('Bidder success points correct.');
    assert.strictEqual(succeedResult.pointChanges['Bob'], -20);
    pass('Defender loss points correct.');

    let failResult3Player = gameLogic.calculateRoundScoreDetails({ ...mockScoringTable, bidWinnerInfo: { playerName: 'Alice', bid: 'Solo' }, bidderTotalCardPoints: 50 });
    assert.strictEqual(failResult3Player.pointChanges['Alice'], -60);
    pass('3-player bidder fail points correct.');
    assert.strictEqual(failResult3Player.pointChanges['Bob'], 20);
    pass('3-player defender win points correct.');
    assert.strictEqual(failResult3Player.pointChanges['ScoreAbsorber'], 20);
    pass('3-player ScoreAbsorber points correct.');
    
    // --- NEW: Widow Point Allocation Tests ---
    const widowPts = 15;
    const mockWidow = ['AC', 'KC']; // 15 pts, but not used directly in calculation for this test
    const mockDiscards = ['AD', 'KD']; // 15 pts

    // For these tests, we assume trick points are 50, and widow/discards add the rest.
    const baseTrickPoints = 50;
    
    // Scenario: Heart Solo, widow goes to bidder (This scenario is simplified as last trick winner is not part of this function)
    const hsWinTable = { ...mockScoringTable, bidWinnerInfo: { playerName: 'Alice', bid: 'Heart Solo' }, originalDealtWidow: mockWidow, bidderTotalCardPoints: baseTrickPoints + widowPts };
    let hsWinResult = gameLogic.calculateRoundScoreDetails(hsWinTable);
    assert.strictEqual(hsWinResult.finalBidderPoints, 65, 'HS Win: Bidder points incorrect.');
    assert.strictEqual(hsWinResult.finalDefenderPoints, 55, 'HS Win: Defender points incorrect.');
    pass('Heart Solo: Widow points are correctly assigned.');
    
    // Scenario: Solo bid -> widow always goes to bidder
    const soloTable = { ...mockScoringTable, bidWinnerInfo: { playerName: 'Alice', bid: 'Solo' }, originalDealtWidow: mockWidow, bidderTotalCardPoints: baseTrickPoints + widowPts };
    let soloResult = gameLogic.calculateRoundScoreDetails(soloTable);
    assert.strictEqual(soloResult.finalBidderPoints, 65, 'Solo: Bidder points incorrect.');
    assert.strictEqual(soloResult.finalDefenderPoints, 55, 'Solo: Defender points incorrect.');
    pass('Solo Bid: Widow points go to bidder.');

    // Scenario: Frog bid -> bidder gets points from their discards
    const frogTable = { ...mockScoringTable, bidWinnerInfo: { playerName: 'Alice', bid: 'Frog' }, widowDiscardsForFrogBidder: mockDiscards, bidderTotalCardPoints: baseTrickPoints + widowPts };
    let frogResult = gameLogic.calculateRoundScoreDetails(frogTable);
    assert.strictEqual(frogResult.finalBidderPoints, 65, 'Frog: Bidder points incorrect.');
    assert.strictEqual(frogResult.finalDefenderPoints, 55, 'Frog: Defender points incorrect.');
    pass('Frog Bid: Bidder gets points from their discarded cards.');


    console.log('\n  \u2713 All gameLogic.js tests passed!');
}

runGameLogicTests();
--- END FILE: backend/tests/gameLogic.unit.test.js ---

--- START FILE: backend/tests/legalMoves.test.js ---
const assert = require('assert');
const { getLegalMoves } = require('../game/legalMoves');

function runLegalMovesTests() {
    console.log('Running legalMoves.js tests...');
    let testCounter = 1;
    const pass = (testName) => console.log(`  \u2713 Test ${testCounter++}: ${testName}`);

    // Scenario 1: Must Follow Suit
    let hand = ['7D', '8D', '9S', '10C'];
    let legal = getLegalMoves(hand, false, 'D', 'H', true);
    assert.deepStrictEqual(legal.sort(), ['7D', '8D'].sort());
    pass('Must follow suit.');

    // Scenario 2: Cannot Follow, Must Play Trump
    hand = ['7S', '8C', '9S', 'JH'];
    legal = getLegalMoves(hand, false, 'D', 'H', true);
    assert.deepStrictEqual(legal, ['JH']);
    pass('Must play trump.');

    // Scenario 3: Cannot Follow or Trump, Can Sluff Anything
    hand = ['7S', '8C', '9S', 'JC'];
    legal = getLegalMoves(hand, false, 'D', 'H', true);
    assert.deepStrictEqual(legal.sort(), hand.sort());
    pass('Can sluff any card.');

    // Scenario 4: Leading, Trump Not Broken, Has Other Suits
    hand = ['7D', '8H', '9S'];
    legal = getLegalMoves(hand, true, null, 'H', false);
    assert.deepStrictEqual(legal.sort(), ['7D', '9S'].sort());
    pass('Cannot lead trump if not broken.');

    // Scenario 5: Leading, Trump Not Broken, Only Has Trump
    hand = ['7H', '8H', '9H'];
    legal = getLegalMoves(hand, true, null, 'H', false);
    assert.deepStrictEqual(legal.sort(), hand.sort());
    pass('Can lead trump if it is the only suit.');

    // Scenario 6: Leading, Trump Is Broken
    hand = ['7D', '8H', '9S'];
    legal = getLegalMoves(hand, true, null, 'H', true);
    assert.deepStrictEqual(legal.sort(), hand.sort());
    pass('Can lead any card once trump is broken.');

    console.log('  \u2713 All legalMoves.js tests passed!');
}

runLegalMovesTests();
--- END FILE: backend/tests/legalMoves.test.js ---

--- START FILE: backend/tests/lifecycle.test.js ---
const assert = require('assert');
const fetch = require('node-fetch');
const io = require('socket.io-client');
require('dotenv').config();

const SERVER_URL = 'http://localhost:3000';
const TEST_USER_EMAIL = 'matthewgmcmillan@icloud.com';
const TEST_USER_PASSWORD = 'Ew**2012';

// Helper function to create a delay
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function runLifecycleTests() {
    console.log('Running lifecycle.js tests...');
    let testCounter = 1;
    const pass = (testName) => console.log(`  \u2713 Test ${testCounter++}: ${testName}`);
    
    let token;
    let user;
    let socket;

    // --- Login and Socket Connection ---
    try {
        const loginRes = await fetch(`${SERVER_URL}/api/auth/login`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: TEST_USER_EMAIL, password: TEST_USER_PASSWORD }),
        });
        const loginData = await loginRes.json();
        token = loginData.token;
        user = loginData.user;
        assert.ok(token, 'Setup Failed: Could not log in.');
    } catch (e) {
        console.error('Setup Failed: Login failed.', e.message);
        process.exit(1);
    }
    
    // --- Test 1: Login triggers a chat message ---
    console.log('  Running Test 1: Login Chat Announcement...');
    try {
        const chatPromise = new Promise((resolve, reject) => {
            socket = io(SERVER_URL, { auth: { token }, transports: ['websocket'] });
            socket.on('new_lobby_message', (msg) => {
                if (msg.message.includes(`${user.username} has logged on`)) {
                    resolve(msg);
                }
            });
            setTimeout(() => reject(new Error('Test timed out. No login message received.')), 3000);
        });
        
        await chatPromise;
        pass('Login triggers a system chat message.');
        
    } catch (error) {
        // We expect this to fail right now.
        assert.fail('Test 1 FAILED (as expected): Login did not trigger a chat message.');
    }

    // --- Test 2: Logout triggers a chat message ---
    console.log('  Running Test 2: Logout Chat Announcement...');
    try {
        const logoutPromise = new Promise((resolve, reject) => {
            socket.on('new_lobby_message', (msg) => {
                 if (msg.message.includes(`${user.username} has logged out`)) {
                    resolve(msg);
                }
            });
            // Disconnecting the socket should trigger the logout message
            socket.disconnect();
            setTimeout(() => reject(new Error('Test timed out. No logout message received.')), 3000);
        });

        await logoutPromise;
        pass('Logout triggers a system chat message.');

    } catch (error) {
         // We expect this to fail right now.
        assert.fail('Test 2 FAILED (as expected): Logout did not trigger a chat message.');
    } finally {
        if(socket && socket.connected) socket.disconnect();
    }


    // --- Tests for inactivity timeouts are difficult to automate in a short script ---
    // --- They are better suited for manual testing or longer-running E2E test suites. ---
    // --- We will skip them for now to focus on what we can reliably test here. ---

    console.log('\n  Lifecycle tests complete. Failures are expected until features are implemented.');
}


runLifecycleTests().catch(err => {
    // This block catches the assertion failures and allows the script to finish gracefully.
    console.error(`\nTest Suite Failed: ${err.message}`);
    process.exit(1);
});
--- END FILE: backend/tests/lifecycle.test.js ---

--- START FILE: backend/tests/Table.integration.test.js ---
const assert = require('assert');
const Table = require('../src/core/Table');

// --- Mocks and Helpers ---

// A mock socket.io server object to capture emissions
const mockIo = {
    lastEmit: null,
    to: function(tableId) {
        return {
            emit: (event, data) => {
                this.lastEmit = { event, data };
                // console.log(`Mock IO emitted to ${tableId}: ${event}`);
            }
        };
    }
};

// A helper to pause execution, allowing async bot actions to complete
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// --- The Test Case ---

async function testFrogUpgradeScenario() {
    console.log("Running: testFrogUpgradeScenario...");

    // 1. ARRANGE: Set up the game state
    const table = new Table('test-table-1', 'fort-creek', 'Test Table', mockIo, null, () => {});
    
    // Add players: one bot, one human
    table.addBotPlayer(); // Bot gets ID -1, Name "Mike Knight"
    await table.joinTable({ id: 101, username: "HumanPlayer" }, "socket123");
    
    // Ensure we have exactly two players for this test
    assert.strictEqual(Object.keys(table.players).length, 2, "Should have 2 players");
    
    // Start the game. Since it's random, we find out who the dealer is.
    await table.startGame(101); // Human starts the game
    table.dealCards(table.dealer);

    // Identify who is who in the turn order
    const botId = table.playerOrderActive.find(id => id < 0);
    const humanId = table.playerOrderActive.find(id => id > 0);
    const botPlayer = table.players[botId];
    const humanPlayer = table.players[humanId];

    // Make sure the bidding starts with the first player in order
    assert.strictEqual(table.state, "Bidding Phase", "Game should be in Bidding Phase");
    const firstBidderId = table.biddingTurnPlayerId;
    const secondBidderId = table.playerOrderActive.find(id => id !== firstBidderId);

    // 2. ACT: Perform the sequence of bids that causes the bug
    console.log(`  - ${table.players[firstBidderId].playerName} bids Frog...`);
    table.placeBid(firstBidderId, "Frog"); // First player bids Frog

    console.log(`  - ${table.players[secondBidderId].playerName} bids Solo...`);
    table.placeBid(secondBidderId, "Solo"); // Second player bids Solo
    
    // The game state should now be waiting for the original Frog bidder
    assert.strictEqual(table.state, "Awaiting Frog Upgrade Decision", "State should be Awaiting Frog Upgrade Decision");
    assert.strictEqual(table.biddingTurnPlayerId, firstBidderId, "Turn should return to the original Frog bidder");

    console.log(`  - Waiting for ${botPlayer.playerName} to automatically pass...`);
    await sleep(1200); // Wait for the bot's timeout to fire

    // 3. ASSERT: Check the final state
    assert.strictEqual(table.state, "Trump Selection", "Game should have proceeded to Trump Selection");
    assert.strictEqual(table.bidWinnerInfo.userId, secondBidderId, "The Solo bidder should be the winner");
    assert.strictEqual(table.bidWinnerInfo.bid, "Solo", "The winning bid should be Solo");
    
    console.log("...Success!\n");
}


// --- Test Runner ---
async function runAllTests() {
    try {
        await testFrogUpgradeScenario();
        console.log("âœ… All Table integration tests passed!");
    } catch (error) {
        console.error("âŒ A test failed:", error);
        process.exit(1); // Exit with an error code
    }
}

runAllTests();
--- END FILE: backend/tests/Table.integration.test.js ---

--- START FILE: backend/utils/shuffle.js ---
// Backend/utils/shuffle.js

/**
 * Shuffles an array in place using the Fisher-Yates (aka Knuth) Shuffle.
 * @param {Array} array The array to shuffle.
 * @returns {Array} The shuffled array.
 */
const shuffle = (array) => {
    let currentIndex = array.length, randomIndex;
    // While there remain elements to shuffle.
    while (currentIndex !== 0) {
        // Pick a remaining element.
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        // And swap it with the current element.
        [array[currentIndex], array[randomIndex]] = [
            array[randomIndex], array[currentIndex]];
    }
    return array;
};

module.exports = { shuffle };
--- END FILE: backend/utils/shuffle.js ---

--- START FILE: frontend/.env ---
CI=false
--- END FILE: frontend/.env ---

--- START FILE: frontend/.gitignore ---
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*
--- END FILE: frontend/.gitignore ---

--- START FILE: frontend/package.json ---
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.2.0",
    "@testing-library/user-event": "^13.5.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-router-dom": "^7.6.3",
    "react-scripts": "5.0.1",
    "socket.io-client": "^4.8.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

--- END FILE: frontend/package.json ---

--- START FILE: frontend/README.md ---
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)

--- END FILE: frontend/README.md ---

--- START FILE: frontend/src/App.css ---
/* App.css - Styles for the Sluff Card Game */
body {
  font-family: Arial, sans-serif;
  text-align: center;
  background-color: #f4f4f4;
  padding: 20px;
}

h1 {
  color: #333;
}

button {
  padding: 10px 15px;
  margin: 5px;
  border: none;
  background-color: #007bff;
  color: white;
  font-size: 16px;
  cursor: pointer;
  border-radius: 5px;
}

button:hover {
  background-color: #0056b3;
}

h2 {
  margin-top: 20px;
}

input {
  padding: 8px;
  font-size: 16px;
  margin-right: 10px;
}

ul {
  list-style-type: none;
  padding: 0;
}

li {
  font-size: 18px;
  margin: 5px 0;
}

--- END FILE: frontend/src/App.css ---

--- START FILE: frontend/src/App.js ---
// frontend/src/App.js
import React, { useState, useEffect, useCallback } from "react";
import io from "socket.io-client";
import Login from "./components/Login.js";
import Register from "./components/Register.js";
import LobbyView from "./components/LobbyView.js";
import GameTableView from "./components/GameTableView.js";
import LeaderboardView from "./components/LeaderboardView.js";
import MercyWindow from "./components/MercyWindow.js";
import AdminView from "./components/AdminView.js";
import "./components/AdminView.css";
import { useSounds } from "./hooks/useSounds.js";

const SERVER_URL = "https://sluff-backend.onrender.com";
const socket = io(SERVER_URL, {
    autoConnect: false,
    reconnectionAttempts: 5,
    transports: ['websocket', 'polling']
});

function App() {
    const [view, setView] = useState('login');
    const [token, setToken] = useState(localStorage.getItem("sluff_token"));
    const [user, setUser] = useState(null);
    const [lobbyThemes, setLobbyThemes] = useState([]);
    const [currentTableState, setCurrentTableState] = useState(null);
    const [errorMessage, setErrorMessage] = useState('');
    const [serverVersion, setServerVersion] = useState('');
    const [showMercyWindow, setShowMercyWindow] = useState(false);
    const { playSound, enableSound } = useSounds();

    const handleLogout = useCallback(() => {
        localStorage.removeItem("sluff_token");
        setToken(null);
        setUser(null);
        setView('login');
        if (socket.connected) {
            socket.disconnect();
        }
    }, []);

    const handleHardReset = () => {
        const confirmReset = window.confirm(
            "SERVER RESET WARNING:\n\nThis will boot ALL players from ALL tables, reset ALL in-progress games, and force everyone to log in again. This action cannot be undone.\n\nAre you sure you want to proceed?"
        );
        if (confirmReset) {
            const question = "?What is Matthew's childhood Nickname and ranch phone number? Enter this format Nickname_XXXXXXXXXX";
            const secret = prompt(question);
            if (secret) {
                socket.emit("hardResetServer", { secret });
            }
        }
    };

    const handleResetAllTokens = () => {
        const confirmReset = window.confirm(
            "TOKEN RESET WARNING:\n\nThis will reset the token balance for ALL players on the server to the default amount (8). This is useful for starting a new season or testing period.\n\nAre you sure you want to proceed?"
        );
        if (confirmReset) {
            const question = "Childhood Friend, Make of first car last 4 SSN Mom's maiden name\n\nFormat = Friend_Make_XXXX_Maiden";
            const secret = prompt(question);
            if (secret) {
                socket.emit("resetAllTokens", { secret });
            }
        }
    };

    const handleRequestFreeToken = () => {
        if (user && parseFloat(user.tokens) >= 5) {
            alert("Sorry, free tokens are only available for players with fewer than 5 tokens.");
        } else {
            setShowMercyWindow(true);
        }
    };

    const handleShowAdmin = () => {
        setView('admin');
    };

    const handleReturnToLobby = () => {
        setView('lobby');
        socket.emit("requestUserSync");
    };

    useEffect(() => {
        if (token && !user) {
            try {
                const payload = JSON.parse(atob(token.split('.')[1]));
                setUser({ id: payload.id, username: payload.username, tokens: 0, is_admin: payload.is_admin || false });
                setView('lobby');
            }
            catch (e) {
                console.error("Invalid token found, logging out:", e);
                handleLogout();
            }
        }
    }, [token, user, handleLogout]);

    useEffect(() => {
        if (token) {
            socket.auth = { token };
            socket.connect();

            const onConnect = () => {
                console.log("Socket connected!");
                socket.emit("requestUserSync");
            };

            const onUpdateUser = (updatedUser) => {
                setUser(updatedUser);
            };

            const onLobbyState = (newLobbyState) => {
                if (newLobbyState && newLobbyState.themes) {
                    setLobbyThemes(newLobbyState.themes);
                    setServerVersion(newLobbyState.serverVersion || 'N/A');
                }
            };

            const onGameState = (newTableState) => {
                const currentUserId = JSON.parse(atob(token.split('.')[1])).id;
                const playerAtTable = newTableState.players[currentUserId];

                if (!playerAtTable) {
                    setView('lobby');
                    setCurrentTableState(null);
                } else {
                    setCurrentTableState(newTableState);
                }
            };

            const onJoinedTable = ({ gameState }) => {
                setCurrentTableState(gameState);
                setView('gameTable');
            };

            const onError = (error) => {
                const msg = error.message || error;
                setErrorMessage(msg);
                setTimeout(() => setErrorMessage(''), 5000);
            };

            const onConnectError = (err) => {
                console.error("Connection Error:", err.message);
                if (err.message.includes("Authentication error")) {
                    handleLogout();
                }
            };

            const onForceReset = (message) => {
                alert(message);
                handleLogout();
                window.location.reload(true);
            };

            const onGameStartFailed = ({ message }) => {
                alert(`Game could not start:\n\n${message}`);
            };

            const onNotification = ({ message }) => {
                alert(message);
            };

            socket.on('connect', onConnect);
            socket.on('updateUser', onUpdateUser);
            socket.on('lobbyState', onLobbyState);
            socket.on('gameState', onGameState);
            socket.on('joinedTable', onJoinedTable);
            socket.on('error', onError);
            socket.on('connect_error', onConnectError);
            socket.on('forceDisconnectAndReset', onForceReset);
            socket.on('gameStartFailed', onGameStartFailed);
            socket.on('notification', onNotification);

            return () => {
                socket.off('connect', onConnect);
                socket.off('updateUser', onUpdateUser);
                socket.off('lobbyState', onLobbyState);
                socket.off('gameState', onGameState);
                socket.off('joinedTable', onJoinedTable);
                socket.off('error', onError);
                socket.off('connect_error', onConnectError);
                socket.off('forceDisconnectAndReset', onForceReset);
                socket.off('gameStartFailed', onGameStartFailed);
                socket.off('notification', onNotification);
            };
        }
    }, [token, handleLogout]);

    const handleLoginSuccess = (data) => {
        localStorage.setItem("sluff_token", data.token);
        setToken(data.token);
        setUser(data.user);
        enableSound();
    };

    const handleJoinTable = (tableId) => {
        enableSound();
        socket.emit("joinTable", { tableId });
    }

    const handleLeaveTable = () => {
        if (currentTableState) {
            socket.emit("leaveTable", { tableId: currentTableState.tableId });
        }
        handleReturnToLobby();
        setCurrentTableState(null);
    }

    const emitEvent = (eventName, payload = {}) => {
        if (currentTableState) {
            socket.emit(eventName, { ...payload, tableId: currentTableState.tableId });
        } else {
            socket.emit(eventName, payload);
        }
    }

    if (!token || !user) {
        return view === 'register' ?
            (
                <Register onRegisterSuccess={() => setView('login')} onSwitchToLogin={() => setView('login')} />
            ) : (
                <Login onLoginSuccess={handleLoginSuccess} onSwitchToRegister={() => setView('register')} />
            );
    }

    return (
        <>
            <MercyWindow
                show={showMercyWindow}
                onClose={() => setShowMercyWindow(false)}
                emitEvent={emitEvent}
            />

            {(() => {
                switch (view) {
                    case 'lobby':
                        return <LobbyView
                            user={user}
                            lobbyThemes={lobbyThemes}
                            serverVersion={serverVersion}
                            handleJoinTable={handleJoinTable}
                            handleLogout={handleLogout}
                            handleHardReset={handleHardReset}
                            handleRequestFreeToken={handleRequestFreeToken}
                            handleShowLeaderboard={() => setView('leaderboard')}
                            handleShowAdmin={handleShowAdmin}
                            errorMessage={errorMessage}
                            emitEvent={emitEvent}
                            socket={socket}
                        />;
                    case 'gameTable':
                        return currentTableState ?
                            (
                                <GameTableView
                                    playerId={user.id}
                                    currentTableState={currentTableState}
                                    handleLeaveTable={handleLeaveTable}
                                    // --- MODIFICATION: Pass handleLogout down ---
                                    handleLogout={handleLogout}
                                    errorMessage={errorMessage}
                                    emitEvent={emitEvent}
                                    playSound={playSound}
                                    socket={socket}
                                />
                            ) : (
                                <div>Loading table...</div>
                            );
                    case 'leaderboard':
                        return <LeaderboardView
                            user={user}
                            onReturnToLobby={handleReturnToLobby}
                            handleResetAllTokens={handleResetAllTokens}
                            handleShowAdmin={handleShowAdmin}
                        />;
                    case 'admin':
                        return <AdminView
                            onReturnToLobby={handleReturnToLobby}
                            emitEvent={emitEvent}
                        />;
                    default:
                        setView('lobby');
                        return null;
                }
            })()}
        </>
    );
}

export default App;
--- END FILE: frontend/src/App.js ---

--- START FILE: frontend/src/App.test.js ---
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});

--- END FILE: frontend/src/App.test.js ---

--- START FILE: frontend/src/constants.js ---
// frontend/src/constants.js

/**
 * This file centralizes constants used across the frontend application
 * to ensure consistency and make future updates easier.
 */

// Card and Suit Definitions
export const SUITS_MAP = { H: "Hearts", D: "Diamonds", C: "Clubs", S: "Spades" };
// --- FIX: Corrected UTF-8 characters for suit symbols ---
export const SUIT_SYMBOLS = { H: 'â™¥', D: 'â™¦', C: 'â™£', S: 'â™ ' };
export const SUIT_COLORS = { H: 'crimson', D: 'crimson', C: 'black', S: 'black' };
export const SUIT_BACKGROUNDS = { H: 'mistyrose', D: 'lightyellow', C: 'palegreen', S: 'lightgrey' };

// Game Rule Definitions
export const RANKS_ORDER = ["6", "7", "8", "9", "J", "Q", "K", "10", "A"];
export const CARD_POINT_VALUES = { "A": 11, "10": 10, "K": 4, "Q": 3, "J": 2, "9":0, "8":0, "7":0, "6":0 };
export const BID_HIERARCHY = ["Pass", "Frog", "Solo", "Heart Solo"];
export const BID_MULTIPLIERS = { "Frog": 1, "Solo": 2, "Heart Solo": 3 };

// Sorting Order Definitions
export const SUIT_SORT_ORDER = ['C', 'D', 'H', 'S'];

// Miscellaneous Game Identifiers
export const PLACEHOLDER_ID_CLIENT = "ScoreAbsorber";
--- END FILE: frontend/src/constants.js ---

--- START FILE: frontend/src/index.css ---
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

--- END FILE: frontend/src/index.css ---

--- START FILE: frontend/src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

--- END FILE: frontend/src/index.js ---

--- START FILE: frontend/src/reportWebVitals.js ---
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

--- END FILE: frontend/src/reportWebVitals.js ---

--- START FILE: frontend/src/setupTests.js ---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

--- END FILE: frontend/src/setupTests.js ---

--- START FILE: frontend/src/components/AdminView.css ---
/* frontend/src/components/AdminView.css */

.admin-view {
    display: flex;
    flex-direction: column;
    height: 100vh;
    background-color: #212121; /* Dark background */
    color: #f5f5f5;
    font-family: 'Merriweather', serif;
}

.admin-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 25px;
    background-color: #1a1a1a;
    border-bottom: 1px solid #444;
    flex-shrink: 0;
}

.admin-header h2 {
    font-family: 'Oswald', sans-serif;
    margin: 0;
    font-size: 1.8em;
    color: #e0e0e0;
}

.admin-actions-container {
    flex-grow: 1;
    overflow-y: auto;
    padding: 25px;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 25px;
}

.admin-action-card {
    background-color: #333;
    border: 1px solid #444;
    border-radius: 8px;
    padding: 20px;
    display: flex;
    flex-direction: column;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}

.admin-action-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
}

.admin-action-card h3 {
    font-family: 'Oswald', sans-serif;
    margin: 0 0 10px 0;
    color: #ffc107; /* Gold accent color */
    border-bottom: 1px solid #555;
    padding-bottom: 10px;
}

.admin-action-card p {
    flex-grow: 1;
    margin: 0 0 20px 0;
    line-height: 1.6;
    color: #bdbdbd;
}

.admin-button {
    padding: 10px 20px;
    font-family: 'Oswald', sans-serif;
    font-size: 1em;
    color: white;
    background-color: #007bff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.2s;
    align-self: flex-start; /* Align button to the start of the card */
}

.admin-button:disabled {
    background-color: #555;
    cursor: not-allowed;
}

.admin-button:hover:not(:disabled) {
    background-color: #0056b3;
}

.admin-button.back-button {
    background-color: #6c757d;
}

.admin-button.back-button:hover {
    background-color: #5a6268;
}

.admin-button.danger-button {
    background-color: #dc3545;
}

.admin-button.danger-button:hover {
    background-color: #c82333;
}

--- END FILE: frontend/src/components/AdminView.css ---

--- START FILE: frontend/src/components/AdminView.js ---
import React from 'react';

const AdminView = ({ onReturnToLobby, emitEvent }) => {

    const handleHardReset = () => {
        if (window.confirm("SERVER RESET WARNING:\n\nThis will boot ALL players from ALL tables, reset ALL in-progress games, and force everyone to log in again. This action cannot be undone.\n\nAre you sure you want to proceed?")) {
            const secret = prompt("Enter the server reset secret (Mouse_...):");
            if (secret) {
                emitEvent("hardResetServer", { secret });
            }
        }
    };

    const handleResetAllTokens = () => {
        if (window.confirm("TOKEN RESET WARNING:\n\nThis will reset the token balance for ALL players on the server to the default amount. This is useful for starting a new season.\n\nAre you sure you want to proceed?")) {
            const secret = prompt("Enter the token reset secret (Ben_...):");
            if (secret) {
                emitEvent("resetAllTokens", { secret });
            }
        }
    };

    return (
        <div className="admin-view">
            <header className="admin-header">
                <h2>Admin Control Panel</h2>
                <button onClick={onReturnToLobby} className="admin-button back-button">Back to Lobby</button>
            </header>
            <div className="admin-actions-container">
                <div className="admin-action-card">
                    <h3>Reset All Tokens</h3>
                    <p>Reset the token balance for ALL players to the default starting amount. Use this to begin a new season.</p>
                    <button onClick={handleResetAllTokens} className="admin-button danger-button">
                        Reset Tokens
                    </button>
                </div>
                <div className="admin-action-card">
                    <h3>Hard Server Reset</h3>
                    <p>Forcefully reset all game tables, boot all players, and clear all in-progress games. Use with extreme caution.</p>
                    <button onClick={handleHardReset} className="admin-button danger-button">
                        Hard Reset Server
                    </button>
                </div>
            </div>
        </div>
    );
};

export default AdminView;

--- END FILE: frontend/src/components/AdminView.js ---

--- START FILE: frontend/src/components/AuthForm.css ---
/* frontend/src/components/AuthForm.css */

.auth-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    background-color: #333;
    color: white;
    padding: 20px;
    font-family: 'Merriweather', serif;
}

.auth-logo {
    width: 100%;
    max-width: 300px;
    margin-bottom: 20px;
}

.auth-title {
    margin-top: 0;
    font-family: 'Oswald', sans-serif;
}

.auth-form {
    display: flex;
    flex-direction: column;
    gap: 10px;
    padding: 20px;
    background-color: #444;
    border-radius: 8px;
    min-width: 300px;
    width: 100%;
    max-width: 400px;
}

.auth-input {
    padding: 10px;
    border-radius: 4px;
    border: none;
    font-size: 1em;
}

.auth-error {
    color: #f87171; /* A lighter red for dark backgrounds */
    margin: 0;
    text-align: center;
}

.auth-button {
    padding: 10px;
    color: white;
    cursor: pointer;
    border: none;
    border-radius: 4px;
    font-size: 1.1em;
    font-family: 'Oswald', sans-serif;
}

.auth-button.login {
    background-color: #007bff;
}

.auth-button.register {
    background-color: #28a745;
}

.switch-form-button {
    background: none;
    border: none;
    color: #007bff;
    margin-top: 15px;
    cursor: pointer;
    font-size: 0.9em;
}

/* Specific to Register component */
.register-warning {
    color: #856404;
    background-color: #fff3cd;
    border-color: #ffeeba;
    padding: 15px;
    border-radius: 8px;
    margin: 10px 0;
    text-align: center;
}

.register-warning-title {
    font-size: 1.1em;
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
}

.register-warning-text {
    margin: 0;
    font-size: 0.95em;
}

--- END FILE: frontend/src/components/AuthForm.css ---

--- START FILE: frontend/src/components/Bulletin.css ---
/* frontend/src/components/Bulletin.css */

.bulletin-container {
    background-color: #2c2c2c;
    border: 1px solid #4f4f4f;
    border-radius: 8px;
    padding: 15px 25px;
    margin: 15px 0;
    text-align: left;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    font-family: 'Merriweather', serif;
    /* --- MODIFICATION: Make the container scrollable --- */
    max-height: 220px; /* Adjust this value to control the visible area */
    overflow-y: auto;  /* Add a scrollbar only when needed */
}

.bulletin-header {
    font-family: 'Oswald', sans-serif;
    color: #ffc107; /* Gold accent */
    margin-top: 10px;
    margin-bottom: 8px;
    border-bottom: 1px solid #444;
    padding-bottom: 5px;
    font-size: 1.3em;
}

.bulletin-container > *:first-child {
    margin-top: 0;
}

.bulletin-paragraph {
    line-height: 1.6;
    color: #e0e0e0;
    margin-bottom: 15px;
}

.bulletin-list-item {
    color: #d1d1d1;
    margin-bottom: 5px;
    padding-left: 10px;
    position: relative;
}

.bulletin-list-item::before {
    content: 'â€¢'; /* Bullet character */
    color: #ffc107; /* Gold accent for the bullet */
    font-weight: bold;
    display: inline-block;
    position: absolute;
    left: -10px;
}
--- END FILE: frontend/src/components/Bulletin.css ---

--- START FILE: frontend/src/components/Bulletin.js ---
import React from 'react';
import './Bulletin.css';
// --- MODIFICATION: Corrected the import path to be local ---
import { bulletinContent } from './bulletinContent';

/**
 * A component to display news and updates in the lobby.
 * It reads from a static content file for easy updates.
 */
const Bulletin = () => {
    return (
        <div className="bulletin-container">
            {bulletinContent.map((item, index) => {
                switch (item.type) {
                    case 'header':
                        return <h3 key={index} className="bulletin-header">{item.text}</h3>;
                    case 'paragraph':
                        return <p key={index} className="bulletin-paragraph">{item.text}</p>;
                    case 'list-item':
                        // To ensure valid HTML, we render a list item.
                        // The CSS will provide the bullet point.
                        return <div key={index} className="bulletin-list-item">{item.text}</div>;
                    default:
                        return null;
                }
            })}
        </div>
    );
};

export default Bulletin;
--- END FILE: frontend/src/components/Bulletin.js ---

--- START FILE: frontend/src/components/bulletinContent.js ---
// frontend/src/bulletinContent.js

/**
 * This file holds the content for the lobby bulletin.
 * To update the bulletin, simply edit the text in the 'content' array.
 * 
 * Supported types:
 * - 'header': A main title for a section.
 * - 'paragraph': A regular block of text.
 * - 'list-item': An item in a bulleted list.
 */

export const bulletinContent = [
    { 
        type: 'header', 
        text: 'Welcome to Sluff Alpha Testing!' 
    },
    { 
        type: 'paragraph', 
        text: 'Thank you for trying out the game. Your feedback is greatly appreciated as we work to make this the best experience possible.' 
    },
    { 
        type: 'header', 
        text: 'Recent Changes' 
    },
    { 
        type: 'list-item', 
        text: 'Added "Offer Draw" logic for ending games.' 
    },
    { 
        type: 'list-item', 
        text: 'Improved insurance panel buttons for more intuitive dealing.' 
    },
    { 
        type: 'list-item', 
        text: 'Fixed several bugs related to token calculation after a game finishes.' 
    },
    { 
        type: 'header', 
        text: 'On Deck' 
    },
    { 
        type: 'list-item', 
        text: 'A "Training Table" with lower stakes and UI helpers for new players.' 
    },
    { 
        type: 'list-item', 
        text: 'Improved backend logic for more detailed win/loss/forfeit tracking.' 
    },
    { 
        type: 'list-item', 
        text: 'An in-game tool for submitting feedback directly.' 
    },
    { 
        type: 'list-item', 
        text: 'First version of Bot players to fill empty seats.' 
    },
];
--- END FILE: frontend/src/components/bulletinContent.js ---

--- START FILE: frontend/src/components/GameTableView.css ---
/* frontend/src/components/GameTableView.css */

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.game-view {
    font-family: "Merriweather", serif;
    display: flex;
    flex-direction: column;
    height: 100vh;
    background-color: #333;
    overflow: hidden;
}

@keyframes pulsing-glow {
    0% { box-shadow: 0 0 5px #ffcc00; }
    50% { box-shadow: 0 0 20px #ffcc00; }
    100% { box-shadow: 0 0 5px #ffcc00; }
}

.game-button {
    padding: 8px 16px;
    font-family: 'Oswald', sans-serif;
    background: linear-gradient(to bottom, #5c6bc0, #3f51b5);
    color: white;
    border: 1px solid #303f9f;
    border-radius: 5px;
    cursor: pointer;
    margin: 5px;
}

.game-button:disabled {
    background: #9e9e9e;
    cursor: not-allowed;
}

.game-table {
    flex-grow: 1;
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    background: radial-gradient(circle, #424242, #212121);
    padding: 5px;
}

.table-oval {
    width: 100%;
    height: 100%;
    max-width: 1200px;
    background-color: #004d00;
    border-radius: 150px;
    border: 10px solid #3e2723;
    position: relative;
    box-shadow: inset 0 0 25px rgba(0,0,0,0.5);
}

/* Default Player Seat Positions (for landscape/desktop) */
.player-seat-left {
    position: absolute;
    top: 50%;
    left: 2%; 
    transform: translateY(-50%);
    z-index: 10;
}

.player-seat-right {
    position: absolute;
    top: 50%;
    right: 2%;
    transform: translateY(-50%);
    z-index: 10;
}

/* This seat is always at the bottom, inside the oval */
.player-seat-bottom {
    position: absolute;
    bottom: 5%;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
}

.card-back-container {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    background-color: #1a1a1a;
    border: 1px solid #888;
    border-radius: 4px;
    box-shadow: 1px 1px 3px rgba(0,0,0,0.5);
    padding: 5px;
    box-sizing: border-box;
}

.card-back-image {
    width: 100%;
    height: 100%;
    object-fit: contain;
    transform: rotate(-70deg);
}

.trick-pile-container {
    position: absolute;
    bottom: .1%;
    z-index: 5;
    width: auto;
}
.defender-pile { left: 15%; }
.bidder-pile { right: 15%; }

.trick-pile {
    display: flex;
    flex-direction: column;
    align-items: center;
    position: relative;
}
.trick-pile-cards {
    position: relative;
    height: 67.5px;
    width: 48.75px;
    margin-bottom: 5px;
}
.trick-pile-card-wrapper {
    position: absolute;
    top: 0;
    left: 0;
}
.trick-pile-label {
    color: white;
    font-family: 'Oswald', sans-serif;
    text-shadow: 1px 1px 2px black;
    font-size: 1.1em;
}

.score-progress-container {
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 240px;
    background-color: rgba(0, 0, 0, 0.6);
    padding: 5px 8px;
    border-radius: 8px;
    color: white;
    text-align: center;
    font-family: 'Oswald', sans-serif;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.score-progress-label {
    font-size: 0.9em;
    margin-bottom: 4px;
    text-shadow: 1px 1px 1px black;
    white-space: nowrap;
}

.score-progress-bar-background {
    width: 100%;
    height: 12px;
    background-color: #333;
    border-radius: 5px;
    border: 1px solid #555;
    overflow: hidden;
}

.score-progress-bar-foreground {
    height: 100%;
    border-radius: 4px;
    transition: width 0.5s ease-in-out;
}

.widow-display-container {
    position: absolute;
    top: 20px;
    left: 20px;
    z-index: 5;
    display: flex;
    flex-direction: column;
    align-items: center;
}

.widow-pile {
    display: flex;
    position: relative;
    height: 67.5px;
}

.widow-pile-card-wrapper {
    margin-right: -37.5px;
}

.widow-pile-label {
    color: white;
    font-family: 'Oswald', sans-serif;
    text-shadow: 1px 1px 2px black;
    margin-top: 5px;
}

@keyframes attention-glow {
    0% { box-shadow: 0 0 8px #ff4d4d; }
    50% { box-shadow: 0 0 25px #ff4d4d; }
    100% { box-shadow: 0 0 8px #ff4d4d; }
}

.trump-indicator-puck {
    position: absolute;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 20;
    width: 40px;
    height: 40px;
    background-color: rgba(0, 0, 0, 0.5);
    border: 2px solid #ccc;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.8em;
    color: white;
    cursor: help;
    transition: all 0.3s ease;
    overflow: hidden;
}

.trump-indicator-puck.broken {
    border-color: #ff4d4d;
    animation: attention-glow 1.5s infinite;
}

.trump-indicator-puck.broken::after {
    content: '';
    position: absolute;
    left: -10%;
    top: 50%;
    width: 120%;
    height: 4px;
    background-color: #ff4d4d;
    transform: translateY(-50%) rotate(-45deg);
    box-shadow: 0 0 5px black;
}


.last-trick-tab-container {
    position: absolute;
    top: 50%;
    z-index: 25;
}
.last-trick-tab-container.defender { 
    left: 10px; 
    transform: translateY(-50%) rotate(-90deg);
    transform-origin: left top;
}
.last-trick-tab-container.bidder { 
    right: 10px;
    transform: translateY(-50%) rotate(90deg);
    transform-origin: right top;
}

.last-trick-tab {
    background-color: #333;
    color: #fff;
    border: 1px solid #555;
    border-radius: 4px 4px 0 0;
    padding: 5px 10px;
    font-size: 1em;
    cursor: pointer;
}

.last-trick-overlay-container {
    position: absolute;
    bottom: 25%;
    z-index: 26;
    background-color: rgba(0,0,0,0.7);
    padding: 5px 8px;
    border-radius: 8px;
    text-align: center;
    transition: all 0.5s ease-in-out;
}
.last-trick-overlay-container.defender { left: 5%; }
.last-trick-overlay-container.bidder { right: 5%; }

.last-trick-header {
    margin: 0 0 5px 0;
    font-size: 0.7em;
    color: #e0e0e0;
}
.last-trick-cards {
    display: flex;
    gap: 2px;
}

.game-footer {
    background-color: rgba(48, 48, 48, 0.8);
    padding: 5px 10px;
    border-top: 2px solid #424242;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    color: white;
    position: relative;
}
.footer-controls-wrapper {
    display: flex;
    align-items: center;
    gap: 10px;
}

.player-hand-cards {
    display: flex;
    flex-wrap: nowrap;
    gap: 5px;
    justify-content: center;
    padding: 5px;
    overflow-x: auto;
}

.game-view-chat-container {
    width: 320px;
    position: absolute;
    bottom: 10px;
    left: 10px;
    z-index: 30;
}

.chat-close-button {
    position: absolute;
    top: 2px;
    right: 6px;
    cursor: pointer;
    color: #fff;
    background: none;
    border: none;
    font-size: 1.2em;
    z-index: 35;
}

.chat-tab-button {
    background-color: #333;
    color: #fff;
    border: 1px solid #555;
    border-radius: 4px;
    padding: 5px 10px;
    font-size: 1em;
    cursor: pointer;
    z-index: 25;
    display: flex;
    align-items: center;
    gap: 8px;
}

.unread-badge {
    background-color: #28a745;
    color: white;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    font-size: 0.8em;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
}

.modal-overlay, .initial-prompt-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.6);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.game-menu-popup {
    position: absolute;
    bottom: calc(100% + 10px);
    right: 10px;
    background-color: #212121;
    border: 1px solid #555;
    border-radius: 8px;
    padding: 15px;
    z-index: 1010;
    box-shadow: 0 -4px 12px rgba(0,0,0,0.5);
    color: white;
    width: 280px;
}

.initial-prompt-modal {
    background-color: #fefcbf;
    border: 2px solid #f59e0b;
    border-radius: 8px;
    padding: 20px;
    width: 90%;
    max-width: 500px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    text-align: center;
}

.game-menu-popup h3 {
    margin: 0 0 10px 0;
    padding-bottom: 10px;
    border-bottom: 1px solid #444;
    font-family: 'Oswald', sans-serif;
}

.game-menu-info p {
    margin: 0 0 8px 0;
    font-size: 0.9em;
}

.game-menu-actions {
    display: flex;
    justify-content: space-around;
    margin-top: 15px;
}

.hamburger-btn {
    background: none;
    border: 1px solid #666;
    padding: 8px;
    cursor: pointer;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.hamburger-btn svg {
    stroke: white;
}

.vertical-test-box-container {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 20;
}

.vertical-test-box-container.left {
    left: 10px;
}

.vertical-test-box-container.right {
    right: 10px;
}

.vertical-test-box {
    padding: 5px 10px;
    background-color: #333;
    color: white;
    border: 1px solid #555;
    border-radius: 4px;
    font-size: 1em;
    writing-mode: vertical-rl;
    text-orientation: mixed;
}

.vertical-test-box-container.left .vertical-test-box {
    transform: rotate(180deg);
}


/* --- MOBILE & RESPONSIVE STYLES --- */
@media (orientation: portrait) {
    .table-oval { border-radius: 50px; }

    /* Apply rotation for portrait mode */
    .player-seat-left {
        transform: translateY(-50%) rotate(90deg);
    }
    .player-seat-right {
        transform: translateY(-50%) rotate(-90deg);
    }

    .trick-pile-container { bottom: 15%; }

    .last-trick-tab-container { 
        top: auto;
        bottom: 25%;
    }

    .game-footer {
        flex-direction: column;
        padding: 5px;
        gap: 5px;
    }
    .player-hand-cards {
        flex-wrap: wrap;
        justify-content: center;
    }
    .footer-controls-wrapper {
        width: 100%;
        justify-content: space-between;
        background-color: #1a1a1a;
        padding: 5px 10px;
        border-top: 2px solid #424242;
    }
    .right-controls-group {
        display: flex;
        align-items: center;
        gap: 10px;
    }
}

@media (max-width: 768px) {
    .game-menu-popup {
        width: 90vw;
        right: 5vw;
        bottom: calc(100% + 5px);
    }
}
--- END FILE: frontend/src/components/GameTableView.css ---

--- START FILE: frontend/src/components/GameTableView.js ---
// frontend/src/components/GameTableView.js
import React, { useState, useEffect, useRef, useCallback } from 'react';

import './GameTableView.css';

import PlayerHand from './game/PlayerHand';
import InsuranceControls from './game/InsuranceControls';
import RoundSummaryModal from './game/RoundSummaryModal';
import TableLayout from './game/TableLayout';
import PlayerSeat from './game/PlayerSeat';
import ActionControls from './game/ActionControls';
import InsurancePrompt from './game/InsurancePrompt';
import IosPwaPrompt from './game/IosPwaPrompt';
import DrawVoteModal from './game/DrawVoteModal';
import LobbyChat from './LobbyChat';

import { getLobbyChatHistory } from '../services/api';
import { SUITS_MAP, SUIT_SYMBOLS, SUIT_COLORS, SUIT_BACKGROUNDS } from '../constants';

const GameTableView = ({ playerId, currentTableState, handleLeaveTable, handleLogout, emitEvent, playSound, socket }) => {
    const [seatAssignments, setSeatAssignments] = useState({ self: null, opponentLeft: null, opponentRight: null });
    const [showRoundSummaryModal, setShowRoundSummaryModal] = useState(false);
    const [showInsurancePrompt, setShowInsurancePrompt] = useState(false);
    const [showGameMenu, setShowGameMenu] = useState(false);
    const [showIosPrompt, setShowIosPrompt] = useState(false);
    const [showDrawVote, setShowDrawVote] = useState(false);
    const [chatOpen, setChatOpen] = useState(false);
    const [unreadChat, setUnreadChat] = useState(0);
    const [touchStartX, setTouchStartX] = useState(null);
    const SWIPE_CLOSE_THRESHOLD = 50; 
    const [playerError, setPlayerError] = useState(null);
    const [chatMessages, setChatMessages] = useState([]);
    const turnPlayerRef = useRef(null);
    const trickWinnerRef = useRef(null);
    const cardCountRef = useRef(null);
    const gameStateRef = useRef(null);
    const insurancePromptShownRef = useRef(false);
    const errorTimerRef = useRef(null);

    const selfPlayerInTable = currentTableState ? currentTableState.players[playerId] : null;
    const isSpectator = selfPlayerInTable?.isSpectator;
    const selfPlayerName = selfPlayerInTable?.playerName;
    
    useEffect(() => {
        getLobbyChatHistory()
            .then(setChatMessages)
            .catch(err => {
                console.error('Failed to load chat history:', err);
                setChatMessages([{ id: 'error', username: 'System', message: 'Could not load chat history.' }]);
            });
    }, []);

    useEffect(() => {
        if (!socket) return;
        
        const handleNewChatMessage = (newMessage) => {
            setChatMessages(prev => [...prev, newMessage]);
            setChatOpen(currentChatOpenState => {
                if (!currentChatOpenState) {
                    setUnreadChat(c => c + 1);
                }
                return currentChatOpenState;
            });
        };
        
        const handlePlayerError = ({ message }) => {
            if (errorTimerRef.current) clearTimeout(errorTimerRef.current);
            setPlayerError({ message });
            errorTimerRef.current = setTimeout(() => {
                setPlayerError(null);
                errorTimerRef.current = null;
            }, 4000);
        };

        socket.on('new_lobby_message', handleNewChatMessage);
        socket.on('error', handlePlayerError);

        return () => {
            socket.off('new_lobby_message', handleNewChatMessage);
            socket.off('error', handlePlayerError);
            if (errorTimerRef.current) clearTimeout(errorTimerRef.current);
        };
    }, [socket]);

    useEffect(() => {
        if (!showGameMenu) return;
        const timer = setTimeout(() => setShowGameMenu(false), 3000);
        return () => clearTimeout(timer);
    }, [showGameMenu]);
    
    const getPlayerNameByUserId = useCallback((targetPlayerId) => {
        if (!currentTableState?.players || !targetPlayerId) return String(targetPlayerId);
        const player = Object.values(currentTableState.players).find(p => p.userId === targetPlayerId);
        return player?.playerName || String(targetPlayerId);
    }, [currentTableState]);

    useEffect(() => {
        if (currentTableState && !isSpectator) {
            const insurance = currentTableState.insurance;
            if (insurance?.isActive && !insurancePromptShownRef.current) {
                setShowInsurancePrompt(true);
                insurancePromptShownRef.current = true;
            }
            if (!insurance?.isActive && insurancePromptShownRef.current) {
                insurancePromptShownRef.current = false;
            }
        }
    }, [currentTableState, isSpectator]);

    useEffect(() => {
        if (currentTableState) {
            const myVote = currentTableState.drawRequest?.votes?.[selfPlayerName];
            const shouldShow = currentTableState.drawRequest?.isActive && myVote == null && !isSpectator;
            setShowDrawVote(shouldShow);
        }
    }, [currentTableState, selfPlayerName, isSpectator]);

    useEffect(() => {
        if (currentTableState?.playerOrderActive?.length > 0 && playerId && currentTableState.players[playerId] && !isSpectator) {
            const myName = getPlayerNameByUserId(playerId);
            const selfIndex = currentTableState.playerOrderActive.indexOf(myName);
            if (selfIndex !== -1) {
                const numActive = currentTableState.playerOrderActive.length;
                const opponentLeftName = currentTableState.playerOrderActive[(selfIndex + 1) % numActive];
                const opponentRightName = currentTableState.playerOrderActive[(selfIndex + numActive - 1) % numActive];
                setSeatAssignments({ self: myName, opponentLeft: opponentLeftName, opponentRight: opponentRightName });
            } else { setSeatAssignments({ self: null, opponentLeft: null, opponentRight: null }); }
        } else { setSeatAssignments({ self: null, opponentLeft: null, opponentRight: null }); }
    }, [currentTableState, playerId, isSpectator, getPlayerNameByUserId]);
    
    useEffect(() => {
        if (currentTableState) {
            const { state, roundSummary } = currentTableState;
            const isModalState = state === "WidowReveal" || state === "Awaiting Next Round Trigger" || state === "Game Over";
            setShowRoundSummaryModal(!!(roundSummary && isModalState));
        }
    }, [currentTableState]);

    useEffect(() => {
        if (!currentTableState || !selfPlayerName || isSpectator) return;
        const { state, trickTurnPlayerName, lastCompletedTrick, currentTrickCards } = currentTableState;
        if ((state === "Playing Phase" || state === "Bidding Phase") && trickTurnPlayerName === selfPlayerName && turnPlayerRef.current !== selfPlayerName) playSound('turnAlert');
        turnPlayerRef.current = trickTurnPlayerName;
        const newCardCount = currentTrickCards?.length || 0;
        if (newCardCount > 0 && newCardCount !== cardCountRef.current) playSound('cardPlay');
        cardCountRef.current = newCardCount;
        if (lastCompletedTrick && lastCompletedTrick.winnerName === selfPlayerName && trickWinnerRef.current !== lastCompletedTrick.winnerName) playSound('trickWin');
        trickWinnerRef.current = lastCompletedTrick?.winnerName;
        if (state === 'Bidding Phase' && gameStateRef.current === 'Dealing Pending') playSound('cardDeal');
        gameStateRef.current = state;
    }, [currentTableState, selfPlayerName, isSpectator, playSound]);
    
    if (!currentTableState) {
        return <div>Loading table...</div>;
    }

    const openChatWindow = () => {
        setChatOpen(true);
        setUnreadChat(0);
    };

    const closeChatWindow = () => {
        setChatOpen(false);
    };

    const renderCard = (cardString, { isButton = false, onClick = null, disabled = false, isSelected = false, small = false, large = false, isFaceDown = false, style: customStyle = {} } = {}) => {
        const width = large ? '65px' : (small ? '30px' : '45px');
        const height = large ? '90px' : (small ? '50px' : '70px');

        if (isFaceDown) {
            return (
                <div className="card-back-container" style={{ width, height, ...customStyle }}>
                    <img src="/SluffLogo.png" alt="Card Back" className="card-back-image" />
                </div>
            );
        }

        if (!cardString) {
            return (
                <div 
                    className="card-placeholder" 
                    style={{ 
                        width, 
                        height, 
                        border: '2px dashed rgba(0, 0, 0, 0.2)', 
                        margin: '3px', 
                        display: 'inline-block', 
                        borderRadius: '4px', 
                        backgroundColor: 'transparent',
                        boxSizing: 'border-box' 
                    }}>
                </div>
            );
        }
        
        const rank = cardString.slice(0, -1);
        const suit = cardString.slice(-1);
        const symbol = SUIT_SYMBOLS[suit] || suit;
        const color = SUIT_COLORS[suit] || 'black';
        const backgroundColor = SUIT_BACKGROUNDS[suit] || 'white';
        let borderStyle = isSelected ? '3px solid royalblue' : '1px solid #777';
        const baseFontSize = large ? '1.3em' : (small ? '0.8em' : '1em');
        const style = { padding: large ? '10px' : (small ? '4px' : '8px'), border: borderStyle, borderRadius: '4px', backgroundColor: isSelected ? 'lightblue' : backgroundColor, color: color, margin: '3px', minWidth: width, height, textAlign: 'center', fontWeight: 'bold', fontSize: baseFontSize, cursor: isButton && !disabled ? 'pointer' : 'default', display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', ...customStyle };

        const symbolStyle = { fontSize: '125%' };
        const cardContent = <>{rank !== '?' && rank}<span style={symbolStyle}>{symbol}</span></>;

        if (isButton) return (<button key={cardString} onClick={onClick} disabled={disabled} style={style}>{cardContent}</button>);
        return (<span key={cardString} style={{ ...style, display: 'inline-flex' }}>{cardContent}</span>);
    };

    const handleForfeit = () => {
        if (window.confirm("Are you sure you want to forfeit? This will count as a loss and your buy-in will be distributed to the other players.")) {
            emitEvent("forfeitGame");
        }
        setShowGameMenu(false);
    };
    
    const GameMenu = () => (
        <div className="game-menu-popup">
            <h3>{currentTableState.tableName}</h3>
            <div className="game-menu-info">
                <p><strong>State:</strong> {currentTableState?.state || "N/A"}</p>
                <p><strong>Mode:</strong> {currentTableState?.playerMode ? `${currentTableState.playerMode}-Player` : "N/A"}</p>
                <p><strong>Trump:</strong> {currentTableState?.trumpSuit ? SUITS_MAP[currentTableState.trumpSuit] : "N/A"}</p>
                <p><strong>Bid:</strong> {currentTableState?.bidWinnerInfo?.bid || "N/A"} {currentTableState?.bidWinnerInfo?.playerName && ` by ${currentTableState.bidWinnerInfo.playerName}`}</p>
            </div>
            <div className="game-menu-actions">
                <button 
                    onClick={() => emitEvent("requestDraw")}
                    className="game-button"
                    disabled={currentTableState.state !== 'Playing Phase'}
                    style={{backgroundColor: '#1d4ed8'}}
                >
                    Request Draw
                </button>
                <button onClick={handleForfeit} className="game-button" style={{backgroundColor: '#dc3545'}}>Forfeit Game</button>
                <button onClick={handleLeaveTable} className="game-button">Lobby</button>
            </div>
        </div>
    );

    return (
        <div className="game-view">
            <InsurancePrompt 
                show={showInsurancePrompt}
                insuranceState={currentTableState.insurance}
                selfPlayerName={selfPlayerName}
                emitEvent={emitEvent}
                onClose={() => setShowInsurancePrompt(false)}
            />

            <DrawVoteModal
                show={showDrawVote}
                drawRequest={currentTableState.drawRequest}
                onVote={(vote) => emitEvent("submitDrawVote", { vote })}
            />

            <IosPwaPrompt show={showIosPrompt} onClose={() => setShowIosPrompt(false)} />

            <RoundSummaryModal
                summaryData={currentTableState.roundSummary}
                showModal={showRoundSummaryModal}
                playerId={playerId}
                getPlayerNameByUserId={getPlayerNameByUserId}
                renderCard={renderCard}
                emitEvent={emitEvent}
                insurance={currentTableState.insurance}
                bidWinnerInfo={currentTableState.bidWinnerInfo}
                playerOrderActive={currentTableState.playerOrderActive}
                handleLeaveTable={handleLeaveTable}
                handleLogout={handleLogout}
            />
            
            <TableLayout 
                currentTableState={currentTableState}
                seatAssignments={seatAssignments}
                isSpectator={isSpectator}
                renderCard={renderCard}
                PlayerSeat={PlayerSeat}
                ActionControls={ActionControls}
                selfPlayerName={selfPlayerName}
                playerId={playerId}
                emitEvent={emitEvent}
                playerError={playerError}
            />
            
            <footer className="game-footer">
                <PlayerHand
                    currentTableState={currentTableState}
                    selfPlayerName={selfPlayerName}
                    isSpectator={isSpectator}
                    emitEvent={emitEvent}
                    renderCard={renderCard}
                />
                <div className="footer-controls-wrapper">
                    {!chatOpen && (
                        <button className="chat-tab-button" onClick={openChatWindow}>
                            <span>Chat</span>
                            {unreadChat > 0 && <span className="unread-badge">{unreadChat}</span>}
                        </button>
                    )}
                    <div className="right-controls-group">
                        <InsuranceControls
                            insuranceState={currentTableState.insurance}
                            selfPlayerName={selfPlayerName}
                            isSpectator={isSpectator}
                            emitEvent={emitEvent}
                        />
                        <button className="hamburger-btn" onClick={() => setShowGameMenu(prev => !prev)}>
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                <line x1="3" y1="12" x2="21" y2="12"></line>
                                <line x1="3" y1="6" x2="21" y2="6"></line>
                                <line x1="3" y1="18" x2="21" y2="18"></line>
                            </svg>
                        </button>
                    </div>
                </div>
                {showGameMenu && <GameMenu />}
            </footer>
            
            {chatOpen && (
                <div 
                    className="game-view-chat-container open"
                    onTouchStart={(e) => setTouchStartX(e.touches[0].clientX)}
                    onTouchEnd={(e) => {
                        if (touchStartX !== null && e.changedTouches[0].clientX - touchStartX > SWIPE_CLOSE_THRESHOLD) {
                            closeChatWindow();
                        }
                        setTouchStartX(null);
                    }}
                >
                    <button className="chat-close-button" onClick={closeChatWindow} aria-label="Close chat window">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                    <LobbyChat
                        socket={socket}
                        messages={chatMessages}
                    />
                </div>
            )}
        </div>
    );
};

export default GameTableView;
--- END FILE: frontend/src/components/GameTableView.js ---

--- START FILE: frontend/src/components/LeaderboardView.css ---
/* frontend/src/components/LeaderboardView.css */

.leaderboard-view {
    display: flex;
    flex-direction: column;
    height: 100vh;
    background-color: #333;
    color: white;
    font-family: 'Merriweather', serif;
    overflow: hidden;
}

.leaderboard-header {
    padding: 10px 15px;
    background-color: #212121;
    border-bottom: 1px solid #444;
    flex-shrink: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.leaderboard-title-group {
    display: flex;
    align-items: center;
    gap: 15px;
}

.leaderboard-logo {
    height: 35px;
    width: auto;
}

.leaderboard-title {
    font-family: 'Oswald', sans-serif;
    margin: 0;
    font-size: 1.5em;
}

.leaderboard-header-buttons {
    display: flex;
    gap: 10px;
}

.back-button, .admin-button {
    padding: 6px 14px;
    font-family: 'Oswald', sans-serif;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
}

/* --- MODIFICATION: Specific styles for the icon button --- */
.refresh-button {
    background-color: #007bff;
    padding: 4px;
    border-radius: 4px;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

.refresh-button svg {
    fill: white;
    width: 22px;
    height: 22px;
}

.back-button {
    background: #6c757d;
}

.admin-button {
    background-color: #dc3545;
}

.leaderboard-main {
    flex-grow: 1;
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 20px;
    overflow: hidden;
}

.current-user-section {
    flex-shrink: 0;
}

.your-rank-title {
    font-family: 'Oswald', sans-serif;
    font-size: 1em;
    color: #ccc;
    margin: 0 0 5px 5px;
    text-transform: uppercase;
}

.full-leaderboard-container {
    flex-grow: 1;
    overflow-y: auto;
    position: relative;
}


.leaderboard-table {
    width: 100%;
    border-collapse: collapse;
    background-color: #444;
    border-radius: 8px;
    overflow: hidden;
    /* --- MODIFICATION: Use fixed layout for predictable columns --- */
    table-layout: fixed;
}

.leaderboard-table.current-user-table {
    background-color: #2a2a2a;
    border: 1px solid #ffc107;
}

.leaderboard-table th,
.leaderboard-table td {
    /* --- MODIFICATION: Tighter padding --- */
    padding: 10px 8px;
    text-align: left;
    border-bottom: 1px solid #555;
    vertical-align: middle;
}

/* --- MODIFICATION: Set specific widths for all columns --- */
.leaderboard-table .rank-col { width: 12%; }
.leaderboard-table .username-col { width: 35%; }
.leaderboard-table .rotated-header { width: 12%; }
.leaderboard-table .tokens-col { width: 17%; }

.leaderboard-table td.username-cell {
    /* These styles handle the truncation */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.leaderboard-table thead th {
    background-color: #212121;
    font-family: 'Oswald', sans-serif;
    font-size: 1.1em;
    color: #ffc107;
    height: 40px; 
    vertical-align: bottom;
    padding-bottom: 8px;
    /* --- MODIFICATION: Un-rotate the non-rotated headers --- */
    transform: none;
}

.leaderboard-table th.rotated-header {
    text-align: left;
    white-space: nowrap;
    vertical-align: middle;
    /* --- MODIFICATION: Make space for rotated text --- */
    height: 60px;
    padding-left: 20px;
}

.leaderboard-table th.rotated-header span {
    display: inline-block;
    /* --- MODIFICATION: Adjusted rotation and origin for better alignment --- */
    transform: rotate(-55deg);
    transform-origin: 0 50%;
    width: 30px; 
}

.leaderboard-table tbody tr:last-child td {
    border-bottom: none;
}

.leaderboard-table tbody tr:nth-child(even) {
    background-color: #3e3e3e;
}

.leaderboard-table td.tokens {
    font-weight: bold;
    color: #ffc107;
    text-align: right;
}

.loading-text,
.error-text {
    text-align: center;
    padding-top: 40px;
    font-size: 1.2em;
}

.error-text {
    color: #f87171;
}

.leaderboard-footer {
    flex-shrink: 0;
    padding: 10px 15px;
    background-color: #1a1a1a;
    border-top: 1px solid #444;
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

/* frontend/src/components/LeaderboardView.css */
--- END FILE: frontend/src/components/LeaderboardView.css ---

--- START FILE: frontend/src/components/LeaderboardView.js ---
// frontend/src/components/LeaderboardView.js
import React, { useState, useEffect, useCallback } from 'react';
import './LeaderboardView.css';
import { getLeaderboard } from '../services/api';

const LeaderboardView = ({ user, onReturnToLobby, handleResetAllTokens, handleShowAdmin }) => {
    const [leaderboardData, setLeaderboardData] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState('');

    const fetchLeaderboard = useCallback(async () => {
        setIsLoading(true);
        setError('');
        try {
            const data = await getLeaderboard();
            setLeaderboardData(data);
        } catch (err) {
            setError(err.message);
        } finally {
            setIsLoading(false);
        }
    }, []);

    useEffect(() => {
        fetchLeaderboard();
    }, [fetchLeaderboard]);

    const currentUserRank = leaderboardData.find(p => p.username === user.username);
    const currentUserRankIndex = leaderboardData.findIndex(p => p.username === user.username);

    const renderPlayerRow = (player, index) => (
        <tr key={player.username}>
            <td>{index + 1}</td>
            <td className="username-cell" title={player.username}>{player.username}</td>
            <td>{player.wins}</td>
            <td>{player.losses}</td>
            <td>{player.washes}</td>
            <td className="tokens">{parseFloat(player.tokens).toFixed(2)}</td>
        </tr>
    );

    return (
        <div className="leaderboard-view">
            <header className="leaderboard-header">
                <div className="leaderboard-title-group">
                    <img src="/SluffLogo.png" alt="Sluff Logo" className="leaderboard-logo" />
                    <h2 className="leaderboard-title">Leaderboard</h2>
                </div>
                <div className="leaderboard-header-buttons">
                    {/* --- MODIFICATION: Replaced text with an SVG icon --- */}
                    <button onClick={fetchLeaderboard} className="refresh-button" title="Refresh">
                        <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
                    </button>
                    <button onClick={onReturnToLobby} className="back-button">Back to Lobby</button>
                </div>
            </header>
            
            <main className="leaderboard-main">
                {isLoading ? (
                    <p className="loading-text">Loading...</p>
                ) : error ? (
                    <p className="error-text">{error}</p>
                ) : (
                    <>
                        {currentUserRank && (
                            <div className="current-user-section">
                                <h3 className="your-rank-title">Your Rank</h3>
                                <table className="leaderboard-table current-user-table">
                                    <thead>
                                        <tr>
                                            <th className="rank-col">Rank</th>
                                            <th className="username-col">Username</th>
                                            <th className="rotated-header"><span>Wins</span></th>
                                            <th className="rotated-header"><span>Losses</span></th>
                                            <th className="rotated-header"><span>Washes</span></th>
                                            <th className="tokens-col">Tokens</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {renderPlayerRow(currentUserRank, currentUserRankIndex)}
                                    </tbody>
                                </table>
                            </div>
                        )}

                        <div className="full-leaderboard-container">
                            <table className="leaderboard-table">
                                <thead>
                                    <tr>
                                        <th className="rank-col">Rank</th>
                                        <th className="username-col">Username</th>
                                        <th className="rotated-header"><span>Wins</span></th>
                                        <th className="rotated-header"><span>Losses</span></th>
                                        <th className="rotated-header"><span>Washes</span></th>
                                        <th className="tokens-col">Tokens</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {leaderboardData.map(renderPlayerRow)}
                                </tbody>
                            </table>
                        </div>
                    </>
                )}
            </main>

            {user?.is_admin && (
                <footer className="leaderboard-footer">
                    <button onClick={handleShowAdmin} className="admin-button">Admin Panel</button>
                    <button onClick={handleResetAllTokens} className="admin-button">Reset All Tokens</button>
                </footer>
            )}
        </div>
    );
};

export default LeaderboardView;
// frontend/src/components/LeaderboardView.js
--- END FILE: frontend/src/components/LeaderboardView.js ---

--- START FILE: frontend/src/components/LobbyChat.css ---
/* frontend/src/components/game/LobbyChat.css */

.lobby-chat-container {
    flex-shrink: 0; /* Prevents this area from shrinking */
    background-color: #1a1a1a;
    border-top: 1px solid #444;
}

.chat-log-section {
    padding: 0 15px;
}

.section-header {
    font-family: 'Oswald', sans-serif;
    font-size: 1.1em;
    color: #ffc107;
    background-color: #333;
    padding: 6px 12px;
    margin: 0;
    cursor: pointer;
    user-select: none;
    border-radius: 6px 6px 0 0;
}

.chat-log-window {
    /* --- MODIFICATION: Increased height for ~7 lines of text --- */
    height: 150px; 
    background-color: #2c2c2c;
    border: 1px solid #333;
    border-top: none;
    padding: 10px;
    overflow-y: auto;
}

.chat-placeholder-text {
    color: #888;
    font-style: italic;
    text-align: center;
    margin-top: 20px;
}

.chat-input-area {
    display: flex;
    gap: 10px;
    padding: 8px 15px;
    background-color: #1a1a1a;
}

.chat-input {
    flex-grow: 1;
    padding: 8px;
    border-radius: 20px;
    border: 1px solid #444;
    background-color: #333;
    color: white;
    font-size: 1em;
}

.chat-send-button {
    flex-shrink: 0;
    width: 36px;
    height: 36px;
    padding: 0;
    background: linear-gradient(to bottom, #28a745, #218838);
    color: white;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s;
    
}

.chat-line {
    color: #fff;
    margin-bottom: 4px;
    font-size: 0.9em;
    text-align: left; /* Explicitly align text to the left */
}
--- END FILE: frontend/src/components/LobbyChat.css ---

--- START FILE: frontend/src/components/LobbyChat.js ---
import React, { useState, useEffect, useRef } from 'react';
import './LobbyChat.css';
import { sendLobbyChatMessage } from '../services/api';

// Component now receives messages as a prop
const LobbyChat = ({ socket, messages = [] }) => {
    const [message, setMessage] = useState('');
    const chatLogRef = useRef(null);

    // Scroll to the bottom whenever the messages prop changes
    useEffect(() => {
        if (chatLogRef.current) {
            chatLogRef.current.scrollTop = chatLogRef.current.scrollHeight;
        }
    }, [messages]);

    const handleSend = async () => {
        if (message.trim()) {
            try {
                // The send logic remains the same
                await sendLobbyChatMessage(message.trim());
                setMessage('');
            } catch (err) {
                console.error('Failed to send chat message:', err);
            }
        }
    };

    // The stray brace has been removed from before this return statement
    return (
        <div className="lobby-chat-container">
            <div className="chat-log-window" ref={chatLogRef}>
                {messages.length === 0 ? (
                    <p className="chat-placeholder-text">No messages yet.</p>
                ) : (
                    messages.map(msg => (
                        <div key={msg.id} className="chat-line">
                            <strong>{msg.username}: </strong>{msg.message}
                        </div>
                    ))
                )}
            </div>
            <div className="chat-input-area">
                <input 
                    type="text" 
                    placeholder="Type a message..." 
                    className="chat-input"
                    value={message}
                    onChange={(e) => setMessage(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && handleSend()}
                />
                <button className="chat-send-button" onClick={handleSend} disabled={!message.trim()}>
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <path fill="currentColor" d="M13,20H11V8L5.5,13.5L4.08,12.08L12,4.16L19.92,12.08L18.5,13.5L13,8V20Z" />
                    </svg>
                </button>
            </div>
        </div>
    );
};

export default LobbyChat;
--- END FILE: frontend/src/components/LobbyChat.js ---

--- START FILE: frontend/src/components/LobbyTable.css ---
/* frontend/src/components/game/LobbyChat.css */

.lobby-chat-container {
    flex-shrink: 0; /* Prevents this area from shrinking */
    background-color: #1a1a1a;
    border-top: 1px solid #444;
}

.chat-log-section {
    padding: 0 15px; /* Removed top padding */
}

.section-header {
    font-family: 'Oswald', sans-serif;
    font-size: 1.1em; /* Made font smaller */
    color: #ffc107;
    background-color: #333;
    padding: 6px 12px; /* Reduced padding */
    margin: 0;
    cursor: pointer;
    user-select: none;
    border-radius: 6px 6px 0 0; 
}

.chat-log-window {
    height: 100px; /* Reduced height */
    background-color: #2c2c2c;
    border: 1px solid #333;
    border-top: none;
    padding: 10px;
    overflow-y: auto;
}

.chat-placeholder-text {
    color: #888;
    font-style: italic;
    text-align: center;
    margin-top: 20px;
}

.chat-input-area {
    display: flex;
    gap: 10px;
    padding: 8px 15px; /* Reduced padding */
    background-color: #1a1a1a;
}

.chat-input {
    flex-grow: 1;
    padding: 8px; /* Reduced padding */
    border-radius: 20px;
    border: 1px solid #444;
    background-color: #333;
    color: white;
    font-size: 1em;
}

.chat-send-button {
    flex-shrink: 0;
    width: 36px; /* Made smaller */
    height: 36px; /* Made smaller */
    padding: 0;
    background: linear-gradient(to bottom, #28a745, #218838);
    color: white;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s;
    
}

.chat-line {
    color: #fff;
    margin-bottom: 4px;
    font-size: 0.9em;
}
--- END FILE: frontend/src/components/LobbyTable.css ---

--- START FILE: frontend/src/components/LobbyTable.js ---
import React from 'react';
import './LobbyTable.css';

const LobbyTable = ({ table, onJoin, currentUserId }) => {
    // --- FIX: Default players to an empty object if it's null or undefined ---
    // This prevents the "Cannot convert undefined or null to object" crash.
    const { tableName, players = {}, gameStarted, playerMode } = table;

    const playerCount = Object.values(players).filter(p => !p.isSpectator).length;
    const isPlayerAtTable = players[currentUserId];
    const isFull = playerCount >= (playerMode || 4);

    let statusText = 'Waiting for players...';
    let canJoin = !isPlayerAtTable && !gameStarted && !isFull;

    if (gameStarted) {
        statusText = 'Game in progress';
        canJoin = false;
    } else if (isFull) {
        statusText = 'Table is full';
        canJoin = false;
    } else if (playerCount >= 3) {
        statusText = 'Ready to Start';
    }

    if (isPlayerAtTable) {
        statusText = 'You are at this table';
        canJoin = false;
    }

    return (
        <div className={`lobby-table ${gameStarted ? 'in-progress' : ''} ${isFull ? 'full' : ''}`}>
            <div className="table-header">
                <h3>{tableName}</h3>
                <span className="player-count">{playerCount} / {playerMode || 4}</span>
            </div>
            <div className="table-body">
                <ul className="player-list">
                    {Object.values(players).map(p => (
                        !p.isSpectator && <li key={p.userId}>{p.playerName}</li>
                    ))}
                </ul>
            </div>
            <div className="table-footer">
                <span className="table-status">{statusText}</span>
                <button onClick={onJoin} disabled={!canJoin} className="join-button">
                    Join
                </button>
            </div>
        </div>
    );
};

export default LobbyTable;

--- END FILE: frontend/src/components/LobbyTable.js ---

--- START FILE: frontend/src/components/LobbyTableCard.css ---
/* frontend/src/components/LobbyTableCard.css */
.table-card-container {
    background: #3c3c3c;
    border: 1px solid #555;
    border-radius: 8px;
    padding: 12px 15px;
    display: flex;
    flex-direction: column;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    transition: all 0.2s ease-in-out;
}

.table-card-container:not(.disabled):hover {
    transform: translateY(-3px);
    border-color: #777;
}

.table-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.table-card-title {
    font-family: 'Oswald', sans-serif;
    margin: 0;
    font-size: 1.1em;
    color: #fff;
}

.table-card-status {
    font-weight: bold;
    font-size: 0.8em;
    padding: 3px 8px;
    border-radius: 10px;
    color: white;
    /* --- MODIFICATION: Ensure status text doesn't wrap --- */
    white-space: nowrap; 
}

/* --- MODIFICATION: Added specific class for the new status --- */
.table-card-status.waiting-for-players { background-color: #28a745; }
.table-card-status.playing { background-color: #ffc107; color: #333; }
.table-card-status.full { background-color: #dc3545; }

.table-card-body {
    flex-grow: 1;
}

.player-list {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.9em;
    color: #ccc;
    list-style: none;
    padding: 0;
    margin: 0;
    min-height: 36px;
}

.player-names {
    flex-grow: 1;
    margin-right: 10px;
    /* --- MODIFICATION: Allow player names to shrink if needed but truncate gracefully --- */
    min-width: 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.open-seats {
    font-style: italic;
    color: #888;
}

.join-table-button {
    flex-shrink: 0;
    padding: 8px 12px; /* Adjusted padding */
    background: linear-gradient(to bottom, #28a745, #218838);
    color: white;
    border: 1px solid #1e7e34;
    border-radius: 6px;
    cursor: pointer;
    font-family: 'Oswald', sans-serif;
    font-size: 1em;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
    /* --- MODIFICATION: Prevent button text from wrapping --- */
    white-space: nowrap;
}

.join-table-button:hover:not(:disabled) {
    background: linear-gradient(to bottom, #2ebf4f, #28a745);
}

.table-card-container.disabled {
    opacity: 0.6;
}

.join-table-button:disabled {
    background: #6c757d;
    border-color: #5a6268;
    cursor: not-allowed;
}
--- END FILE: frontend/src/components/LobbyTableCard.css ---

--- START FILE: frontend/src/components/LobbyTableCard.js ---
import React from 'react';
import './LobbyTableCard.css';

const LobbyTableCard = ({ table, canAfford, onJoin, user }) => {
    const isFull = table.playerCount >= 4;
    const isPlaying = table.state.includes("Playing") || table.state.includes("Game Over");
    
    const isMyGame = table.players.some(p => p.userId === user.id);

    const canRejoin = isMyGame && isPlaying;
    const canJoin = !isMyGame && !isFull && canAfford && !isPlaying;
    
    const isDisabled = !(canJoin || canRejoin);
    const buttonText = canRejoin ? "Return to Game" : "Join";

    // --- MODIFICATION: Improved status text logic ---
    let statusText = 'Waiting for players';
    if (isPlaying) {
        statusText = 'Playing';
    } else if (isFull) {
        statusText = 'Full';
    }

    let buttonTitle = 'Join Table';
    if (canRejoin) buttonTitle = 'Return to your active game';
    else if (!canAfford) buttonTitle = 'You cannot afford the buy-in for this table.';
    else if (isFull) buttonTitle = 'This table is full.';
    else if (isPlaying) buttonTitle = 'This game is already in progress.';

    return (
        <div className={`table-card-container ${isDisabled ? 'disabled' : ''}`}>
            <div className="table-card-header">
                <h3 className="table-card-title">{table.tableName}</h3>
                <div className={`table-card-status ${statusText.toLowerCase().replace(/ /g, '-')}`}>
                    {statusText}
                </div>
            </div>
            <div className="table-card-body">
                <div className="player-list">
                    <span className="player-names">
                        {table.players && table.players.length > 0
                            ? table.players.map(p => p.playerName).join(', ')
                            : <em className="open-seats">Open Seats</em>
                        }
                    </span>
                    <button
                        onClick={() => onJoin(table.tableId)}
                        className="join-table-button"
                        disabled={isDisabled}
                        title={buttonTitle}
                        style={canRejoin ? {backgroundColor: '#17a2b8'} : {}}
                    >
                        {buttonText}
                    </button>
                </div>
            </div>
        </div>
    );
};

export default LobbyTableCard;
--- END FILE: frontend/src/components/LobbyTableCard.js ---

--- START FILE: frontend/src/components/LobbyView.css ---
/* frontend/src/components/LobbyView.css */

.lobby-view {
    display: flex;
    flex-direction: column;
    height: 100vh;
    background-color: #212121;
    color: white;
    /* --- MODIFICATION: Prevent any scrolling on the main container --- */
    overflow: hidden; 
}

/* Header section */
.lobby-header {
    padding: 5px 20px;
    background-color: #1a1a1a;
    flex-shrink: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.header-left, .header-right {
    display: flex;
    align-items: center;
    gap: 20px;
}

.lobby-logo {
    height: 35px;
}

.lobby-title {
    font-family: 'Oswald', sans-serif;
    margin: 0;
    font-size: 1.6em;
    font-weight: 400;
}

.user-welcome {
    font-size: 0.9em;
    color: #ccc;
}

.user-tokens {
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: bold;
    font-family: 'Oswald', sans-serif;
    background-color: #2c2c2c;
    padding: 5px 10px;
    border-radius: 20px;
    border: 1px solid #444;
}

.token-icon {
    height: 22px;
}

.user-tokens span {
    color: #ffc107;
    font-size: 1.1em;
}

.hamburger-menu-container {
    position: relative;
}

.hamburger-btn {
    background: none;
    /* --- MODIFICATION: Removed the border --- */
    border: none;
    padding: 5px;
    cursor: pointer;
    display: flex;
}
.hamburger-btn svg {
    fill: #aaa;
    width: 28px;
    height: 28px;
}

/* Tab Navigation */
.lobby-nav {
    display: flex;
    background-color: #2a2a2a;
    flex-shrink: 0;
    border-bottom: 1px solid #111;
    overflow-x: auto;
}

.lobby-tab {
    flex: 0 0 auto;
    padding: 8px 15px;
    border: none;
    background: transparent;
    border-bottom: 4px solid transparent;
    font-family: 'Oswald', sans-serif;
    font-size: 1em;
    cursor: pointer;
    color: #aaa;
    white-space: nowrap;
}

.lobby-tab.active {
    color: white;
    border-bottom-color: #0d6efd;
}

.lobby-tab-name {
    font-size: 1.1em;
}

.lobby-tab-cost {
    display: flex;
    align-items: center;
    gap: 4px;
    opacity: 0.7;
    font-size: 0.8em;
}

.tab-token-icon {
    height: 12px;
    width: 12px;
}


/* Main Content & Collapsible Sections */
/* --- MODIFICATION: Make the main area grow and scroll independently --- */
.lobby-main {
    flex-grow: 1;
    overflow-y: auto; 
    padding: 10px 15px;
}

.collapsible-section {
    margin-bottom: 10px;
}

.section-header {
    font-family: 'Oswald', sans-serif;
    font-size: 1.2em;
    color: #ffc107;
    background-color: #333;
    padding: 8px 12px;
    border-radius: 6px;
    margin: 0 0 10px 0;
    cursor: pointer;
    user-select: none;
}

.table-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 15px;
}

/* Lobby Menu */
.lobby-menu-popup {
    position: absolute;
    top: calc(100% + 10px);
    right: 0;
    background-color: #212121;
    border: 1px solid #555;
    border-radius: 8px;
    padding: 10px;
    z-index: 110;
    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    width: 150px;
}

.lobby-footer {
    padding: 4px 20px;
    background-color: #111;
    flex-shrink: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.7em;
    color: #888;
    font-family: monospace;
}

/* Responsive styles for the lobby menu */
@media (max-width: 768px) {
    .lobby-menu-popup {
        width: 60vw;
        right: 5vw;
        top: calc(100% + 5px);
    }
}


--- END FILE: frontend/src/components/LobbyView.css ---

--- START FILE: frontend/src/components/LobbyView.js ---
import React, { useState, useEffect } from 'react';
import './LobbyView.css';
import Bulletin from './Bulletin';
import LobbyTableCard from './LobbyTableCard';
import LobbyChat from './LobbyChat';

import { getLobbyChatHistory } from '../services/api';

const LobbyView = ({ user, lobbyThemes, serverVersion, handleJoinTable, handleLogout, handleRequestFreeToken, handleShowLeaderboard, handleShowAdmin, errorMessage, emitEvent, socket }) => {
    
    const [activeTab, setActiveTab] = useState('');
    const [showMenu, setShowMenu] = useState(false);
    const [tablesExpanded, setTablesExpanded] = useState(true);
    const [bulletinExpanded, setBulletinExpanded] = useState(true);
    const [chatLogExpanded, setChatLogExpanded] = useState(true);
    const [chatMessages, setChatMessages] = useState([]);

    useEffect(() => {
        getLobbyChatHistory()
            .then(setChatMessages)
            .catch(err => {
                console.error('Failed to load lobby chat history:', err);
                setChatMessages([{ id: 'error', username: 'System', message: 'Could not load chat history.' }]);
            });
    }, []);

    useEffect(() => {
        if (!socket) return;
        
        const handleNewMessage = (newMessage) => {
            setChatMessages(prev => [...prev, newMessage]);
        };

        socket.on('new_lobby_message', handleNewMessage);

        return () => {
            socket.off('new_lobby_message', handleNewMessage);
        };
    }, [socket]);

    useEffect(() => {
        if (!showMenu) return;
        const timer = setTimeout(() => setShowMenu(false), 3000);
        return () => clearTimeout(timer);
    }, [showMenu]);

    useEffect(() => {
        if (lobbyThemes && lobbyThemes.length > 0 && !activeTab) {
            setActiveTab(lobbyThemes[0].id);
        }
    }, [lobbyThemes, activeTab]);

    const activeTheme = lobbyThemes.find(theme => theme.id === activeTab);

    const LobbyMenu = () => (
        <div className="lobby-menu-popup">
            <button onClick={() => { handleRequestFreeToken(); setShowMenu(false); }} className="lobby-menu-button">Free Token</button>
            <button onClick={() => { emitEvent("requestUserSync"); setShowMenu(false); }} className="lobby-menu-button">Sync Profile</button>
            <button onClick={() => { handleShowLeaderboard(); setShowMenu(false); }} className="lobby-menu-button">Leaderboard</button>
            <button onClick={() => { handleLogout(); setShowMenu(false); }} className="lobby-menu-button">Logout</button>
            {user?.is_admin && <button onClick={() => { handleShowAdmin(); setShowMenu(false); }} className="lobby-menu-button admin">Admin Panel</button>}
        </div>
    );

    return (
        <div className="lobby-view">
            <header className="lobby-header">
                <div className="header-left">
                    <img src="/SluffLogo.png" alt="Sluff Logo" className="lobby-logo" />
                    <h2 className="lobby-title">Lobby</h2>
                </div>
                <div className="header-right">
                    <span className="user-welcome"><strong>{user.username}</strong></span>
                    <div className="user-tokens">
                        <img src="/sluff_token.png" alt="Tokens" className="token-icon" />
                        <span>{parseFloat(user.tokens).toFixed(2)}</span>
                    </div>
                    <div className="hamburger-menu-container">
                        <button className="hamburger-btn" onClick={() => setShowMenu(prev => !prev)}>
                             <svg width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z" /></svg>
                        </button>
                        {showMenu && <LobbyMenu />}
                    </div>
                </div>
            </header>
            
            {errorMessage && <p className="error-message">{errorMessage}</p>}

            <nav className="lobby-nav">
                {lobbyThemes && lobbyThemes.map(theme => (
                    <button
                        key={theme.id}
                        onClick={() => setActiveTab(theme.id)}
                        className={`lobby-tab ${activeTab === theme.id ? 'active' : ''}`}
                    >
                        <span className="lobby-tab-name">{theme.name}</span>
                        <span className="lobby-tab-cost">
                            <img src="/sluff_token.png" alt="Token" className="tab-token-icon" /> {theme.cost}
                        </span>
                    </button>
                ))}
            </nav>

            <main className="lobby-main">
                <div className="collapsible-section">
                    <h3 className="section-header" onClick={() => setTablesExpanded(!tablesExpanded)}>
                        Game Tables {tablesExpanded ? <>Ã¢â€ â€œ</> : <>Ã¢â€¡â€™</>}
                    </h3>
                    {tablesExpanded && (
                        <div className="table-grid">
                            {activeTheme ? activeTheme.tables.map(table => (
                                <LobbyTableCard 
                                    key={table.tableId}
                                    table={table}
                                    canAfford={user.tokens >= activeTheme.cost}
                                    onJoin={handleJoinTable}
                                    user={user}
                                />
                            )) : <p className="loading-text">Loading tables...</p>}
                        </div>
                    )}
                </div>
                
                <div className="collapsible-section">
                    <h3 className="section-header" onClick={() => setBulletinExpanded(!bulletinExpanded)}>
                        Bulletin {bulletinExpanded ? <>Ã¢â€ â€œ</> : <>Ã¢â€¡â€™</>}
                    </h3>
                    {bulletinExpanded && <Bulletin />}
                </div>
            </main>

            <LobbyChat
                chatLogExpanded={chatLogExpanded}
                onToggleChatLog={() => setChatLogExpanded(prev => !prev)}
                socket={socket}
                messages={chatMessages}
            />
            
            {/* --- NEW: Added a footer for server info --- */}
            <footer className="lobby-footer">
                <span>Server URL: {process.env.REACT_APP_SERVER_URL}</span>
                <span>Version: {serverVersion}</span>
            </footer>
        </div>
    );
};

export default LobbyView;
--- END FILE: frontend/src/components/LobbyView.js ---

--- START FILE: frontend/src/components/Login.js ---
import React, { useState } from 'react';
import './AuthForm.css'; // Import the shared CSS file
import { login } from '../services/api'; // --- MODIFICATION: Import the new login service function ---

const Login = ({ onLoginSuccess, onSwitchToRegister }) => {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');

        try {
            // --- MODIFICATION: Replace the old fetch with a call to the api service ---
            const data = await login(email, password);
            onLoginSuccess(data);
        } catch (err) {
            setError(err.message);
        }
    };

    return (
        <div className="auth-container">
            <img src="/SluffLogo.png" alt="Sluff Logo" className="auth-logo" />

            <h2 className="auth-title">Login</h2>
            <form onSubmit={handleSubmit} className="auth-form">
                <input
                    type="email"
                    placeholder="Email"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    required
                    className="auth-input"
                />
                <input
                    type="password"
                    placeholder="Password"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    required
                    className="auth-input"
                />
                {error && <p className="auth-error">{error}</p>}
                <button type="submit" className="auth-button login">Login</button>
            </form>
            <button onClick={onSwitchToRegister} className="switch-form-button">
                Don't have an account? Register
            </button>
        </div>
    );
};

export default Login;
--- END FILE: frontend/src/components/Login.js ---

--- START FILE: frontend/src/components/MercyWindow.css ---
/* frontend/src/components/MercyWindow.css */

.mercy-window-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 200; /* High z-index to appear over everything */
}

.mercy-window-content {
    background-color: #fff3cd; /* A light yellow, like a scroll of shame */
    color: #856404;
    padding: 20px 30px;
    border-radius: 10px;
    width: 90%;
    max-width: 450px;
    text-align: center;
    font-family: 'Merriweather', serif;
    border: 3px solid #ffeeba;
}

.mercy-window-content h2 {
    font-family: 'Oswald', sans-serif;
    color: #664d03;
    margin-top: 0;
}

.timer-display {
    font-size: 3em;
    font-weight: bold;
    font-family: 'Oswald', sans-serif;
    color: #d9534f;
    margin: 15px 0;
    padding: 10px;
    background-color: rgba(0, 0, 0, 0.05);
    border-radius: 5px;
}

.redemption-button {
    padding: 12px 24px;
    font-family: 'Oswald', sans-serif;
    font-size: 1.2em;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 15px;
    transition: background-color 0.2s;
}

.redemption-button.enabled {
    background-color: #28a745; /* Green for go */
}

.redemption-button.disabled {
    background-color: #6c757d; /* Gray for disabled */
    cursor: not-allowed;
}

--- END FILE: frontend/src/components/MercyWindow.css ---

--- START FILE: frontend/src/components/MercyWindow.js ---
import React, { useState, useEffect } from 'react';
import './MercyWindow.css';

const MercyWindow = ({ show, onClose, emitEvent }) => {
    const [secondsLeft, setSecondsLeft] = useState(15);

    useEffect(() => {
        if (show) {
            setSecondsLeft(15);

            const timer = setInterval(() => {
                setSecondsLeft(prevSeconds => {
                    if (prevSeconds <= 1) {
                        clearInterval(timer);
                        return 0;
                    }
                    return prevSeconds - 1;
                });
            }, 1000);

            return () => clearInterval(timer);
        }
    }, [show]);

    const handleRedeem = () => {
        // --- MODIFICATION: Only emit the request for the token. ---
        // The server is now responsible for pushing the user update.
        emitEvent("requestFreeToken");
        onClose();
    };

    if (!show) {
        return null;
    }

    const isButtonDisabled = secondsLeft > 0;

    return (
        <div className="mercy-window-overlay">
            <div className="mercy-window-content">
                <h2>A Moment of Contemplation</h2>
                <p>You have lost everything. Contemplate your life choices for the next few moments before receiving a handout.</p>
                <div className="timer-display">
                    {secondsLeft}
                </div>
                <button
                    onClick={handleRedeem}
                    className={`redemption-button ${isButtonDisabled ? 'disabled' : 'enabled'}`}
                    disabled={isButtonDisabled}
                >
                    I'm sorry, I'm bad
                </button>
            </div>
        </div>
    );
};

export default MercyWindow;
--- END FILE: frontend/src/components/MercyWindow.js ---

--- START FILE: frontend/src/components/Register.js ---
import React, { useState } from 'react';
import './AuthForm.css'; // Import the shared CSS file
import { register } from '../services/api'; // --- MODIFICATION: Import the new register service function ---

const Register = ({ onRegisterSuccess, onSwitchToLogin }) => {
    const [username, setUsername] = useState('');
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');

        try {
            // --- MODIFICATION: Replace the old fetch with a call to the api service ---
            await register(username, email, password);
            onRegisterSuccess();
        } catch (err) {
            setError(err.message);
        }
    };

    return (
        <div className="auth-container">
            <h2 className="auth-title">Register</h2>
            <form onSubmit={handleSubmit} className="auth-form">
                <input
                    type="text"
                    placeholder="Username"
                    value={username}
                    onChange={(e) => setUsername(e.target.value)}
                    required
                    className="auth-input"
                />
                <input
                    type="email"
                    placeholder="Email"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    required
                    className="auth-input"
                />
                <input
                    type="password"
                    placeholder="Password"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    required
                    className="auth-input"
                />

                <div className="register-warning">
                    <strong className="register-warning-title">WARNING: Unrecoverable Password!</strong>
                    <p className="register-warning-text">There is currently no way to recover a lost password. Please store your password in a very safe place, like a password manager.</p>
                </div>

                {error && <p className="auth-error">{error}</p>}
                <button type="submit" className="auth-button register">Register</button>
            </form>
            <button onClick={onSwitchToLogin} className="switch-form-button">
                Already have an account? Login
            </button>
        </div>
    );
};

export default Register;
--- END FILE: frontend/src/components/Register.js ---

--- START FILE: frontend/src/components/game/ActionControls.js ---
import React, { useEffect } from 'react';
import { BID_HIERARCHY } from '../../constants';

/**
 * Renders the main interactive element in the center of the table,
 * such as bidding controls, dealing buttons, or turn indicators.
 */
const ActionControls = ({
    currentTableState,
    playerId,
    selfPlayerName,
    isSpectator,
    emitEvent,
    renderCard
}) => {

    useEffect(() => {
        const socket = currentTableState.socket; 
        if (!socket) return;

        const handleGameStartError = (data) => {
            alert(`Could not start game: ${data.message}`);
        };

        socket.on('gameStartError', handleGameStartError);

        return () => {
            socket.off('gameStartError', handleGameStartError);
        };
    }, [currentTableState.socket]);


    const getPlayerNameByUserId = (targetPlayerId) => {
        if (!currentTableState?.players || !targetPlayerId) return String(targetPlayerId);
        const player = Object.values(currentTableState.players).find(p => p.userId === targetPlayerId);
        return player?.playerName || String(targetPlayerId);
    };
    
    if (isSpectator) {
        return <p style={{color: 'white', fontStyle:'italic'}}>{currentTableState.state}</p>;
    }

    const activePlayers = Object.values(currentTableState.players).filter(p => !p.isSpectator && !p.disconnected);

    switch (currentTableState.state) {
        case "Waiting for Players":
            return (
                <div style={{ color: 'white', textAlign: 'center', backgroundColor: 'transparent', padding: '15px', borderRadius: '8px' }}>
                    <h2>Waiting for players... ({activePlayers.length} / 3)</h2>
                    {activePlayers.length < 4 && (
                        <button onClick={() => emitEvent("addBot")} className="game-button">Add Bot</button>
                    )}
                </div>
            );

        case "Ready to Start":
            if (activePlayers.length < 3) {
                return <h2 style={{ color: 'white' }}>Waiting for more players...</h2>;
            }
            return (
                <div>
                    <button onClick={() => emitEvent("startGame", { tableId: currentTableState.tableId })} className="game-button">Start {activePlayers.length}-Player Game</button>
                    {activePlayers.length < 4 && (
                        <button onClick={() => emitEvent("addBot")} className="game-button">Add Bot</button>
                    )}
                </div>
            );

        case "Dealing Pending":
            if (playerId === currentTableState.dealer) {
                return <button onClick={() => emitEvent("dealCards")} className="game-button">Deal Cards</button>;
            }
            return <p style={{ color: 'white', fontStyle: 'italic' }}>Waiting for {getPlayerNameByUserId(currentTableState.dealer)} to deal...</p>;

        case "Bidding Phase":
            if (currentTableState.biddingTurnPlayerName === selfPlayerName) {
                const bids = BID_HIERARCHY;
                const currentHighestBidLevel = currentTableState.currentHighestBidDetails ? BID_HIERARCHY.indexOf(currentTableState.currentHighestBidDetails.bid) : -1;
                return (
                    <div style={{ textAlign: 'center', backgroundColor: 'rgba(0,0,0,0.5)', padding: '10px', borderRadius: '10px' }}>
                        <p style={{ color: 'white', margin: '0 0 10px 0' }}>Your turn to bid.</p>
                        {bids.map(bid => (
                            <button 
                                key={bid} 
                                onClick={() => emitEvent("placeBid", { bid })} 
                                className="game-button" 
                                disabled={bid !== "Pass" && BID_HIERARCHY.indexOf(bid) <= currentHighestBidLevel}>
                                {bid}
                            </button>
                        ))}
                    </div>
                );
            }
            return <p style={{ color: 'white', fontStyle: 'italic' }}>Waiting for {currentTableState.biddingTurnPlayerName} to bid...</p>;

        case "Awaiting Frog Upgrade Decision":
            if (currentTableState.biddingTurnPlayerName === selfPlayerName) {
                return (
                    <div style={{ textAlign: 'center', backgroundColor: 'rgba(0,0,0,0.5)', padding: '10px', borderRadius: '10px' }}>
                        <p style={{ color: 'white' }}>A Solo bid was made. Upgrade your Frog to Heart Solo?</p>
                        <button onClick={() => emitEvent("placeBid", { bid: "Heart Solo" })} className="game-button">Upgrade to Heart Solo</button>
                        <button onClick={() => emitEvent("placeBid", { bid: "Pass" })} className="game-button">Pass</button>
                    </div>
                );
            }
            return <p style={{ color: 'white', fontStyle: 'italic' }}>Waiting for {currentTableState.biddingTurnPlayerName} to decide...</p>;

        case "Trump Selection":
            if (currentTableState.bidWinnerInfo?.userId === playerId) {
                return (
                    <div className="action-prompt">
                        <h4>Choose Trump Suit:</h4>
                        <div style={{ display: 'flex', justifyContent: 'center', gap: '10px', marginTop: '10px' }}>
                            {["D", "C", "S"].map(suit => renderCard(`?${suit}`, {
                                key: suit,
                                large: true,
                                isButton: true,
                                onClick: () => emitEvent("chooseTrump", { suit })
                            }))}
                        </div>
                    </div>
                );
            }
            return <p style={{ color: 'white', fontStyle: 'italic' }}>Waiting for {currentTableState.bidWinnerInfo?.playerName} to choose trump...</p>;

        case "AllPassWidowReveal":
            return (
                <div className="action-prompt">
                    <h4>All players passed. Revealing the widow...</h4>
                    <div style={{ display: 'flex', justifyContent: 'center', gap: '10px', marginTop: '10px' }}>
                        {(currentTableState.originalDealtWidow || []).map((card, index) => renderCard(card, { key: index, large: true }))}
                    </div>
                </div>
            );

        case "Playing Phase":
        case "TrickCompleteLinger":
            if (currentTableState.trickTurnPlayerName === selfPlayerName) {
                return <p style={{ color: 'limegreen', fontWeight: 'bold', fontSize: '1.2em', textShadow: '1px 1px 2px black' }}>Your Turn!</p>;
            }
            return <p style={{ color: 'white', fontStyle: 'italic' }}>Waiting for {currentTableState.trickTurnPlayerName}...</p>;
        
        case "Frog Widow Exchange":
            const isBidder = currentTableState.bidWinnerInfo?.userId === playerId;
            if (isBidder) {
                return null; 
            } else {
                return (
                    <div className="action-prompt">
                        <h4 style={{marginBottom: '10px'}}>Revealed Widow (Frog)</h4>
                        <div style={{ display: 'flex', justifyContent: 'center', gap: '10px' }}>
                            {(currentTableState.revealedWidowForFrog || []).map((card, index) => renderCard(card, { key: `widow-${index}`, large: true }))}
                        </div>
                        <p style={{ color: 'white', fontStyle: 'italic', marginTop: '15px' }}>
                            {currentTableState.bidWinnerInfo?.playerName} is exchanging cards...
                        </p>
                    </div>
                );
            }

        default:
            return <p style={{ color: 'white' }}>{currentTableState.state}</p>;
    }
};

export default ActionControls;
--- END FILE: frontend/src/components/game/ActionControls.js ---

--- START FILE: frontend/src/components/game/CardValueKey.js ---
import React, { useState } from 'react';
import { CARD_POINT_VALUES } from '../../constants';
import './KeyAndModal.css';

/**
 * A static UI component to display the point values of cards.
 */
const CardValueKey = () => {
    const [expanded, setExpanded] = useState(false);
    // Sort the cards by point value for a logical display
    const sortedCards = Object.entries(CARD_POINT_VALUES).sort(([, a], [, b]) => b - a);

    return (
        <div
            className="card-value-key-container"
            onClick={() => setExpanded(!expanded)}
        >
            <h4 className="card-value-key-title">
                Card Points {expanded ? 'â–²' : 'â–¼'}
            </h4>
            {expanded && (
                <div className="card-value-key-list">
                    {sortedCards.map(([rank, value]) => (
                        <p key={rank} className="card-value-key-item">
                            <strong>{rank}:</strong> {value} pts
                        </p>
                    ))}
                </div>
            )}
        </div>
    );
};

export default CardValueKey;
--- END FILE: frontend/src/components/game/CardValueKey.js ---

--- START FILE: frontend/src/components/game/DrawVoteModal.js ---
// frontend/src/components/game/DrawVoteModal.js
import React from 'react';
import './RoundSummaryModal.css'; // You can reuse the modal styles

const DrawVoteModal = ({ show, drawRequest, onVote, onClose }) => {
    if (!show || !drawRequest?.isActive) return null;

    return (
        <div className="modal-overlay">
            <div className="modal-content">
                <h2>Draw Requested</h2>
                <p><strong>{drawRequest.initiator}</strong> has requested to end the game.</p>
                <p>Time to vote: <strong>{drawRequest.timer}s</strong></p>
                
                <div className="draw-votes">
                    <p>Votes:</p>
                    <ul>
                        {Object.entries(drawRequest.votes).map(([name, vote]) => (
                            <li key={name}>
                                {name}: {vote ? <strong>{vote.toUpperCase()}</strong> : '...voting'}
                            </li>
                        ))}
                    </ul>
                </div>

                <div className="modal-actions" style={{ marginTop: '20px' }}>
                    <button className="game-button" onClick={() => onVote('wash')}>
                        Vote Wash (Return Buy-ins)
                    </button>
                    <button className="game-button" style={{ backgroundColor: '#1e40af' }} onClick={() => onVote('split')}>
                        Vote Split (Proportional Payout)
                    </button>
                    <button className="game-button" style={{ backgroundColor: '#991b1b' }} onClick={() => onVote('no')}>
                        Vote No (Resume Game)
                    </button>
                </div>
            </div>
        </div>
    );
};

export default DrawVoteModal;
--- END FILE: frontend/src/components/game/DrawVoteModal.js ---

--- START FILE: frontend/src/components/game/InsuranceControls.css ---
/* frontend/src/components/game/InsuranceControls.css */

.insurance-controls-container {
    padding: 8px 12px;
    background-color: rgba(0, 0, 0, 0.4);
    color: white;
    border-radius: 8px;
    flex-basis: auto;
    flex-shrink: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    min-height: 50px; /* Ensure consistent height */
}

.deal-made-text {
    color: #10b981; /* Green */
    font-weight: bold;
    font-size: 1.2em;
    font-family: 'Oswald', sans-serif;
}

.value-display {
    font-size: 1.6em;
    font-weight: bold;
    font-family: 'Oswald', sans-serif;
    min-width: 40px;
    text-align: center;
    line-height: 1;
}

/* Color for the player's own value based on giving/getting points */
.value-display.player-value-get {
  color: #22c55e; /* Green 500 - for getting points */
}

.value-display.player-value-give {
  color: #ef4444; /* Red 500 - for giving points */
}


.gap-value {
    border-right: 1px solid rgba(255, 255, 255, 0.2);
    padding-right: 15px;
}

.gap-value.positive {
    color: #f59e0b; /* Amber */
}

.gap-value.zero-or-less {
    color: #10b981; /* Green */
}

.adjust-button {
    width: 32px;
    height: 32px;
    font-size: 1.5em;
    font-weight: bold;
    cursor: pointer;
    background: linear-gradient(to bottom, #4a5568, #2d3748); /* Default Gray gradient */
    border: 1px solid #718096;
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    transition: all 0.2s ease;
}

.adjust-button:hover {
    background: linear-gradient(to bottom, #718096, #4a5568);
    box-shadow: 0 0 8px rgba(150, 160, 180, 0.7);
}

.adjust-button:active {
    transform: translateY(1px);
}

/* Green button for "good" actions */
.adjust-button.adjust-green {
    background: linear-gradient(to bottom, #34d399, #10b981);
    border-color: #10b981;
}
.adjust-button.adjust-green:hover {
    background: linear-gradient(to bottom, #4ade80, #22c55e);
    box-shadow: 0 0 8px rgba(34, 197, 94, 0.7);
}

/* Red button for "bad" actions */
.adjust-button.adjust-red {
    background: linear-gradient(to bottom, #f87171, #ef4444);
    border-color: #ef4444;
}
.adjust-button.adjust-red:hover {
    background: linear-gradient(to bottom, #fb7185, #f43f5e);
    box-shadow: 0 0 8px rgba(239, 68, 68, 0.7);
}

--- END FILE: frontend/src/components/game/InsuranceControls.css ---

--- START FILE: frontend/src/components/game/InsuranceControls.js ---
import React from 'react';
import './InsuranceControls.css'; // Import the new CSS file

/**
 * Renders a super-compact insurance negotiation panel for 3-player games,
 * focusing on values and buttons with no text labels.
 */
const InsuranceControls = ({ insuranceState, selfPlayerName, isSpectator, emitEvent }) => {

    if (!insuranceState || !insuranceState.isActive || isSpectator) {
        return null;
    }

    const { bidderPlayerName, bidderRequirement, defenderOffers, dealExecuted } = insuranceState;
    const isBidder = selfPlayerName === bidderPlayerName;
    const myOffer = defenderOffers ? defenderOffers[selfPlayerName] : undefined;
    const isDefender = myOffer !== undefined;

    const handleAdjustInsurance = (amount) => {
        if (dealExecuted) return; // Don't allow changes after a deal is made
        let settingType, currentValue;
        if (isBidder) {
            settingType = 'bidderRequirement';
            currentValue = bidderRequirement;
        } else if (isDefender) {
            settingType = 'defenderOffer';
            currentValue = myOffer;
        } else {
            return;
        }
        const newValue = currentValue + amount;
        emitEvent("updateInsuranceSetting", { settingType, value: newValue });
    };

    const sumOfOffers = Object.values(defenderOffers || {}).reduce((sum, offer) => sum + offer, 0);
    const gapToDeal = bidderRequirement - sumOfOffers;
    const playerValue = isBidder ? bidderRequirement : myOffer;

    // --- Build className strings dynamically ---
    const gapValueClasses = [
        'value-display',
        'gap-value',
        gapToDeal <= 0 ? 'zero-or-less' : 'positive'
    ].join(' ');

    const playerValueClasses = ['value-display'];
    if (isBidder) {
        playerValueClasses.push('player-value-get');
    } else if (isDefender) {
        if (playerValue > 0) playerValueClasses.push('player-value-give');
        else playerValueClasses.push('player-value-get');
    }

    // --- Determine button colors based on role ---
    const decreaseButtonClasses = ['adjust-button'];
    const increaseButtonClasses = ['adjust-button'];

    if (isBidder) {
        // For bidder: increasing is good (green), decreasing is bad (red)
        increaseButtonClasses.push('adjust-green');
        decreaseButtonClasses.push('adjust-red');
    } else if (isDefender) {
        // For defender: increasing offer is bad (red), decreasing is good (green)
        increaseButtonClasses.push('adjust-red');
        decreaseButtonClasses.push('adjust-green');
    }


    return (
        <div className="insurance-controls-container">
            {dealExecuted ? (
                <div className="deal-made-text">DEAL!</div>
            ) : (
                <>
                    {/* Gap to Deal Value */}
                    <div className={gapValueClasses} title="Gap to Deal">{gapToDeal}</div>

                    {/* Player Controls */}
                    {(isBidder || isDefender) && (
                        <>
                            <div className={playerValueClasses.join(' ')} title={isBidder ? 'Your Ask' : 'Your Offer'}>{playerValue}</div>
                            <button onClick={() => handleAdjustInsurance(-1)} className={decreaseButtonClasses.join(' ')} title="Decrease">-</button>
                            <button onClick={() => handleAdjustInsurance(1)} className={increaseButtonClasses.join(' ')} title="Increase">+</button>
                        </>
                    )}
                </>
            )}
        </div>
    );
};

export default InsuranceControls;

--- END FILE: frontend/src/components/game/InsuranceControls.js ---

--- START FILE: frontend/src/components/game/InsurancePrompt.js ---
import React from 'react';

/**
 * A modal that prompts the user for their initial insurance setting
 * at the beginning of the playing phase.
 */
const InitialInsurancePrompt = ({ show, insuranceState, selfPlayerName, emitEvent, onClose }) => {

    if (!show || !insuranceState) {
        return null;
    }

    const { bidMultiplier } = insuranceState;
    const isBidder = selfPlayerName === insuranceState.bidderPlayerName;
    
    let title, options, settingType;

    // Define colors for button states
    const buttonColors = {
        give: '#ef4444', // Red 500
        get: '#22c55e',  // Green 500
        neutral: '#3b82f6' // Blue 500
    };

    const getButtonColor = (value) => {
        if (isBidder) {
            // Bidders are always asking to GET points, so their options are "good".
            return buttonColors.get;
        }
        // For defenders, giving points is "bad" (red), getting is "good" (green).
        if (value > 0) return buttonColors.give;
        if (value < 0) return buttonColors.get;
        return buttonColors.neutral; // For the '0' option
    };


    if (isBidder) {
        title = "Set Your Initial Requirement";
        settingType = 'bidderRequirement';
        options = [20, 30, 40, 60, 80].map(v => v * bidMultiplier);
    } else {
        title = "Make Your Initial Offer";
        settingType = 'defenderOffer';
        options = [-10, -5, 0, 5, 10, 15, 20].map(v => v * bidMultiplier);
    }

    const handleChoice = (value) => {
        emitEvent("updateInsuranceSetting", { settingType, value });
        onClose(); // Close the modal after a choice is made
    };

    return (
        <div className="initial-prompt-modal-overlay">
            <div className="initial-prompt-modal">
                <h3 style={{ fontFamily: 'Oswald, sans-serif', margin: '0 0 15px 0' }}>{title}</h3>
                
                {/* Explanatory text for defenders */}
                {!isBidder && (
                    <div style={{ fontSize: '0.9em', marginBottom: '15px', textAlign: 'center' }}>
                        <span style={{ color: buttonColors.get, fontWeight: 'bold' }}>Green values</span> are points you GET.
                        <br />
                        <span style={{ color: buttonColors.give, fontWeight: 'bold' }}>Red values</span> are points you GIVE.
                    </div>
                )}

                <div style={{ display: 'flex', flexWrap: 'wrap', justifyContent: 'center', gap: '10px' }}>
                    {options.map(value => {
                        const color = getButtonColor(value);
                        return (
                            <button
                                key={value}
                                className="game-button"
                                style={{
                                    fontSize: '1.1em',
                                    minWidth: '60px',
                                    color: 'white',
                                    textShadow: '1px 1px 2px rgba(0,0,0,0.7)',
                                    // FIX: Explicitly set background properties to override global .game-button styles
                                    backgroundImage: 'none',
                                    backgroundColor: color,
                                    borderColor: color
                                }}
                                onClick={() => handleChoice(value)}
                            >
                                {value}
                            </button>
                        );
                    })}
                </div>
                <p style={{ fontSize: '0.8em', fontStyle: 'italic', marginTop: '15px', color: '#666' }}>
                    You can change this at any time using the main insurance panel below.
                </p>
                 <button onClick={onClose} style={{marginTop: '10px', background: 'none', border: '1px solid #aaa', padding: '5px 10px', borderRadius: '4px', cursor: 'pointer'}}>Skip</button>
            </div>
        </div>
    );
};

export default InitialInsurancePrompt;

--- END FILE: frontend/src/components/game/InsurancePrompt.js ---

--- START FILE: frontend/src/components/game/IosPwaPrompt.js ---
import React from 'react';

/**
 * A simple modal that instructs iOS users on how to add the app
 * to their home screen for a fullscreen experience.
 */
const IosPwaPrompt = ({ show, onClose }) => {
    if (!show) {
        return null;
    }

    const shareIcon = (
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8" />
            <polyline points="16 6 12 2 8 6" />
            <line x1="12" y1="2" x2="12" y2="15" />
        </svg>
    );

    const plusIcon = (
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <line x1="12" y1="5" x2="12" y2="19" />
            <line x1="5" y1="12" x2="19" y2="12" />
        </svg>
    );

    return (
        <div className="modal-overlay" onClick={onClose}>
            <div className="modal-content" style={{maxWidth: '350px'}} onClick={e => e.stopPropagation()}>
                <h3 style={{fontFamily: 'Oswald, sans-serif'}}>Get the Full App Experience</h3>
                <p>To play in fullscreen without the address bar, add this game to your Home Screen:</p>
                <ol style={{textAlign: 'left', paddingLeft: '25px'}}>
                    <li style={{marginBottom: '10px'}}>Tap the <strong>Share</strong> icon {shareIcon} in your browser's toolbar.</li>
                    <li style={{marginBottom: '10px'}}>Scroll down and tap on <strong>"Add to Home Screen"</strong> {plusIcon}.</li>
                </ol>
                <button onClick={onClose} className="game-button" style={{marginTop: '10px'}}>Got It</button>
            </div>
        </div>
    );
};

export default IosPwaPrompt;

--- END FILE: frontend/src/components/game/IosPwaPrompt.js ---

--- START FILE: frontend/src/components/game/KeyAndModal.css ---
/* frontend/src/components/game/KeyAndModal.css */

.card-value-key-container {
    position: absolute;
    top: 20px;
    right: 20px;
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
    padding: 10px 15px;
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    font-family: 'Merriweather', serif;
    z-index: 20;
    width: 130px;
    cursor: pointer; /* Indicates the container is clickable */
}

/* 
  This rule is no longer needed because the JavaScript's conditional
  rendering (`expanded && ...`) removes the element entirely instead of hiding it.
*/
/*
.card-value-key-container.collapsed .card-value-key-list {
    display: none;
}
*/

.card-value-key-title {
    font-family: 'Oswald', sans-serif;
    margin: 0; /* Removed bottom margin for a tighter look when collapsed */
    text-align: center;
    font-size: 1.1em;
    color: #ffc107; /* Gold accent */
}

.card-value-key-list {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    margin-top: 5px; /* Add some space between title and list when expanded */
}

.card-value-key-item {
    margin: 2px 0;
    font-size: 0.9em;
    width: 50%; /* Two columns */
}
--- END FILE: frontend/src/components/game/KeyAndModal.css ---

--- START FILE: frontend/src/components/game/LearnerDisplay.css ---
/* frontend/src/components/game/LearnerDisplay.css */

.score-progress-container {
    position: absolute;
    /* 
      THIS IS WHAT MOVES THE BAR UP AND DOWN ON THE SCREEN.
      'bottom: 0;' anchors it to the bottom of its parent container.
      You can change this to a pixel value like 'bottom: 10px;' to move it up,
      or even change it to 'top: 0;' to anchor it to the top.
    */
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 200px;
    background-color: rgba(0, 0, 0, 0.6);
    padding: 5px 8px;
    border-radius: 8px;
    color: white;
    text-align: center;
    font-family: 'Oswald', sans-serif;
    z-index: 20;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.score-progress-label {
    font-size: 1em;
    margin-bottom: 4px;
    text-shadow: 1px 1px 1px black;
}

.score-progress-bar-background {
    width: 100%;
    height: 12px;
    background-color: #333;
    border-radius: 5px;
    border: 1px solid #555;
    overflow: hidden;
}

.score-progress-bar-foreground {
    height: 100%;
    border-radius: 4px;
    transition: width 0.5s ease-in-out;
}

.learner-pile-details {
    display: none;
}
--- END FILE: frontend/src/components/game/LearnerDisplay.css ---

--- START FILE: frontend/src/components/game/PlayerHand.js ---
import React, { useState, useEffect, useCallback } from 'react';
import { RANKS_ORDER, SUIT_SORT_ORDER } from '../../constants';

// Helper function for card sorting
const getSuitLocal = (cardStr) => cardStr.slice(-1);
const getRankLocal = (cardStr) => cardStr.slice(0, -1);

const sortHandBySuit = (handArray) => {
    if (!handArray) return [];
    return [...handArray].sort((a, b) => {
        const suitAIndex = SUIT_SORT_ORDER.indexOf(getSuitLocal(a));
        const suitBIndex = SUIT_SORT_ORDER.indexOf(getSuitLocal(b));
        const rankAIndex = RANKS_ORDER.indexOf(getRankLocal(a));
        const rankBIndex = RANKS_ORDER.indexOf(getRankLocal(b));
        if (suitAIndex !== suitBIndex) return suitAIndex - suitBIndex;
        return rankAIndex - rankBIndex;
    });
};

const PlayerHand = ({
    currentTableState,
    selfPlayerName,
    isSpectator,
    emitEvent,
    renderCard
}) => {
    const [selectedDiscards, setSelectedDiscards] = useState([]);

    const { state, hands, bidWinnerInfo, revealedWidowForFrog } = currentTableState;
    const myHand = hands[selfPlayerName] || [];

    useEffect(() => {
        if (state !== "Frog Widow Exchange") {
            setSelectedDiscards([]);
        }
    }, [state]);

    const handleToggleFrogDiscard = useCallback((card) => {
        setSelectedDiscards(prev =>
            prev.includes(card) ? prev.filter(c => c !== card) : [...prev, card]
        );
    }, []);

    const handlePlayCard = useCallback((card) => {
        emitEvent("playCard", { card });
    }, [emitEvent]);


    if (state === "Frog Widow Exchange" && bidWinnerInfo?.playerName === selfPlayerName) {
        return (
            <div style={{ backgroundColor: 'rgba(0,0,0,0.7)', padding: '15px', borderRadius: '10px', width: '100%', textAlign: 'center' }}>
                <p style={{color: 'white'}}>You took the widow. Select 3 cards from your hand to discard:</p>
                <div style={{ display: 'flex', justifyContent: 'center', gap: '5px', marginBottom: '15px', color: 'white' }}>
                    <span>Revealed Widow:</span>
                    {(revealedWidowForFrog || []).map((card, index) => renderCard(card, { key: `widow-${index}` }))}
                </div>
                <div style={{ display: 'flex', flexWrap: 'wrap', justifyContent: 'center', gap: '5px', maxHeight: '150px', overflowY: 'auto', padding: '10px', backgroundColor: 'rgba(255,255,255,0.1)', borderRadius: '5px' }}>
                    {sortHandBySuit(myHand).map(card => renderCard(card, {
                        key: card,
                        isButton: true,
                        onClick: () => handleToggleFrogDiscard(card),
                        isSelected: selectedDiscards.includes(card)
                    }))}
                </div>
                <button
                    onClick={() => emitEvent("submitFrogDiscards", { discards: selectedDiscards })}
                    className="game-button"
                    disabled={selectedDiscards.length !== 3}
                    style={{ marginTop: '10px' }}>
                    Confirm Discards ({selectedDiscards.length}/3)
                </button>
            </div>
        );
    }

    if (isSpectator || !myHand.length) {
        return (
            <div style={{ textAlign: 'center', padding: '20px', fontStyle: 'italic', flex: 1, color: 'white' }}>
                {isSpectator ? "Spectators cannot see player hands." : "Waiting for next hand..."}
            </div>
        );
    }

    const myHandToDisplay = sortHandBySuit(myHand);
    const isMyTurnToPlay = state === "Playing Phase" && currentTableState.trickTurnPlayerName === selfPlayerName;

    return (
        <div style={{ flexGrow: 1, display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
            {/* --- MODIFICATION: Added a className for responsive styling --- */}
            <div className="player-hand-cards">
                {myHandToDisplay.map((card, index) => renderCard(card, {
                    key: card,
                    isButton: true,
                    onClick: () => handlePlayCard(card),
                    disabled: !isMyTurnToPlay,
                    style: { animation: `fadeIn 0.5s ease-out forwards`, animationDelay: `${index * 0.05}s`, opacity: 0 }
                }))}
            </div>
        </div>
    );
};

export default PlayerHand;
--- END FILE: frontend/src/components/game/PlayerHand.js ---

--- START FILE: frontend/src/components/game/PlayerSeat.css ---
/* frontend/src/components/game/PlayerSeat.css */

.player-seat-wrapper {
    position: relative;
}

.player-seat {
    text-align: center;
    padding: 8px 12px;
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    min-width: 150px;
    border: 2px solid #ccc; /* Default border */
    white-space: nowrap;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
}

.player-name {
    font-weight: bold;
    font-size: 1.1em;
}
.player-name.is-self {
    color: #15803d; /* Dark Green */
}

.player-stats-line {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9em;
}

.token-icon-inline {
    height: 14px;
    vertical-align: middle;
}
.info-divider {
    color: #aaa;
}

/* State & Role Borders */
.player-seat.disconnected { border-color: red; }
.player-seat.bid-winner { border-color: #ffc107; }
.player-seat.defender { border-color: #0d6efd; }
.player-seat.active-turn { animation: pulsing-glow 1.5s infinite; }

/* Puck Styles */
.puck {
    position: absolute;
    top: -12px;
    border-radius: 50%;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.7em;
    font-weight: bold;
    border: 1px solid black;
    z-index: 5;
    font-family: 'Oswald', sans-serif;
}
.dealer-puck { right: -12px; background-color: ivory; color: black; }
.role-puck { left: -12px; }
.role-puck.bid-winner { background-color: #ffc107; color: black; }
.role-puck.defender { background-color: #0d6efd; color: white; }
.role-puck.small-font { font-size: 0.6em; }

/* Disconnected Controls */
.disconnected-controls { margin-top: 5px; }
.start-timer-button {
    padding: 4px 8px;
    font-size: 0.8em;
    background-color: #ffc107;
    color: black;
    border: 1px solid #c69500;
    border-radius: 4px;
    cursor: pointer;
    font-family: 'Oswald', sans-serif;
}
.timeout-display { font-weight: bold; color: #dc3545; font-size: 0.9em; }

/* Token and Score Styles */
.player-tokens, .player-score { font-weight: bold; display: flex; align-items: center; }
.player-tokens { color: #b45309; }
.player-score { color: #444; }

/* --- NEW STYLES FOR THE ERROR TOOLTIP --- */
.player-error-tooltip {
    position: absolute;
    bottom: -35px; /* Position it below the player seat */
    left: 50%;
    transform: translateX(-50%);
    background-color: #b91c1c; /* Dark red */
    color: white;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 0.9em;
    font-weight: bold;
    z-index: 15;
    white-space: nowrap;
    animation: fadeInAndOut 4s ease-in-out forwards;
}

@keyframes fadeInAndOut {
    0% { opacity: 0; transform: translate(-50%, 10px); }
    10% { opacity: 1; transform: translate(-50%, 0); }
    90% { opacity: 1; transform: translate(-50%, 0); }
    100% { opacity: 0; transform: translate(-50%, 10px); }
}
--- END FILE: frontend/src/components/game/PlayerSeat.css ---

--- START FILE: frontend/src/components/game/PlayerSeat.js ---
// frontend/src/components/game/PlayerSeat.js
import React from 'react';
import './PlayerSeat.css'; // Import the CSS file

const PlayerSeat = ({ playerName, currentTableState, isSelf, emitEvent }) => {
    if (!playerName) {
        return null; 
    }

    const {
        players,
        scores,
        dealer,
        bidWinnerInfo,
        trumpSuit,
        playerOrderActive,
        trickTurnPlayerName,
        forfeiture,
        roundSummary,
        playerTokens 
    } = currentTableState;

    const playerEntry = Object.values(players).find(p => p.playerName === playerName);

    if (!playerEntry) {
        return null;
    }

    const { userId, disconnected } = playerEntry;
    const playerTokenCount = playerTokens?.[playerName] ?? roundSummary?.playerTokens?.[playerName];
    const isDealer = dealer === userId;
    const isBidWinner = bidWinnerInfo?.playerName === playerName;
    const isDefender = bidWinnerInfo && !isBidWinner && playerOrderActive.includes(playerName);
    const isTimerRunningForThisPlayer = forfeiture?.targetPlayerName === playerName;
    const isMyTurn = trickTurnPlayerName === playerName;

    let rolePuckContent = null;
    if (isBidWinner) {
        switch (bidWinnerInfo.bid) {
            case "Frog": rolePuckContent = "FROG"; break;
            case "Heart Solo": rolePuckContent = "H-S"; break;
            case "Solo": rolePuckContent = `${trumpSuit}-S`; break;
            default: break;
        }
    } else if (isDefender) {
        rolePuckContent = "TEAM";
    }

    const seatClasses = [
        'player-seat',
        isBidWinner && 'bid-winner',
        isDefender && 'defender',
        disconnected && 'disconnected',
        isMyTurn && 'active-turn'
    ].filter(Boolean).join(' ');

    const nameClasses = ['player-name', isSelf && 'is-self'].filter(Boolean).join(' ');
    
    const rolePuckClasses = [
        'puck', 
        'role-puck', 
        isBidWinner ? 'bid-winner' : 'defender', 
        rolePuckContent?.length > 3 && 'small-font'
    ].filter(Boolean).join(' ');

    const handleStartTimer = () => {
        emitEvent("startTimeoutClock", { targetPlayerName: playerName });
    };

    return (
        <div className="player-seat-wrapper">
            {isDealer && <div className="puck dealer-puck">D</div>}
            {rolePuckContent && <div className={rolePuckClasses}>{rolePuckContent}</div>}

            <div className={seatClasses}>
                <div className={nameClasses}>{playerName}</div>
                <div className="player-stats-line">
                    <span className="player-tokens">
                        <img src="/sluff_token.png" alt="Tokens" className="token-icon-inline" />
                        {playerTokenCount !== undefined ? parseFloat(playerTokenCount).toFixed(2) : '...'}
                    </span>
                    <span className="info-divider">|</span>
                    <span className="player-score">Points: {scores[playerName] ?? '120'}</span>
                </div>
                
                {disconnected && (
                    <div className="disconnected-controls">
                        {isTimerRunningForThisPlayer ? (
                            <div className="timeout-display">
                                Time Left: {forfeiture.timeLeft}s
                            </div>
                        ) : (
                            <button className="start-timer-button" onClick={handleStartTimer}>
                                Start 2-Min Timer
                            </button>
                        )}
                    </div>
                )}
            </div>
        </div>
    );
};

export default PlayerSeat;
--- END FILE: frontend/src/components/game/PlayerSeat.js ---

--- START FILE: frontend/src/components/game/PointsBreakdownBar.css ---
/* frontend/src/components/game/PointsBreakdownBar.css */

.points-breakdown-container {
    position: relative;
    padding-top: 20px; 
    margin-bottom: 10px;
}

.points-bar {
    display: flex;
    width: 100%;
    height: 50px;
    border-radius: 8px;
    overflow: hidden;
    position: relative;
    background-color: #8b5cf6; /* Defender color as fallback */
    border: 1px solid #a7a7a7;
}

/* The vertical "Break Even" line */
.points-bar::after {
    content: '';
    position: absolute;
    left: 50%;
    top: 0;
    bottom: 0;
    width: 3px;
    background-color: #a7f3d0; /* A light, minty green */
    transform: translateX(-1.5px);
    z-index: 2;
}

.break-even-label {
    position: absolute;
    top: -5px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #0d6efd;
    color: white;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 0.7em;
    font-family: 'Oswald', sans-serif;
}

.points-bar-bidder,
.points-bar-defender {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 15px;
    color: white;
    font-family: 'Oswald', sans-serif;
    transition: width 0.5s ease-in-out;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

.points-bar-bidder {
    background-color: #166534; /* Dark Green */
    flex-shrink: 0; 
}

.points-bar-defender {
    background-color: #8b5cf6; /* Purple */
    flex-grow: 1; 
}

/* --- NEW STYLES for displaying info inside the bar --- */
.player-info {
    display: flex;
    flex-direction: column;
    align-items: center;
    line-height: 1.1;
}

.player-name {
    font-size: 1.1em;
    font-weight: normal;
}

.player-points {
    font-size: 1.3em;
    font-weight: bold;
}
--- END FILE: frontend/src/components/game/PointsBreakdownBar.css ---

--- START FILE: frontend/src/components/game/PointsBreakdownBar.js ---
import React from 'react';
import './PointsBreakdownBar.css';

const PointsBreakdownBar = ({ bidderName, bidderPoints, defenderNames, defenderPoints }) => {
    const totalPoints = 120;
    const bidderWidth = (bidderPoints / totalPoints) * 100;

    return (
        <div className="points-breakdown-container">
            <div className="points-bar">
                {/* The visual "break even" line is handled by the ::after pseudo-element in CSS */}
                <div className="points-bar-bidder" style={{ width: `${bidderWidth}%` }}>
                    <div className="player-info">
                        <span className="player-name">{bidderName}</span>
                        <span className="player-points">{bidderPoints} pts</span>
                    </div>
                </div>
                <div className="points-bar-defender">
                    <div className="player-info">
                        <span className="player-name">{defenderNames.join(', ')}</span>
                        <span className="player-points">{defenderPoints} pts</span>
                    </div>
                </div>
            </div>
            <div className="break-even-label">Break Even Line</div>
        </div>
    );
};

export default PointsBreakdownBar;
--- END FILE: frontend/src/components/game/PointsBreakdownBar.js ---

--- START FILE: frontend/src/components/game/RoundSummaryModal.css ---
/* frontend/src/components/game/RoundSummaryModal.css */

.summary-modal-content {
    background-color: #f8f9fa;
    padding: 0;
    border-radius: 12px;
    width: 90%;
    max-width: 550px;
    text-align: center;
    font-family: 'Merriweather', serif;
    max-height: 90vh;
    display: flex;
    flex-direction: column;
    overflow: hidden; 
}

.summary-main-area {
    padding: 20px 25px;
    overflow-y: auto; 
}

.summary-main-area h2 {
    font-family: 'Oswald', sans-serif;
    color: #343a40;
    margin: 0 0 10px 0;
}

.summary-message {
    font-style: italic;
    color: #6c757d;
    margin-bottom: 20px;
}

.summary-points-section {
    background-color: #f0f0f0;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
}

.summary-points-section h4 {
    margin: 0 0 10px 0;
    font-family: 'Oswald', sans-serif;
}

/* --- NEW STYLES for the calculation recap --- */
.point-calculation-recap {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    margin: 15px 0 10px 0;
    padding: 8px;
    background-color: #e9ecef;
    border-radius: 6px;
    font-size: 0.9em;
    color: #495057;
    flex-wrap: wrap; /* Allow wrapping on small screens */
}

.point-calculation-recap strong {
    color: #212529;
    font-size: 1.1em;
}

.recap-divider {
    font-size: 1.2em;
    font-weight: bold;
    color: #6c757d;
}
/* --- END NEW STYLES --- */


.point-changes-list {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-top: 10px;
    font-family: 'Oswald', sans-serif;
}

.point-change-item {
    font-size: 1.1em;
}

.point-change-item .positive {
    color: #15803d; /* Dark Green */
    font-weight: bold;
}

.point-change-item .negative {
    color: #b91c1c; /* Dark Red */
    font-weight: bold;
}

.what-if-panel {
    border: 2px dashed #0d6efd;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
    background-color: #f7f9ff;
}

.what-if-title {
    font-family: 'Oswald', sans-serif;
    color: #0d6efd;
    margin: -15px -15px 10px -15px;
    padding: 8px 15px;
    background-color: #e0eafc;
    border-top-left-radius: 6px;
    border-top-right-radius: 6px;
    border-bottom: 1px solid #c4d5f5;
}


.summary-scores-container {
    background-color: #e9ecef;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 15px;
}

.summary-scores-container h4 {
    margin: 0 0 10px 0;
    font-family: 'Oswald', sans-serif;
}

.summary-score-list {
    list-style: none;
    padding: 0;
    margin: 0;
    columns: 2; 
    -webkit-columns: 2;
    -moz-columns: 2;
}

.summary-score-list li {
    text-align: left;
    padding: 2px 5px;
}

.insurance-deal-recap {
    background-color: #d1e7dd;
    border: 1px solid #a3cfbb;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
    text-align: left;
}

.insurance-deal-recap .recap-title {
    margin: 0 0 10px 0;
    font-family: 'Oswald', sans-serif;
    color: #0a3622;
}

.insurance-deal-recap p {
    margin: 0 0 5px 0;
}

.insurance-deal-recap ul {
    padding-left: 20px;
    margin: 0;
}

.insurance-hindsight {
    background-color: #eef2ff;
    border: 1px solid #a5b4fc;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
}

.hindsight-title {
    margin: 0 0 10px 0;
    font-family: 'Oswald', sans-serif;
    color: #1e3a8a;
}

.hindsight-text {
    margin: 3px 0;
    font-size: 0.9em;
}

.summary-details-section {
    background-color: #dee2e6;
    padding: 10px;
}

.details-toggle {
    background: none;
    border: 1px solid #6c757d;
    border-radius: 5px;
    padding: 8px 12px;
    cursor: pointer;
    font-family: 'Oswald', sans-serif;
    color: #495057;
    width: 100%;
}

.details-content {
    padding: 15px;
    background-color: white;
    margin-top: 10px;
    border-radius: 5px;
}

.summary-action-area {
    margin-top: auto;
    background-color: #e9ecef;
    padding: 15px;
    border-top: 1px solid #ced4da;
}

.forfeit-payout-section {
    margin: 15px 0 0 0;
    padding: 10px;
    background-color: #f8d7da;
    border: 1px solid #f5c6cb;
    border-radius: 8px;
    text-align: left;
}

.forfeit-payout-section h4 {
    margin-top: 0;
    color: #721c24;
}

.forfeit-payout-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.game-over-actions {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
}

.trick-breakdown-details {
    text-align: left;
}

.team-trick-section {
    margin-bottom: 15px;
}

.team-trick-section h4 {
    font-family: 'Oswald', sans-serif;
    margin: 0 0 8px 0;
    border-bottom: 1px solid #ddd;
    padding-bottom: 5px;
}

.trick-detail-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.9em;
    padding: 2px 0;
}

.trick-detail-row.widow-row {
    background-color: #fff3cd; /* Highlight the widow row */
    padding: 4px 2px;
    border-radius: 4px;
    margin-top: 5px;
}

.trick-number {
    font-weight: bold;
    color: #555;
    min-width: 60px;
}

.trick-cards {
    flex-grow: 1;
}

.trick-points {
    font-weight: bold;
    min-width: 50px;
    text-align: right;
}

.scrollable-tricks {
    max-height: 250px;
    overflow-y: auto;
}
--- END FILE: frontend/src/components/game/RoundSummaryModal.css ---

--- START FILE: frontend/src/components/game/RoundSummaryModal.js ---
// frontend/src/components/game/RoundSummaryModal.js
import React, { useState } from 'react';
import './RoundSummaryModal.css';
// --- MODIFICATION: Import BID_MULTIPLIERS ---
import { CARD_POINT_VALUES, BID_MULTIPLIERS } from '../../constants';
import PointsBreakdownBar from './PointsBreakdownBar';

const RoundSummaryModal = ({
    summaryData,
    showModal,
    playerId,
    getPlayerNameByUserId,
    renderCard,
    emitEvent,
    insurance,
    bidWinnerInfo,
    playerOrderActive,
    handleLeaveTable,
    handleLogout
}) => {
    const [detailsVisible, setDetailsVisible] = useState(false);

    if (!showModal || !summaryData) {
        return null;
    }

    const {
        message,
        finalScores,
        isGameOver,
        gameWinner,
        dealerOfRoundId,
        widowForReveal,
        insuranceHindsight,
        allTricks,
        payouts,
        finalBidderPoints,
        finalDefenderPoints,
        pointChanges,
        widowPointsValue,
        bidType
    } = summaryData;
    
    const insuranceAgreement = insurance?.executedDetails?.agreement;
    
    const bidderName = bidWinnerInfo?.playerName || 'Bidder';
    const defenderNames = playerOrderActive?.filter(name => name !== bidderName) || ['Defenders'];

    const calculateCardPoints = (cards) => {
        if (!cards || cards.length === 0) return 0;
        return cards.reduce((sum, cardString) => {
            const rank = cardString.slice(0, -1);
            return sum + (CARD_POINT_VALUES[rank] || 0);
        }, 0);
    };

    // --- NEW: Calculations for the points breakdown text ---
    const rawDifference = Math.abs(finalBidderPoints - 60);
    const bidMultiplier = BID_MULTIPLIERS[bidType] || 1;
    const exchangeValue = rawDifference * bidMultiplier;

    const pointsPanelContent = (
        <div className="summary-points-section">
            <h4>Points Captured</h4>
            <PointsBreakdownBar
                bidderName={bidderName}
                bidderPoints={finalBidderPoints}
                defenderNames={defenderNames}
                defenderPoints={finalDefenderPoints}
            />
            {/* --- MODIFICATION: Replaced the old text with the new calculation breakdown --- */}
            <div className="point-calculation-recap">
                <span>Difference from Goal: <strong>{rawDifference}</strong> pts</span>
                <span className="recap-divider">Ãƒâ€”</span>
                <span>Bid Multiplier: <strong>{bidMultiplier}x</strong> ({bidType})</span>
                <span className="recap-divider">=</span>
                <span>Exchange Value: <strong>{exchangeValue}</strong> pts</span>
            </div>
            <div className="point-changes-list">
                {pointChanges && Object.entries(pointChanges).map(([name, change]) => (
                    name !== 'ScoreAbsorber' &&
                    <div key={name} className="point-change-item">
                        {name}: <span className={change > 0 ? 'positive' : 'negative'}>{change > 0 ? `+${change}` : change}</span>
                    </div>
                ))}
            </div>
        </div>
    );
    
    const renderTrickDetails = () => {
        if (!allTricks) return null;
        let trickCounter = 1;

        const bidderTotal = finalBidderPoints;
        const defenderTotal = finalDefenderPoints;
        
        return (
            <div className="trick-breakdown-details">
                <div className="team-trick-section">
                    <h4>Bidder Total ({bidderName}): {bidderTotal} pts</h4>
                     {Object.entries(allTricks).filter(([pName]) => pName === bidderName).flatMap(([_, tricks]) => tricks).map((trick, i) => (
                        <div key={`bidder-trick-${i}`} className="trick-detail-row">
                            <span className="trick-number">Trick {trickCounter++}:</span>
                            <span className="trick-cards">{trick.join(', ')}</span>
                            <span className="trick-points">({calculateCardPoints(trick)} pts)</span>
                        </div>
                    ))}
                    {widowPointsValue > 0 && (
                        <div className="trick-detail-row widow-row">
                            <span className="trick-number">Widow:</span>
                            <span className="trick-cards">{widowForReveal.join(', ')}</span>
                            <span className="trick-points">({widowPointsValue} pts)</span>
                        </div>
                    )}
                </div>
                <div className="team-trick-section">
                    <h4>Defender Total ({defenderNames.join(', ')}): {defenderTotal} pts</h4>
                     {Object.entries(allTricks).filter(([pName]) => pName !== bidderName).flatMap(([_, tricks]) => tricks).map((trick, i) => (
                        <div key={`defender-trick-${i}`} className="trick-detail-row">
                            <span className="trick-number">Trick {trickCounter++}:</span>
                            <span className="trick-cards">{trick.join(', ')}</span>
                            <span className="trick-points">({calculateCardPoints(trick)} pts)</span>
                        </div>
                    ))}
                </div>
            </div>
        );
    };

    return (
        <div className="modal-overlay">
            <div className="summary-modal-content">
                <div className="summary-main-area">
                    <h2>{isGameOver ? "Game Over" : "Round Over"}</h2>
                    <p className="summary-message">{isGameOver ? `Winner: ${gameWinner}` : message}</p>

                    {summaryData.insuranceDealWasMade ? (
                        <div className="what-if-panel">
                            <h4 className="what-if-title">How Points Would Have Been Calculated</h4>
                            {pointsPanelContent}
                        </div>
                    ) : (
                        pointsPanelContent
                    )}
                    
                    {insuranceAgreement && (
                        <div className="insurance-deal-recap">
                            <h4 className="recap-title">Insurance Deal Recap</h4>
                            <p><strong>{insuranceAgreement.bidderPlayerName}</strong> (Bidder) asked for <strong>{insuranceAgreement.bidderRequirement}</strong> points.</p>
                            <ul>
                                {Object.entries(insuranceAgreement.defenderOffers).map(([name, offer]) => (
                                    <li key={name}><strong>{name}</strong> offered <strong>{offer}</strong> points.</li>
                                ))}
                            </ul>
                        </div>
                    )}

                    {insuranceHindsight && (
                        <div className="insurance-hindsight">
                            <h4 className="hindsight-title">Insurance Hindsight</h4>
                             {Object.entries(insuranceHindsight).map(([pName, data]) => (
                                <p key={pName} className="hindsight-text">
                                    <strong>{pName}:</strong> Your decision <strong>{data.hindsightValue >= 0 ? 'saved' : 'wasted'} {Math.abs(data.hindsightValue)}</strong> points.
                                </p>
                            ))}
                        </div>
                    )}

                    <div className="summary-scores-container">
                        <h4>Updated Scores</h4>
                        <ul className="summary-score-list">
                            {Object.entries(finalScores).map(([name, score]) => (
                               <li key={name}><strong>{name}:</strong> {score}</li>
                            ))}
                        </ul>
                        {payouts && (
                             <div className="forfeit-payout-section">
                                <h4>Forfeit Payouts:</h4>
                                <ul className="forfeit-payout-list">
                                    {Object.entries(payouts).map(([pName, details]) => (
                                        <li key={pName}>
                                            <strong>{pName}:</strong> Received {details.totalGain.toFixed(2)} tokens
                                        </li>
                                    ))}
                                </ul>
                            </div>
                        )}
                    </div>
                </div>

                <div className="summary-details-section">
                    <button className="details-toggle" onClick={() => setDetailsVisible(!detailsVisible)}>
                        {detailsVisible ? 'Hide Round Details' : 'Show Round Details'}
                    </button>
                    {detailsVisible && (
                        <div className="details-content">
                            <h4 style={{marginTop: '0px'}}>Trick Breakdown</h4>
                             <div className="scrollable-tricks">
                                {renderTrickDetails()}
                            </div>
                        </div>
                    )}
                </div>
                
                <div className="summary-action-area">
                    {!isGameOver && playerId === dealerOfRoundId && (
                        <button onClick={() => emitEvent("requestNextRound")} className="game-button">
                            Start Next Round
                        </button>
                    )}
                    {!isGameOver && playerId !== dealerOfRoundId && (
                        <p>Waiting for {getPlayerNameByUserId(dealerOfRoundId)} to start the next round...</p>
                    )}
                    {isGameOver && (
                        <div className="game-over-actions">
                             <button onClick={() => emitEvent("resetGame")} className="game-button">
                                Play Again
                            </button>
                            <button onClick={handleLeaveTable} className="game-button" style={{backgroundColor: '#17a2b8'}}>
                                Back to Lobby
                            </button>
                             <button onClick={handleLogout} className="game-button" style={{backgroundColor: '#6c757d'}}>
                                Logout
                            </button>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

export default RoundSummaryModal;
--- END FILE: frontend/src/components/game/RoundSummaryModal.js ---

--- START FILE: frontend/src/components/game/ScoreProgressBar.js ---
import React from 'react';

/**
 * A generic progress bar for displaying point accumulation.
 */
const ScoreProgressBar = ({ currentPoints, opponentPoints, barColor }) => {
    const goalPoints = 60;
    const maxPossible = 120 - opponentPoints;
    const progressPercent = Math.min((currentPoints / goalPoints) * 100, 100);

    return (
        <div className="score-progress-container">
            {/* --- MODIFICATION: Updated the label format --- */}
            <div className="score-progress-label">
                <strong>{currentPoints}</strong> of <strong>{goalPoints}</strong> Goal | <strong>{maxPossible}</strong> Max
            </div>
            <div className="score-progress-bar-background">
                <div 
                    className="score-progress-bar-foreground"
                    style={{ 
                        width: `${progressPercent}%`,
                        background: barColor 
                    }}
                >
                </div>
            </div>
        </div>
    );
};

export default ScoreProgressBar;
--- END FILE: frontend/src/components/game/ScoreProgressBar.js ---

--- START FILE: frontend/src/components/game/TableLayout.js ---
// frontend/src/components/game/TableLayout.js
import React, { useState } from 'react';
import ScoreProgressBar from './ScoreProgressBar';
import './KeyAndModal.css';
import { SUIT_SYMBOLS } from '../../constants';

const TableLayout = ({
    currentTableState,
    seatAssignments,
    isSpectator,
    renderCard,
    PlayerSeat,
    ActionControls,
    selfPlayerName,
    playerId,
    emitEvent,
}) => {
    const [lastTrickVisible, setLastTrickVisible] = useState(false);

    const renderPlayedCardsOnTable = () => {
        const isLingerState = currentTableState.state === 'TrickCompleteLinger';
        const cardsToDisplay = isLingerState ? currentTableState.lastCompletedTrick.cards : currentTableState.currentTrickCards;

        if (!cardsToDisplay || cardsToDisplay.length === 0 || isSpectator) {
            return null;
        }

        const getPlayedCardForPlayer = (pName) => {
            if (!pName) return renderCard(null, { large: true });
            const cardInfo = (cardsToDisplay || []).find(c => c.playerName === pName);
            return renderCard(cardInfo?.card, { large: true });
        };

        return (
            <>
                <div style={{ position: 'absolute', bottom: '25%', left: '50%', transform: 'translateX(-50%)' }}>
                    {getPlayedCardForPlayer(seatAssignments.self)}
                </div>
                <div style={{ position: 'absolute', top: '50%', left: '25%', transform: 'translateY(-50%)' }}>
                    {getPlayedCardForPlayer(seatAssignments.opponentLeft)}
                </div>
                <div style={{ position: 'absolute', top: '50%', right: '25%', transform: 'translateY(-50%)' }}>
                    {getPlayedCardForPlayer(seatAssignments.opponentRight)}
                </div>
            </>
        );
    };

    const renderLastTrickDisplay = () => {
        const { lastCompletedTrick, bidWinnerInfo } = currentTableState;
        if (!lastCompletedTrick || !bidWinnerInfo) {
            return null;
        }

        const winnerIsBidder = lastCompletedTrick.winnerName === bidWinnerInfo.playerName;
        const tabContainerClass = `last-trick-tab-container ${winnerIsBidder ? 'bidder' : 'defender'}`;
        const overlayContainerClass = `last-trick-overlay-container ${winnerIsBidder ? 'bidder' : 'defender'}`;

        return (
            <>
                <div className={tabContainerClass}>
                    <button className="last-trick-tab" onClick={() => setLastTrickVisible(!lastTrickVisible)}>
                        Last Trick
                    </button>
                </div>

                {lastTrickVisible && (
                     <div className={overlayContainerClass}>
                        <h4 className="last-trick-header">Last Trick (won by {lastCompletedTrick.winnerName})</h4>
                        <div className="last-trick-cards">
                            {lastCompletedTrick.cards.map(play => (
                                renderCard(play.card, { key: play.card, small: true })
                            ))}
                        </div>
                    </div>
                )}
            </>
        );
    };
    
    const renderTrickTallyPiles = () => {
        const { theme, state, capturedTricks, bidWinnerInfo, playerOrderActive, bidderCardPoints, defenderCardPoints } = currentTableState;
        if (!bidWinnerInfo) return null;

        const isLearnerTable = theme === 'miss-pauls-academy';
        
        const bidderName = bidWinnerInfo.playerName;
        const bidderTricksCount = capturedTricks[bidderName]?.length || 0;
        const defenderTricksCount = playerOrderActive.reduce((acc, pName) => {
            if (pName !== bidderName) {
                return acc + (capturedTricks[pName]?.length || 0);
            }
            return acc;
        }, 0);

        const TrickPile = ({ count, label, children }) => (
            <div className="trick-pile">
                <div className="trick-pile-cards">
                    {count === 0 ? (
                        renderCard(null, { isFaceDown: true, style: { opacity: 0.3 }, small: true })
                    ) : (
                        Array.from({ length: count }).map((_, i) => (
                            <div key={i} className="trick-pile-card-wrapper" style={{ transform: `translateY(-${i * 2}px)` }}>
                                {renderCard(null, { isFaceDown: true, small: true })}
                            </div>
                        ))
                    )}
                </div>
                <span className="trick-pile-label">{label}: {count}</span>
                {children}
            </div>
        );

        return (
            <>
                <div className="trick-pile-container defender-pile">
                    <TrickPile count={defenderTricksCount} label="Defenders">
                        {isLearnerTable && state === 'Playing Phase' &&
                            <ScoreProgressBar 
                                currentPoints={defenderCardPoints} 
                                opponentPoints={bidderCardPoints}
                                barColor="linear-gradient(to right, #3b82f6, #60a5fa)"
                            />
                        }
                    </TrickPile>
                </div>
                <div className="trick-pile-container bidder-pile">
                    <TrickPile count={bidderTricksCount} label="Bidder">
                        {isLearnerTable && state === 'Playing Phase' &&
                            <ScoreProgressBar 
                                currentPoints={bidderCardPoints} 
                                opponentPoints={defenderCardPoints}
                                barColor="linear-gradient(to right, #f59e0b, #facc15)"
                            />
                        }
                    </TrickPile>
                </div>
            </>
        );
    };

    const renderWidowDisplay = () => {
        const { state, widow, originalDealtWidow, roundSummary } = currentTableState;
        
        const hiddenStates = ["Waiting for Players", "Ready to Start", "Dealing Pending", "Frog Widow Exchange"];
        if (hiddenStates.includes(state)) {
            return null;
        }

        const isRoundOver = state === 'Awaiting Next Round Trigger' || state === 'Game Over';
        
        const cardsToDisplay = isRoundOver ? roundSummary?.widowForReveal : (widow || originalDealtWidow);
        const widowSize = cardsToDisplay?.length || 0;

        if (widowSize === 0) {
            return null;
        }

        return (
            <div className="widow-display-container">
                <div className="widow-pile">
                    {isRoundOver 
                        ? (
                            cardsToDisplay.map((card, i) => (
                                <div key={card + i} className="trick-pile-card-wrapper" style={{ transform: `translateX(${i * 15}px)` }}>
                                    {renderCard(card, { small: true })}
                                </div>
                            ))
                        ) : (
                            Array.from({ length: widowSize }).map((_, i) => (
                                <div key={i} className="trick-pile-card-wrapper" style={{ transform: `translateX(${i * 15}px)` }}>
                                    {renderCard(null, { isFaceDown: true, small: true })}
                                </div>
                            ))
                        )
                    }
                </div>
                <span className="widow-pile-label">Widow</span>
            </div>
        );
    };

    const renderTrumpIndicatorPuck = () => {
        const { trumpSuit, trumpBroken } = currentTableState;
        if (!trumpSuit) {
            return null;
        }

        const classes = [
            'trump-indicator-puck',
            trumpBroken ? 'broken' : ''
        ].filter(Boolean).join(' ');
        
        const title = trumpBroken ? 'Trump has been broken!' : `Trump is ${trumpSuit}`;

        return (
            <div className={classes} title={title}>
                {SUIT_SYMBOLS[trumpSuit]}
            </div>
        );
    };

    return (
        <main className="game-table">
            <div className="player-seat-left">
                <PlayerSeat playerName={seatAssignments.opponentLeft} currentTableState={currentTableState} isSelf={false} emitEvent={emitEvent} />
            </div>
            <div className="player-seat-right">
                <PlayerSeat playerName={seatAssignments.opponentRight} currentTableState={currentTableState} isSelf={false} emitEvent={emitEvent} />
            </div>

            <div className="table-oval">
                <img 
                    src="/SluffLogo.png" 
                    alt="Sluff Watermark" 
                    style={{
                        position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%)',
                        width: '40%', maxWidth: '350px', opacity: 0.1, pointerEvents: 'none'
                    }} 
                />
                
                {renderWidowDisplay()}
                {renderTrumpIndicatorPuck()}
                {renderTrickTallyPiles()}
                {renderLastTrickDisplay()}

                <div className="player-seat-bottom">
                    <PlayerSeat playerName={seatAssignments.self} currentTableState={currentTableState} isSelf={true} emitEvent={emitEvent} />
                </div>

                {renderPlayedCardsOnTable()}
                
                <div style={{ position: 'absolute', top: '15%', left: '50%', transform: 'translateX(-50%)', zIndex: 10, width: '80%', textAlign: 'center' }}>
                    <ActionControls
                        currentTableState={currentTableState}
                        playerId={playerId}
                        selfPlayerName={selfPlayerName}
                        isSpectator={isSpectator}
                        emitEvent={emitEvent}
                        renderCard={renderCard}
                    />
                </div>
            </div>
        </main>
    );
};

export default TableLayout;
--- END FILE: frontend/src/components/game/TableLayout.js ---

--- START FILE: frontend/src/hooks/useSounds.js ---
import { useState, useEffect, useRef } from 'react';

export const useSounds = () => {
    const sounds = useRef({});
    const [isSoundEnabled, setIsSoundEnabled] = useState(false);

    useEffect(() => {
        sounds.current = {
            turnAlert: new Audio('/Sounds/turn_alert.mp3'),
            cardPlay: new Audio('/Sounds/card_play.mp3'),
            trickWin: new Audio('/Sounds/trick_win.mp3'),
            cardDeal: new Audio('/Sounds/card_dealing_10s_v3.mp3'),
        };
        Object.values(sounds.current).forEach(sound => {
            sound.load();
            sound.volume = 0.7;
        });
    }, []);

    const playSound = (soundName) => {
        if (isSoundEnabled && sounds.current[soundName]) {
            sounds.current[soundName].currentTime = 0;
            sounds.current[soundName].play().catch(e => console.error(`Error playing ${soundName}:`, e));
        }
    };

    const enableSound = () => {
        if (!isSoundEnabled) {
            console.log("Audio context unlocked by user interaction. Sounds are now enabled.");
            setIsSoundEnabled(true);
        }
    };

    return { playSound, enableSound };
};
--- END FILE: frontend/src/hooks/useSounds.js ---

--- START FILE: frontend/src/services/api.js ---
/**
 * Centralized API service module.
 * Handles all HTTP communication with the backend, providing a clean interface for components.
 */

const SERVER_URL = "https://sluff-backend.onrender.com";

/**
 * A generic, configured fetch request helper.
 * @param {string} endpoint - The API endpoint to hit (e.g., '/api/auth/login').
 * @param {string} method - The HTTP method (e.g., 'POST', 'GET').
 * @param {object} [body=null] - The request body for POST/PUT requests.
 * @param {boolean} [requiresAuth=true] - Whether the request requires an Authorization token.
 * @returns {Promise<Response>} The raw fetch response object.
 */
const configuredFetch = async (endpoint, method, body = null, requiresAuth = true) => {
    const headers = { 'Content-Type': 'application/json' };
    
    if (requiresAuth) {
        const token = localStorage.getItem("sluff_token");
        if (!token) {
            // This immediate throw can be caught by the calling function
            throw new Error("Authentication token not found.");
        }
        headers['Authorization'] = `Bearer ${token}`;
    }

    const config = {
        method: method,
        headers: headers,
    };

    if (body) {
        config.body = JSON.stringify(body);
    }

    return fetch(`${SERVER_URL}${endpoint}`, config);
};


// --- Auth Service Calls ---

export const login = async (email, password) => {
    const response = await configuredFetch('/api/auth/login', 'POST', { email, password }, false);
    const data = await response.json();
    if (!response.ok) {
        throw new Error(data.message || 'Failed to login');
    }
    return data;
};

export const register = async (username, email, password) => {
    const response = await configuredFetch('/api/auth/register', 'POST', { username, email, password }, false);
    const data = await response.json();
    if (!response.ok) {
        throw new Error(data.message || 'Failed to register');
    }
    // Register doesn't return data to the app, so we just check for success
    return;
};

// --- Leaderboard Service Calls ---

export const getLeaderboard = async () => {
    const response = await configuredFetch('/api/leaderboard', 'GET');
    const data = await response.json();
    if (!response.ok) {
        throw new Error(data.message || 'Failed to fetch leaderboard data.');
    }
    return data;
};

// --- Admin Service Calls ---

export const generateSchema = async () => {
    const response = await configuredFetch('/api/admin/generate-schema', 'POST');
    // This endpoint returns plain text, not JSON
    const responseText = await response.text();
    if (!response.ok) {
        throw new Error(responseText);
    }
    return responseText;
};

// --- Lobby Chat Service Calls ---

export const getLobbyChatHistory = async () => {
    const response = await configuredFetch('/api/chat', 'GET');
    const data = await response.json();
    if (!response.ok) {
        throw new Error(data.message || 'Failed to fetch chat history.');
    }
    return data;
};

export const sendLobbyChatMessage = async (message) => {
    const response = await configuredFetch('/api/chat', 'POST', { message });
    const data = await response.json();
    if (!response.ok) {
        throw new Error(data.message || 'Failed to send chat message.');
    }
    return data;
};
--- END FILE: frontend/src/services/api.js ---

